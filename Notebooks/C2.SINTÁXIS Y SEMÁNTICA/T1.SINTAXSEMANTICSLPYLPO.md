---
elm:
  source-directories:
    - ../../elm-sources/src
  dependencies:
      elm/browser: latest
      elm/core: latest
      elm/file: latest
      elm/html: latest
      elm/parser: latest
      elm-community/graph: latest
      elm-community/list-extra: latest
      elm-community/maybe-extra: latest
      munksgaard/char-extra: latest
      gicentre/elm-vegalite: latest
      avh4/elm-fifo: latest
      elm/bytes: latest
      elm/json: latest
      elm/time: latest
      elm/url: latest
      elm/virtual-dom: latest
      elm-community/intdict: latest
      Chadtech/elm-bool-extra: latest
---

<!-- Cargamos algunas funciones js que necesitamos -->

<script src="../js/d3.min.js"></script>
<script src="../js/viz.js" type="javascript/worker"></script>
<script src="../js/d3-graphviz.js"></script>
<script type="text/javascript">        	
    function plotDot(idDiv, text){
        d3.select(idDiv).graphviz()
        	.fade(false)
        	.renderDot(text).src;
        };
</script>


## **TEMA 1**
Sintaxis y Sem√°ntica en LP y LPO
====================

Descripci√≥n general del cap√≠tulo
--------------------------------

En este cap√≠tulo se recogen, de forma detallada, los m√≥dulos implementados que abordan el √°mbito de la sintaxis y sem√°ntica de la L√≥gica Proposicional y Primer Orden. Complementariamente, en el *Anexo A. Parsers* se encuentra el desarrollo de varios Parsers, que nos permiten acercar la escritura natural de las f√≥rmulas a la definici√≥n en el sistema.

### <u> Estructura del cap√≠tulo </u>

El cap√≠tulo se encuentra estructurado en distintas secciones, a trav√©s de las cuales se abordan los conceptos fundamentales del √°mbito sint√°ctico-sem√°ntico de la LP y la LPO, presentados conjuntamente con los m√≥dulos que implementan dichos conceptos:

-   **M√≥dulo SintaxSemanticsLP**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sint√°cticoS Y sem√°nticos de la L√≥gica Proposicional.

-   **M√≥dulo SintaxSemanticsLPO**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sint√°cticos y sem√°nticos de la L√≥gica de Primer Orden.

-   **M√≥dulo IO\_LP**. Recoge las implementaciones de los m√©todos relacionados con la lectura y representaci√≥n de las f√≥rmulas LP.

-   **M√≥dulo IO\_LPO**. Recoge las implementaciones de los m√©todos relacionados con la lectura y representaci√≥n de las f√≥rmulas LPO.


1.1. Conceptos b√°sicos de la L√≥gica Proposicional
--------------------------------------------

### Caracterizaci√≥n b√°sica de la L√≥gica Proposicional

La L√≥gica surge como m√©todo de modelado del siguiente problema:

> *Dado un conjunto de asertos (afirmaciones), $\mathcal{BC}$ (*Base de conocimiento*), y una afirmaci√≥n, $\mathcal{A}$, decidir si $\mathcal{A}$ ha de ser necesariamente cierta supuestas ciertas las f√≥rmulas de $\mathcal{BC}$.*


De manera que para abordar este problema resultan necesarios los siguientes elementos:

-   Un lenguaje que permita expresar de manera formal y precisa las afirmaciones, hechos e hip√≥tesis. (<u>Sintaxis</u>)

-   Una definici√≥n clara de qu√© se considera *afirmaci√≥n cierta*  (<u>Sem√°ntica</u>)

-   Mecanismos efectivos (y a poder ser eficientes) que garanticen la correcci√≥n (y preferentemente la completitud) en las deducciones. (<u>Algoritmos de decisi√≥n</u>)

A lo largo de los distintos cap√≠tulos abordaremos estos puntos para las dos representaciones m√°s comunes, la L√≥gica Proposicional (*LP* o *PL*) y la L√≥gica de Primer Orden (*LPO* o *FOL*).

Por el momento vamos a comenzar este primer cap√≠tulo abordando los dos primeros puntos para la L√≥gica Proposicional y la L√≥gica de Primer Orden, dando una somera introducci√≥n al tercero para cada caso dejando el desarrollo de los algoritmos de decisi√≥n, que se ir√°n abordando a lo largo del resto de cap√≠tulos.

#### Caracter√≠sticas fundamentales de la LP.

-   Sus expresiones (denominadas f*√≥rmulas proposicionales* o *proposiciones*) modelan afirmaciones que pueden considerarse *ciertas* o *falsas*.

-   Las f√≥rmulas proposicionales (en adelante f√≥rmulas (si no existe ambig√ºedad)), se construyen mediante un conjunto de expresiones  b√°sicas (*f√≥rmulas at√≥micas* o *√°tomos*) y conjunto de operadores (*conectivas l√≥gicas*). Dichas conectivas permiten modelar los  siguientes tipos de afirmaciones:

    -   *Conjunci√≥n*: ‚Äò... tal ... Y ... cual ...‚Äô

    -   *Disyunci√≥n*: ‚Äò... tal ... O ... cual ...‚Äô

    -   *Implicaci√≥n*: ‚ÄòSI tal ... ENTONCES ... cual ...‚Äô

    -   *Equivalencia*: ‚Äò... tal ... SI Y S√ìLO SI ... cual ...‚Äô

    -   *Negaci√≥n*: ‚ÄòNO es cierto tal ...‚Äô

    Profundizaremos en este aspecto en la pr√≥xima secci√≥n, cuando  veamos la *Sintaxis de la LP*.

-   El lenguaje s√≥lo permite modelar este tipo de afirmaciones, por lo que muchas veces puede ser dif√≠cil (o imposible) representar el problema en este tipo de L√≥gica, y es necesario recurrir a otras m√°s  ricas (*LPO, L√≥gicas Modales, L√≥gica Fuzzy, etc*). Especificaremos este apartado cuando tratemos las limitaciones de la LP e introduzcamos la LPO.

-   Aunque esta L√≥gica puede resultar de una aparente sencillez, el problema *SAT* corresponde a la categor√≠a de problemas NP-completos, esto es, no existe ning√∫n algoritmo capaz de resolver el problema planteado en un tiempo polinomial de ejecuci√≥n. Trataremos de nuevo este aspecto en la introducci√≥n a los algoritmos de decisi√≥n.

1.2. Fundamentos de la l√≥gica proposicional
--------------------------------------------

Vamos a abordar desde un punto de vista te√≥rico-pr√°ctico, los elementos base que conforman la L√≥gica Proposicional, esto es la S√≠ntaxis y la Sem√°ntica, mostrando unificadamente los desarrollos formales como las implementaciones llevadas a cabo para modelar cada uno de ellos.

### Sint√°xis de la l√≥gica Proposicional

#### El alfabeto proposicional

El concepto ‚Äò*alfabeto proposicional*‚Äô referencia al conjunto de s√≠mbolos que forman parte de este lenguaje. Podemos distinguir las siguientes categor√≠as:

-   **Variables proposicionales o √°tomos**. Ya hemos se√±alado previamente que todo problema est√° representado por relaciones entre un conjunto finito de afirmaciones b√°sicas, dichas afirmaciones se representan por s√≠mbolos proposicionales: $VP = \{p_0, p_1, \ldots, p, q, r\}$. <br><br>

    Aunque, formalmente, no existe ninguna restricci√≥n, vamos a adoptar el siguiente criterio en relaci√≥n a la sintaxis de los s√≠mbolos proposicionales:<br><br>

    > Los s√≠mbolos proposicionales deben comenzar por una letra min√∫scula, seguida (opcionalmente) de otros caract√©res en min√∫scula o d√≠gitos num√©ricos, exclusivamente.

-   **Conectivas L√≥gicas**. Modelan las relaciones entre las distintas afirmaciones b√°sicas (√°tomos). Podemos distinguir:

    -   De aridad 1 o monoaria : *Negaci√≥n* ($\neg$).

    -   De aridad 2 o binarias: *Conjunci√≥n* ($\wedge$), *Disyunci√≥n* ($\vee$), *Condicional* ($\rightarrow$), *Bicondicional* ($\leftrightarrow$).<br><br>

-   **S√≠mbolos Auxiliares**: ‚Äò*(*‚Äô y ‚Äò*)*‚Äô. Permiten expresar relaciones de prioridad entre conectivas l√≥gicas y evitar la ambigi√ºedad en la interpretaci√≥n de las f√≥rmulas.

#### F√≥rmula Proposicional

Se denomina expresi√≥n del lenguaje proposicional a cada una sucesi√≥n finita (y no vac√≠a) de sus s√≠mbolos y conectivas.Un ejemplo de expresi√≥n puede ser la siguiente $a \rightarrow b )ca\vee$, otro puede corresponder a $(a \rightarrow b ) \vee c$. Parece claro que el primero posee ‚Äúuna coherencia‚Äù o‚Äúequilibrio que no parece tener el primero. De esta forma, las expresiones "bien formadas" las denominaremos **f√≥rmulas proposicionales**.

> Formalmente, El conjunto de las f√≥rmulas proposicionales, $PROP$, es el menor conjunto de expresiones que verifica:
> - $VP \subseteq PROP$
> - Es cerrado bajo las conectivas l√≥gicas, esto es:
    - Si una f√≥rmula $F \in PROP$, entonces $\neg F \in PROP$
    - Si las f√≥rmulas $F, G \in PROP$, entonces $(F \wedge G), (F \vee G), (F \rightarrow G), (F \leftrightarrow G) \in PROP$

De manera que se tiene una definici√≥n recursiva del concepto de *F√≥rmula Proposiciona*, tal que el caso base corresponde a una f√≥rmula b√°sica (*√°tomo*) y el caso recursivo corresponde a la aplicaci√≥n de una conectiva sobre una o dos f√≥rmulas (seg√∫n la aridad de la conectiva).

##### √Årboles de formaci√≥n

Cada una de las f√≥rmulas proposicionales lleva asociado un grafo de tipo √°rbol (esencialmente √∫nico), que muestra el desarrollo de formaci√≥n de la f√≥rmula, siguiendo la definici√≥n recursiva de la misma.

Por ejemplo a la f√≥rmula: $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$ le corresponde el √°rbol de formaci√≥n:

<center> <img src="images/T1Img1.png" title="√Årbol formaci√≥n (ejemplo)"></center><br>

##### Prioridad de conectivas y Reducci√≥n de par√©ntesis.

Para facilitar la escritura y lectura de las f√≥rmulas vamos a adoptar algunos criterios:

1.  Omitimos los par√©ntesis externos.<br><br>
2.  Tomaremos como orden de precedencia de las conectivas (de mayor a  menor): $\neg$, $\wedge$, $\vee$ , $\rightarrow$, $\leftrightarrow$. (Para la conectiva $\leftrightarrow$ se recomienda mantener los par√©ntesis en todos los casos).<br><br>
3.  Cuando una conectiva se usa repetidamente, se asocia por la derecha.<br><br>

##### Principio de inducci√≥n sobre f√≥rmulas

Gracias a la definici√≥n de $PROP$ (y su estructura recursiva), para probar que toda f√≥rmula proposicional satisface una cierta propiedad ($\Psi$), podemos hacerlo aplicando el m√©todo de inducci√≥n sobre f√≥rmulas.

De esta forma, probamos:

1.  (*Caso base*). Probar que todos los elementos de $VP$ tienen la propiedad $\Psi$.

2.  (*Paso de inducci√≥n*).

    -  Si $F \in PROP$ tiene la propiedad $\Psi$, entonces $\neg F$ tiene la propiedad $\Psi$.

    -  Si $F, G \in PROP$, tienen la propiedad $\Psi$ entonces $(F \wedge G), (F \vee G), (F \rightarrow G), (F \leftrightarrow G) \in PROP$ tienen la propiedad $\Psi$

##### Escritura de las f√≥rmulas en Logicus

Vamos a exponer cu√°l es la sintaxis de las f√≥rmulas utilizando la librer√≠a Logicus, que nos permitir√° definir f√≥rmulas y aplicar diversos algoritmos sobre las mismas.

En la librer√≠a podemos definir las f√≥rmulas de dos formas distintas, o bien acudiendo directamente a los constructores de las f√≥rmulas (largo y engorroso), o bien utilizando el Parser (de forma an√°loga a la escritura natural de las f√≥rmulas).

$\longrightarrow$ <u>Definici√≥n de f√≥rmulas a partir de constructores</u>

Si recordamos la definici√≥n recursiva que se ha dado para las f√≥rmulas, expusimos que las mismas pueden corresponder o bien a √°tomos (*caso base*), o bien a la aplicaci√≥n de las conectivas, teniendo en cuenta la aridad de √©stas, sobre f√≥rmulas proposicionales (*caso recursivo*).

Bien, pues la implementaci√≥n dada en la librer√≠a para las f√≥rmulas corresponde fielmente a dicha definici√≥n. De forma que:

- Los s√≠mbolos proposicionales se definen como cadenas de caract√©res, (recordando el criterio, estos caracteres deben ir en min√∫scula).<br><br>

        type alias PSymb = String

- Las f√≥rmulas proposicionales se definen seg√∫n la estructura recursiva presentada.<br><br>

        type FormulaLP = Atom PSymb                 -- caso base
                        | Neg FormulaLP             --‚é´
                        | Conj FormulaLP FormulaLP  --‚é™
                        | Disj FormulaLP FormulaLP  --‚é¨ casos recursivos
                        | Impl FormulaLP FormulaLP  --‚é™
                        | Equi FormulaLP FormulaLP  --‚é≠
                        | Insat                     -- f√≥rmula insatisfactible

Esto nos permite definir todas las f√≥rmulas proposicionales. Para poder hacer uso de la librer√≠a logicus tenemos que importar de los m√≥dulos correspondientes las funciones y tipos necesarios para nuestro trabajo.

Expongamos algunos ejemplos:

a. $(p \wedge q) \vee (p \wedge r) \quad$ b. $ (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q \quad$ c. $(p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p$<br>

```elm {l context="1"}

import Modules.IO_LP exposing (toLatexFLP)
import Modules.SintaxSemanticsLP exposing (FormulaLP(..))

a : FormulaLP
a = Disj (Conj (Atom "p") (Atom "q")) (Conj (Atom "p") (Atom "r"))
```
^^^elm {m=(">" ++ toLatexFLP "a" a) context="1"}^^^

```elm {l context="1"}
b : FormulaLP
b = Impl (Disj (Conj (Atom "p") (Atom "r")) (Conj (Neg (Atom "p")) (Atom "q"))) (Neg (Atom "q"))
```

^^^elm {m=(">" ++ toLatexFLP "b" b) context="1"}^^^

```elm{l context="1"}
c : FormulaLP
c = Conj (Conj (Equi (Atom "p") (Atom "q")) (Impl (Atom "p") (Neg (Atom "q")))) (Atom "p")
```

^^^elm {m=(">" ++ toLatexFLP "c" c) context="1"}^^^

Como se puede apreciar, escribir las f√≥rmulas de esta forma puede resultar una tarea ardua y propensa a errores, por eso, se ha desarrollado un parser que nos permite escribir de forma m√°s c√≥moda,sint√©tica y visual las f√≥rmulas. Para poder utilizarlo se han establecido una serie de requisitos sint√°cticos, an√°logos a los presentados anteriormente:

- Los s√≠mbolos proposicionales deben comenzar por un caracter en min√∫scula seguido, opcionalmente, de caracteres en min√∫scula, d√≠gitos o el s√≠mbolo '_'.<br><br>

- Para las conectivas se usar√°n los siguientes s√≠mbolos, manti√©ndose la prioridad de las conectivas definida (en el orden de prioridad descendente expuesto en la tabla).

<table style="margin-left: auto; margin-right: auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Conectiva L√≥gica</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">S√≠mbolo Logicus</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Negaci√≥n (¬¨)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'NOT'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Conjunci√≥n (‚àß)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'AND'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Disyunci√≥n (‚à®)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'OR'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Implicaci√≥n (ü°í)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'IMPLIES'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Equivalencia (ü°ò)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'EQUIV'</td></tr></tbody></table><br>

- Los par√©ntesis se utilizan de igual forma en que se han definido en el lenguaje formal de la l√≥gica proposicional, con los s√≠mbolos '(' y ')'. No son necesarios los par√©ntesis externos de las f√≥rmulas.<br><br>

- En caso de uso repetido de una misma conectiva, se realizar√° asociaci√≥n por la derecha.

A partir de este momento todas las f√≥rmulas de los ejemplos se definir√°n utilizando el Parser por lo que llegados a este punto se recomienda tener claras las reglas sint√°cticas a seguir, aunque, son an√°logas a las planteadas por el lenguaje formal de la l√≥gica proposicional.

Para definir los ejemplos expuestos anteriormente:

```elm {l context="2"}
import Modules.SintaxSemanticsLP exposing (FormulaLP(..))
import Modules.IO_LP exposing (toLatexFLP, fromStringToFLP, extractReadFLP)

a : FormulaLP
a = fromStringToFLP "(p AND q) OR (p AND t)" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "a" a) context="2"}^^^
```elm{l context="2"}
b : FormulaLP
b = fromStringToFLP "(p AND r) OR (NOT p AND q) IMPLIES NOT q" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "b" b) context="2"}^^^
```elm{l context="2"}
c : FormulaLP
c = fromStringToFLP "(p EQUIV q) AND (p IMPLIES NOT q) AND p" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "c" c) context="2"}^^^

N√≥tese que la funci√≥n *fromStringToFLP* proporciona una tupla de dos elementos el primero de ellos corresponde a la f√≥rmula le√≠da y el segundo a una cadena de texto. Bien, si cometemos alg√∫n error sint√°ctico en la escritura de la f√≥rmula el Parser no ser√° capaz de interpretarla correctamente por lo que devolver√° una tupla *(Nothing,error)*, en el que el segundo elemento corresponder√° al mensaje de error y el primer elemento a un objeto vac√≠o.

Una vez le√≠da la f√≥rmula correctamente podemos extraerla utilizando la funci√≥n *extractReadFLP*. Si utilizamos dicha funci√≥n sobre una f√≥rmula le√≠da incorrectamente, se extraer√° como f√≥rmula la f√≥rmula insatisfactible.

$\longrightarrow$ <u>√Årboles de formaci√≥n en Logicus</u>

La librer√≠a tambi√©n permite la representaci√≥n de los √°rboles de formaci√≥n. La funci√≥n *formtree* muestra la representaci√≥n del √°rbol de formaci√≥n en formato texto DOT.

Por ejemplo para la f√≥rmula $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$:

```elm {l context="3"}
import Modules.IO_LP exposing (toLatexFLP, fromStringToFLP, extractReadFLP, formTree)
import Modules.SintaxSemanticsLP exposing (FormulaLP(..))
import Modules.AuxForLitvis exposing (showGraphViz)

a : FormulaLP
a = fromStringToFLP "NOT ( NOT (p OR q) IMPLIES (NOT r AND s))" |> extractReadFLP

fta : String
fta = formTree a
```
De forma que se obtiene:

^^^elm {m=(showGraphViz "g1" fta) context="3"}^^^

#### Conjuntos de f√≥rmulas

Definido $PROP$, los conjuntos de f√≥rmulas no son m√°s que subconjuntos de $PROP$, esto es, corresponden a agrupaciones de f√≥rmulas proposicionales.


##### Conjuntos de f√≥rmulas en Logicus

Los conjuntos proposicionales se definen como listas de f√≥rmulas proposicionales. De esta forma:


    type alias LPSet = List FormulaLP

De forma que la definici√≥n de estos se realiza como listas de objetos *FormulaLP*. Si por ejemplo queremos definir el conjunto:
$$ M = \left\lbrace (p \wedge q) \vee (p \wedge r), (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q, (p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p \right\rbrace$$

Podr√≠amos hacerlo:

```elm{l context="4"}

import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)

a : FormulaLP
a = fromStringToFLP "(p AND q) OR (p AND r)" |> extractReadFLP

b : FormulaLP
b = fromStringToFLP "(p AND r) OR (NOT p AND q) IMPLIES NOT q" |> extractReadFLP

c: FormulaLP
c = fromStringToFLP "(p EQUIV q) AND (p IMPLIES NOT q) AND p" |> extractReadFLP

m : LPSet
m = [a,b,c]
```

De forma que se obtiene:

^^^elm{m=(">" ++ toLatexLPSet "M" m) context="4"}^^^

### Sem√°ntica de la l√≥gica Proposicional

#### Interpretaciones, Modelos, Satisfactibilidad y Validez L√≥gica

Una vez provista la sintaxis, pasamos a desarrollar la sem√°ntica de la L√≥gica Proposicional. Como ya comentamos, hemos de abordar la interpretaci√≥n de certeza o veracidad de las f√≥rmulas. Para esto es necesario conocer los conceptos de *valor de verdad* y *funci√≥n de verdad*.

> -  **Valor de verdad**. Los elementos del conjunto $\{0,1\}$ se denominan valores de verdad o valores booleanos. Representan si un hecho es cierto o no, de forma que el valor $1$ se asocia a *verdadero* y el valor $0$ a *falso*.<br><br>
>  -   **Funciones de verdad**. Corresponden a funciones que devuelven un valor de verdad seg√∫n el valor de verdad de los argumentos. As√≠, el significado (valor de verdad asociado) de cada una de las conectivas l√≥gicas viene dado por una funci√≥n de verdad, de forma que:<br>
    $$\begin{array}{l l} H_{\neg}(i) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = 0\\
        0 & \textrm{si } i = 1\\
        \end{array} \right. & H_{\wedge}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j = 1\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\vee}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right. & H_{\rightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = 1, j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\leftrightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\end{array}$$

Visto esto, pasamos a estudiar el valor de verdad de las f√≥rmulas proposicionales. Para ello debemos definir el valor de verdad de las variables proposicionales, (denominadas *valoraciones* o *interpretaciones*) y a partir de √©stas y las funciones de verdad de las conectivas,podemos extender cada valoraci√≥n,$v$,de forma √∫nica,al conjunto de todas las f√≥rmulas de manera que se verifica:

$$\begin{array}{c c} v((F \wedge G))= H_{\wedge}(v(F), v(G)) & v((F \vee G))= H_{\vee}(v(F), v(G))\\\\ v((F \rightarrow G))= H_{\rightarrow}(v(F), v(G)) & v((F \leftrightarrow G))= H_{\leftrightarrow}(v(F), v(G)) \end{array}$$

> Dada una f√≥rmula $F \in PROP$, se dice que $v(F)$ es el valor de verdad de $F$ respecto de la valoraci√≥n $v$.

De esta forma, es sencillo realizar el c√°lculo del valor de verdad de una f√≥rmula respecto de una valoraci√≥n, recurriendo al √°rbol de formaci√≥n de la f√≥rmula, evaluando las subf√≥rmulas, desde las hojas (variables proposicionales) hasta el nodo ra√≠z (la f√≥rmula completa).

Por ejemplo el c√°lculo de la valoraci√≥n de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$:

<center> <img src="images/T1Img3.png" title="C√°lculo de la valoraci√≥n con el AF."></center><br>

Adem√°s del c√°culo a trav√©s del √Årbol de Formaci√≥n, existe otro m√©todo (equivalente) para el c√°lculo del valor de verdad de una f√≥rmula respecto de una valoraci√≥n, c√°lculo a trav√©s de Tabla. Dado que, dada una valoraci√≥n,$v$, el valor de verdad de una f√≥rmula $F$ respecto de $v$ est√° determinado por los valores de verdad de las subf√≥rmulas de $F$, podemos construir una tabla que recorra los valores de sus subf√≥rmulas. Para el ejemplo anterior:

<table style="margin-left: auto; margin-right: auto; width:80%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p ‚à® q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(p ‚à® q)</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨r ‚à® s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(p ‚à® q) <span style="font-weight:400;font-style:normal">‚à®</span> <span style="font-style:normal">¬¨(r ‚à® s)</span></th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(<span style="font-style:normal">¬¨(p ‚à® q) </span>‚à® (¬¨r ‚à® s))</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr></tbody></table><br>

##### Tablas de Verdad

Una tabla de verdad corresponde a una estructura similar a la anterior (nosotros s√≥lo reflejaremos el valor de las variables proposicionales y el valor de verdad de la f√≥rmula completa), en la que en cada fila se presenta la valoraci√≥n y el valor de verdad de la f√≥rmula respecto a la misma, para toda interpretaci√≥n posible (que corresponda a las variables proposicionales presentes en la f√≥rmula).

Para la f√≥rmula anterior, su tabla de verdad corresponder√≠a a:

<table style="margin:auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(<span style="font-style:normal">¬¨(p ‚à® q) </span>‚à® (¬¨ r ‚à® s))</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr></tbody></table>


##### Modelos, Satisfactibilidad y Validez L√≥gica

Una vez estudiado lo anterior, vamos dar unas cuantas definiciones:

> -  **Modelo.** Se dice que una f√≥rmula $F$ es v√°lida en una valoraci√≥n $v$ o equivalentemente que $v$ es **modelo** de $F$ si $v(F)=1$ y se denota por $v \models F$. En caso contrario, se dice que $v$ es **contramodelo** de $F$ y se denota $v \not \models F$.<br><br>
> - **Satisfactibilidad.** Una f√≥rmula $F$ se dice **satisfactible** (o consistente) si existe una valoraci√≥n $v$ que es modelo de $F$. En caso contrario se dice que $F$ es **insatisfactible** (o inconsistente), y se representa por $\perp$.<br><br>
> - **Validez l√≥gica o Tautolog√≠a**. Una f√≥rmula $F$ se dice **tautolog√≠a** (o (l√≥gicamente) v√°lida) si toda valoraci√≥n es modelo de $F$ y se denota $\models F$.<br>

$\longrightarrow$ <u>Relaci√≥n entre Validez y Satisfactibilidad</u>

> *LEMA*: Para cada $F \in PROP$ se verifica:
> -  Si $F$ es tautolog√≠a, entonces $F$ es satisfactible.<br>
> -  $F$ es tautolog√≠a si y s√≥lo si $F$ es insatisfactible.<br>

<br>

##### Sem√°ntica de F√≥rmulas LP en Logicus

La librer√≠a dispone de funciones que modelan todos los conceptos sem√°nticos que hemos visto hasta ahora.

$\longrightarrow$ <u>Valores, Funciones de Verdad e Interpretaciones</u>

Como hemos estudiado los **valores de verdad** corresponden a 1 (*verdadero*) y 0 (*falso*). Elm ya provee esos valores booleanos en el tipo *Bool*, por lo que no es necesario realizar ninguna definici√≥n alternativa para este concepto.

Las definici√≥n de las funciones de verdad asociadas a las conectivas corresponden directamente a la aplicaci√≥n de dichas funciones en la evaluaci√≥n de las f√≥rmulas. Antes de ver la evaluaci√≥n resulta necesario ver la definici√≥n que se ha dado para las interpretaciones. Para ello, se ha elegido una representaci√≥n "dispersa" de manera que una interpretaci√≥n corresponde a una lista de s√≠mbolos proposicionales (variables proposicionales) que son los que son considerados verdaderos, los t√©rminos que no aparecen en la lista ser√°n considerados como falsos.

    type alias Interpretation = List PSymb

Con esta definici√≥n resulta sencillo llevar a cabo la evaluaci√≥n de las f√≥rmulas. Tal y como se ha planteado formamelte, podemos distinguir el proceso de evaluaci√≥n en 2 casos:

- **Evaluaci√≥n de variables**. Una variable ser√° verdadera si en la interpretaci√≥n le otorga dicho valor, esto es, seg√∫n la definici√≥n dada, ser√° verdadera si pertenece a la lista de la interpretaci√≥n, y ser√° falsa en caso contrario.

- **Evaluaci√≥n de conectivas**. Seg√∫n la definici√≥n formal dada:
$$\begin{array}{l l} H_{\neg}(i) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = 0\\
        0 & \textrm{si } i = 1\\
        \end{array} \right. & H_{\wedge}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j = 1\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\vee}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right. & H_{\rightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = 1, j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\leftrightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\end{array}$$

De forma que:

    valuation : FormulaLP -> Interpretation -> Bool
    valuation pr i =
        case pr of
            Atom p -> List.member p i
            Neg p -> not (valuation p i)
            Conj p q -> valuation p i &&  valuation q i
            Disj p q ->   valuation p i ||  valuation q i
            Impl p q ->   not (valuation p i) ||  valuation q i
            Equi p q ->   valuation (Impl p q) i &&  valuation (Impl q p) i
            Insat -> Basics.False

NOTA: n√≥tese que la f√≥rmula insatisfactible, l√≥gicamente, es falsa respecto de cualquier valoraci√≥n.

De forma que la funci√≥n *valuation* nos permite calcular la valoraci√≥n de una f√≥rmula respecto de una valoraci√≥n. Por ejemplo, calculemos la valoraci√≥n de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$:

```elm{l context="5"}

import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)

f : FormulaLP
f = fromStringToFLP "NOT (NOT (p OR q) OR (NOT r OR s))" |> extractReadFLP

i : Interpretation
i = ["p", "q"]
```

^^^elm{r=(valuation f i) context="5"}^^^

$\longrightarrow$ <u>Tabla de Verdad, Modelos, Satisfactibilidad y Validez </u>

Como se ha expuesto anteriormente una tabla de verdad recoge las valoraciones de una f√≥rmula respecto a todas las posibles interpretaciones que integran a sus s√≠mbolos proposicionales. Bien dada la definici√≥n de las interpretaciones resulta bien sencillo el c√°lculo de todas las posibles interpretaciones, de hecho el conjunto de interpretaciones corrsponde a todos los posibles subconjuntos del conjunto formado por los s√≠mbolos proposicionales que participan en la f√≥rmula. De esta forma:

    symbInProp : FormulaLP -> Set.Set PSymb
    symbInProp f=
        case f of
            Atom p -> Set.singleton p
            Neg p -> symbInProp p
            Conj p q -> Set.union (symbInProp p ) (symbInProp q)
            Disj p q -> Set.union (symbInProp p ) (symbInProp q)
            Impl p q -> Set.union (symbInProp p ) (symbInProp q)
            Equi p q -> Set.union (symbInProp p ) (symbInProp q)
            Insat -> Set.empty

    allInterpretations : FormulaLP -> List Interpretation
    allInterpretations x =  Aux.powerset <| List.sort <| Set.toList <| symbInProp x

Y la tabla de verdad corresponde al conjunto de pares (*Interpretaci√≥n, Valoraci√≥n*), que corresponde a las entradas cada una de las entradas (filas) de la tabla.

    truthTable : FormulaLP -> List (Interpretation, Bool)
    truthTable x = List.map (\xs ->  (xs,valuation x xs)) <| allInterpretations x

Para el ejemplo anterior:

```elm{l context="6"}
import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)
import Modules.AuxForLitvis exposing (showTable)
import Modules.AuxiliarFunctions exposing (uncurry)
import Bool.Extra exposing (toString)

f : FormulaLP
f = fromStringToFLP "NOT (NOT (p OR q) OR (NOT r OR s))" |> extractReadFLP

-- Ejecutamos: truthTable f |> truthTableToMDFormat (symbInProp f) |> uncurry (showTable)
```

^^^elm{m=(truthTable f |> truthTableToMDFormat (symbInProp f) |> uncurry (showTable)) context="6"}^^^

Una vez calculadas todas las posibles interpretaciones resulta sencillo calcular los modelos y contramodelos de una f√≥rmula proposicional, sin m√°s que seleccionar aquellos que sean evaluados como verdaderos o falsos, respectivamente. Tal que:

    models : FormulaLP -> List Interpretation
    models x = List.filter (\y -> valuation x y) (allInterpretations x)

    countermodels : FormulaLP -> List Interpretation
    countermodels x = List.filter (\y -> not(valuation x y)) (allInterpretations x)

De forma que para la f√≥rmula anterior, el conjunto de modelos y contramodelos corresponder√≠a a:

```elm{l context="6"}

modelos_f : List Interpretation
modelos_f =  models f
```

^^^elm{m=(interpretations2MDFormat modelos_f) context="6"}^^^

```elm{l context="6"}

contramodelos_f : List Interpretation
contramodelos_f = countermodels f
```

^^^elm{m=(interpretations2MDFormat contramodelos_f) context="6"}^^^

Del mismo modo resulta casi trivial decidir la satisfactibilidad y validez de las f√≥rmulas proposicionales, sin m√°s que comprobar si todas las interpretaciones hacen a la f√≥rmula verdadera (*tautolog√≠a*), alguna de ellas la hace verdadera (*f√≥rmula satisfactible*), o no la hace ninguna de ellas (*f√≥rmula insatisfactible*). As√≠:


    satisfactibility : FormulaLP -> Bool
    satisfactibility x = List.any (\xs-> valuation x xs) (allInterpretations x)

    validity : FormulaLP -> Bool
    validity x = List.all (\xs-> valuation x xs) (allInterpretations x)

    insatisfactibility : FormulaLP -> Bool
    insatisfactibility x = List.all (\xs-> not(valuation x xs)) (allInterpretations x)

De forma que en el caso dela f√≥rmula anterior, sabemos que es satisfactible ya que el conjunto de modelos no era vac√≠o, y que no es tautolog√≠a ya que el de contramodelos tampoco lo era. Utilizando las funciones provistas por la librer√≠a:

```elm{l context="6"}

isSatisfactible_f : Bool
isSatisfactible_f = satisfactibility f
```
^^^elm{m=(toString isSatisfactible_f) context="6"}^^^

```elm{l context="6"}

isTaut_f : Bool
isTaut_f = validity f
```
^^^elm{m=(toString isTaut_f) context="6"}^^^

```elm{l context="6"}

isInsatisfactible_f : Bool
isInsatisfactible_f = insatisfactibility f
```

^^^elm{m=(toString isInsatisfactible_f) context="6"}^^^

#### Conjuntos de F√≥rmulas. Modelos y Consistencia.

De forma an√°loga a la presentada para las f√≥rmulas proposicionales podemos definir los conceptos anteriores, aplicados a conjuntos de f√≥rmulas de forma que:

>- **Modelo.** Se dice que una valoraci√≥n $v$ es **modelo** de un conjunto de f√≥rmulas $U$ si para toda f√≥rmula $F \in U$ se tiene que $v(F)=1$ y se denota por $v \models U$. En caso contrario, se dice **contramodelo**.<br><br>
> -   **Consistencia** Un conjunto de f√≥rmulas $U$ se dice **consistente** si existe una valoraci√≥n $v$ que es modelo de $U$. En caso contrario se dice que $U$ es **inconsistente**.


##### Consecuencia L√≥gica.

>Una f√≥rmula $F$ es consecuencia l√≥gica (o se sigue) de un conjunto de f√≥rmulas $U$, y se denota por $U \models F$, si toda valoraci√≥n que es modelo de $U$ es tambi√©n modelo de $F$.

Es precisamente este concepto el que permite formular el problema b√°sico en el marco de la l√≥gica proposicional, que planteamos como objetivo de la LP.

##### Relaci√≥n entre consecuencia l√≥gica, consistencia y validez

> *PROPOSICI√ìN*: Sea $U = \{F_1, F_2, \ldots, F_n \} \subseteq PROP$ y $F \in PROP$ son equivalentes:
>- $(U = \{F_1, F_2, \ldots, F_n \}) \models F$<br><br>
>- $\left(\bigwedge \limits_{F_i} U = (F_1 \wedge F_2 \wedge \ldots \wedge F_n)\right) \rightarrow F \in TAUT$<br><br>
>- $\left( U \cup \{\neg F\} = \{F_1 , F_2 , \ldots , F_n , \neg F\} \right) \models \perp$

##### Sem√°ntica de Conjuntos LP en Logicus

Al igual que en el caso de las f√≥rmulas proposicionales podemos realizar una traslaci√≥n directa de los conceptos formalmente expuestos a las implementaciones, de forma que el c√°lculo de las posibles interpretaciones, an√°logamente al caso de las f√≥rmulas, se reduce al c√°lculo de los posibles subconjuntos de los s√≠mbolos proposicionales presentes en las f√≥rmulas, correspondientes a la uni√≥n de los conjuntos de s√≠mbolos asociados a cada una de las f√≥rmulas. De esta forma:

    setSymbols : List FormulaLP -> Set.Set PSymb
    setSymbols xs = List.foldr (\x acc -> Set.union acc (symbInProp x)) Set.empty xs

    allSetInterpretations : List FormulaLP -> List Interpretation
    allSetInterpretations xs = Aux.powerset <| Set.toList <| setSymbols xs

De forma que el c√°lculo de los modelos, contramodelos, consistencia e inconsistencia se reduce a aplicar las definiciones sobre el conjunto de f√≥rmulas:

    isSetModel : List FormulaLP -> Interpretation -> Bool
    isSetModel xs i =  List.all (\x -> valuation x i) xs

    allSetModels : List FormulaLP -> List Interpretation
    allSetModels xs = List.filter (isSetModel xs) (allSetInterpretations xs)

    allSetCounterModels : List FormulaLP -> List Interpretation
    allSetCounterModels xs = List.filter (\x -> not(isSetModel xs x)) <| allSetInterpretations xs

    isConsistent : List FormulaLP -> Bool
    isConsistent xs = List.any (\x -> isSetModel xs x) <| allSetInterpretations xs

    isInconsistent: List FormulaLP -> Bool
    isInconsistent xs = not(isConsistent xs)

$\longrightarrow$ <u>Consecuencia l√≥gica</u>

Dada la definici√≥n de conseciencia l√≥gica y teniendo en cuenta la relaci√≥n entre consecuencia l√≥gica, consistencia y validez (√∫ltimo caso), funcionalmente hemos planteado dos desarrollos alternativos para el concepto de Consecuencia L√≥gica:

(1) Acudiendo a la propia definici√≥n. (2) Acudiendo al tercer punto de la proposici√≥n anterior.

    isConsecuence : List FormulaLP -> FormulaLP -> Bool
    -- isConsecuence xs x = List.all (\y -> valuation x y) <| allSetModels xs
    isConsecuence xs x = isInconsistent (xs ++ [Neg x])

NOTA: Se ha dejado la segunda como implementaci√≥n final.

Ve√°mos un ejemplo, dado el conjunto de f√≥rmulas $U=\{p \rightarrow q,q \rightarrow p \wedge r\}$ y la f√≥rmula $ F = p \rightarrow (p \rightarrow q) \rightarrow r$, ve√°mos si se cumple $U \models F$.

```elm{l context="7"}

import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)
import Bool.Extra exposing (toString)

u1 : FormulaLP
u1 = fromStringToFLP "p IMPLIES q" |> extractReadFLP

u2 : FormulaLP
u2 =  fromStringToFLP "q IMPLIES p AND r" |> extractReadFLP

uSet : LPSet
uSet = [u1, u2]

f : FormulaLP
f = fromStringToFLP "p IMPLIES (p IMPLIES q) IMPLIES r" |> extractReadFLP

-- Ejecutamos toString <| isConsecuence uSet  f
```

^^^elm{m=(toString <| isConsecuence uSet  f) context="7"}^^^

De hecho, acudiendo a la definici√≥n podemos ver que, en efecto, todo modelo del conjunto $U$ es tambi√©n modelo de la f√≥rmula $F$.

```elm{l context="7"}

modelos_U : List Interpretation
modelos_U = allSetModels uSet

modelos_F : List Interpretation
modelos_F = models f

{-Ejecutamos:
    interpretations2MDFormat modelos_U
    interpretations2MDFormat modelos_F
  -}
```
De forma que los modelos de $U$ corresponden a:

^^^elm{m=(interpretations2MDFormat modelos_U) context="7"}^^^

Y los de $F$:

^^^elm{m=(interpretations2MDFormat modelos_F) context="7"}^^^

De forma que, en efecto, todo modelo de $U$ es tambi√©n modelo de $F$, luego $F$ se sigue de $U$.

### Algoritmos de decisi√≥n en LP

Como hemos se√±alado vamos a presentar de forma somera los algoritmos de decisi√≥n en LP, e iremos desarrollando algunos de los algoritmos m√°s importantes a lo largo de los distintos cap√≠tulos.

> Dado un conjunto de f√≥rmulas $U$, un **algoritmo de decisi√≥n** para $U$ es aqu√©l que dada una f√≥rmula $A \in PROP$, devuelve `SI` cuando $A \in U$ y `NO` cuando $A \not\in U$

Esto da pie a la definici√≥n de algunos problemas con un especial inter√©s:

> - $SAT = \{A \in PROP: \, A \textit{ es satisfactible}\}$.
> - $TAUT = \{A \in PROP: \, A \textit{ es tautolog√≠a}\}$.
> - Fijado $U \subseteq PROP$, la *Teor√≠a de $U$* corresponde a: $\mathcal{T}(U) = \{A \in PROP: \, U \models A\}$.

Precisamente, un algoritmo de decisi√≥n para $\mathcal{T}(U)$ proporciona una respuesta al Problema B√°sico que planteamos al comienzo del cap√≠tulo. Por tanto, podemos reducir dicho problema a uno nuevo:
> Obtener un algoritmo que, dado un conjunto finito de f√≥rmulas proposicionales, $U$, y una f√≥rmula, $F$, decida si $U \models F$.

Y este a su vez se reduce a comprobar la satisfactibilidad de una cierta f√≥rmula (o bien la validez de otra), hemos aqu√≠ el problema conocido como *Problema $SAT$*.

Notemos que ya hemos visto un algoritmo, el de las Tablas de Verdad, que resuelve, de forma simple, el problema, pero la complejidad de dicho algoritmo es exponencial en el n√∫mero de s√≠mbolos proposicionales, lo que lo hace inabordable para f√≥rmulas de cierta complejidad , incluso computacionalmente.

Hemos de se√±alar que existen otros algoritmos de decisi√≥n del problema $SAT$, algunos de los cuales abordaremos a lo largo de los siguientes cap√≠tulos, pero a√∫n no se ha encontrado ninguno capaz de resolver el problema eficientemente (complejidad polinomial), y, de hecho, se duda (fuertemente) de la existencia del mismo. De hecho, determinar la satisfactibilidad de una f√≥rmula proposicional se trata de un problema NP-completo.

1.3 De Proposiciones a Predicados.
Conceptos B√°sicos de L√≥gica de Primer Orden
----------------------------------------------------

### Limitaciones de la L√≥gica Proposicional

Aunque la l√≥gica proposicional posee un sem√°ntica sencilla y existen algoritmos de decisi√≥n (poco eficientes) para sus problemas b√°sicos, como $SAT$ o la consecuencia l√≥gica, la expresividad de LP es bastante limitada, esto hace que muchos problemas no sean modelables en LP, bien porque requieren un gran n√∫mero de f√≥rmulas o f√≥rmulas de gran tama√±o, o
bien porque no puedan ni siquiera expresarse en este lenguaje. El siguiente ejemplo presenta un razonamiento que es v√°lido, sin embargo no es expresable en LP:

‚Äã1. Todo hombre es mortal.
2. S√≥crates es hombre.
3. Por tanto, S√≥crates es mortal.

¬øC√≥mo expresar el concepto de ser hombre?¬øComo expresar qui√©n es S√≥crates?, pero a√∫n m√°s ¬øC√≥mo expresar que todos es mortal?. Es aqu√≠ precisamente donde comienza el √°mbito de la L√≥gica de PrimerOrden.

### Caracterizaci√≥n de la L√≥gica de Primer Orden

La L√≥gica de Primer Orden (LPO) extiende la L√≥gica Proposicional, ganando capacidad expresiva, que permite abordar cuestiones como:

- Realizar cuantificaci√≥n sobre los objetos de un dominio, esto es, expresar en qu√© medida se tiene una propiedad sobre un conjunto de objetos.

- Representar propiedades de los objetos particulares del dominio por medio de predicados y funciones.

- Trabajar con subconjuntos de objetos que pueden venir caracterizados por propiedades que se describen por medio de predicados y funciones.



1.4. Fundamentos de la L√≥gica de Primer Orden
----------------------------------------------------

De forma an√°loga a como se ha visto para la l√≥gica proposicional vamos a estudiar los elementos que definen la L√≥gica de Primer Orden (Sint√°xis y Sem√°ntica) dejando para cap√≠tulos futuros el desarrollo de los Algoritmos de Decisi√≥n.

### Sint√°xis de la L√≥gica de Primer Orden

Formalmente,

> La **L√≥gica de Primer Orden** o **L√≥gica de Predicados** es un sistema formal dise√±ado para estudiar los m√©todos inferenciales en los leguajes de primer orden.

Un **lenguaje de primer orden** corresponde a un lenguaje formal que consta de:

- <u>S√≠mbolos l√≥gicos</u> (comunes a todos los lenguajes): En los que se engloban:

    -   Un conjunto de *Variables:* $V = \{x, x_0, x_1, \ldots, y, y_0, \ldots \}$

    -   *Conectivas l√≥gicas :* $\neg$ (negaci√≥n), $\wedge$ (conjunci√≥n), $\vee$ (disyunci√≥n), $\rightarrow$ (implicaci√≥n), $\leftrightarrow$ (equivalencia).

    -   *Cuantificadores:* $\exists$ (existencial), $\forall$ (universal).

    -   *S√≠mbolos auxiliares:* $`('$ y $`)'$<br><br>

-   <u>S√≠mbolos no l√≥gicos</u> (propios de cada lenguaje): En los que se engloban:

    -   Un conjunto de *Constantes:* $L_{C}= \{a, b, \ldots, a_{0}, a_{1}, \ldots \}$

    -   Un conjunto de *s√≠mbolos de funci√≥n:* $L_{F} = \{f_{0}, f_{1}, \ldots\}$, cada uno con su aridad correspondiente.

    -   Un conjunto de **s√≠mbolos de predicado:** $L_P=\{P_{0}, P_{1}, \ldots, Q, Q_0, \ldots\}$, cada uno con su aridad correspondiente.

        Dos notas:

        -   Los s√≠mpolos de predicado de aridad 0 act√∫an como s√≠mbolos proposicionales.

        -   El s√≠mbolo de igualdad (‚Äò$=$‚Äô) no es un predicado com√∫n a todos los lenguajes de primer orden, pero si es corriente su aparici√≥n. La familia de lenguajes que incluyen este predicado es denominada *Lenguajes de Primer Orden con Igualdad*.

Este aparato permite la construcci√≥n de distintas expresiones, que componen las f√≥rmulas de LPO. Vamos a exponer una diferenciaci√≥n de dichas expresiones, distinguiendo *t√©rminos* y *f√≥rmulas*.

#### T√©rminos en LPO

Los t√©rminos se identifican con posibles objetos del mundo. Englobando los siguientes elementos:

- <u>Constantes</u> para hablar de objetos espec√≠ficos.
- <u>Variables</u> para hablar de objetos gen√©ricos.
- <u>Funciones</u> aplicadas a otros t√©rminos m√°s peque√±os, seg√∫n su aridad.

Para ejemplificar los conceptos expuestos a lo largo del tema vamos a modelar el mundo romano:
(los super√≠ndices indican la aridad)

$$LR = \{\underbrace{\boldsymbol{C√©sar}, \boldsymbol{Marco}}_{constantes}, \underbrace{P^{1}, L^{2}, O^{2}, R^{1}, IA^{2}}_{\textit{s√≠mbolos de predicado}}, \underbrace{f^{1}}_{\textit{s√≠mbolo de funci√≥n}} \}$$

tal que, donde, $C√©sar$ y $Marco$ son constantes, $P$ y $R$ son predicados unarios que denotan *ser pompeyano* y *ser romano*, respectivamente; $L$, $O$, $IA$ son predicados binarios que denotan *ser leal a*, *odiar a* , *intentar asesinar a*, respectivamente; y $f$ una funci√≥n unaria que represente el concepto de *padre de*.

De forma que son t√©rminos de $LR$:



- *Constantes*: *Marco*, *C√©sar*.
- *Variables*: $x$, $y$, $x_1$, ...
- *Funciones*: f(C√©sar), f(x), f(f(x)), ...

#### F√≥rmulas en LPO

Las f√≥rmulas se identifican con afirmaciones sobre los objetos del mundo, permitiendo hablar de la veracidad o falsedad de las afirmaciones. Est√°n formadas a partir de predicados sobre t√©rminos, y construcciones l√≥gicas de estos predicados (conjunciones, implicaciones, cuantificaciones, etc.). Ve√°mos esto formalmente.

Las f√≥rmulas pueden corresponder a:

- <u>√Åtomos o F√≥rmulas at√≥micas</u>. Corresponden a las expresiones $p(t_1, t_2, \ldots, t_n)$, tal que $p$ es un s√≠mbolo de predicado de aridad $n$ y $t_i$ son t√©rminos.

- <u>F√≥rmulas no at√≥micas</u>. Corresponden a expresiones formadas a partir de f√≥rmulas at√≥micas, mediante el empleo de conectivas y/o cuantificadores.

De esta forma, son f√≥rmulas de $L$:

- Toda f√≥rmula at√≥mica.

- Si F y G son f√≥rmulas de de $L$ entonces $\neg F$, $F \wedge G$, $F \vee G$, $F \rightarrow G$, $F \leftrightarrow G$, tambi√©n son f√≥rmulas de $L$.

- Si x es una variable y F es una f√≥rmula de $L$, entonces $\exists x \, F$ y $\forall x \, F$ son tambi√©n f√≥rmulas de $L$.

Volviendo al mundo romano, algunas posibles f√≥rmulas del lenguaje $LR$:

- *√Åtomos*: $P(\boldsymbol{C√©sar})$, $L(\boldsymbol{C√©sar}, \boldsymbol{Marco})$, $IA(\boldsymbol{Marco}, f(x))$.
- *F√≥rmulas compuestas*: $\forall x \exists y \, L(x,y)$, $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$

$\longrightarrow$ <u>Reglas de simplificaci√≥n de la notaci√≥n</u>

Para facilitar la lectura y escritura de las f√≥rmulas vamos a tomar varios criterios de notaci√≥n:

- Se omitir√°n los par√©ntesis externos.
- Las prioridades de las conectivas siguen el mismo orden que el expuesto en LP: $\neg, \wedge, \vee, \rightarrow, \leftrightarrow$ (para la √∫ltima se recomienda mantener los par√©ntesis).
- Los cuantificadores tienen prioridad sobre las conectivas.

##### √Årboles de formaci√≥n.

Al iguan que en las f√≥rmulas de LP, la definici√≥n de las f√≥rmulas en LPO presenta una estructura recursiva:

- *Caso base*. F√≥rmulas at√≥micas.
- *Casos recursivos* Aplicaci√≥n de las conectivas y cuantificadores sobre f√≥rmulas de LPO.

Y de forma an√°loga a la presentada en LP, se puede plasmar dicha estructura recursiva en un grafo tipo √°rbol (esencialmente √∫nico), de forma que el nodo ra√≠z corresponde a la f√≥rmula completa y las hojas corresponden a las f√≥rmulas at√≥micas que participan en la f√≥rmula. Al igual que en LP, toda f√≥rmula que aparezca en alg√∫n nodo (ya sea un nodo interno o una hoja) diremos que es **subf√≥rmula** de la f√≥rmula original.

Para la f√≥rmula $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$, se tendr√≠a el AF asociado:<br><br>

<center> <img src="images/T1Img4.png" title="√Årbol de formaci√≥n en LPO (ejemplo)."></center><br>


##### Sintaxis de F√≥rmulas LPO en Logicus

Al igual que hicimos con la l√≥gica LP, vamos a exponer cu√°l es la sintaxis de las f√≥rmulas utilizando la librer√≠a Logicus, que nos permitir√° definir f√≥rmulas y aplicar diversos algoritmos sobre las mismas.

Bajo la librer√≠a podemos definir las f√≥rmulas de dos formas distintas, o bien acudiendo directamente a los constructores de las f√≥rmulas (largo y engorroso), o bien utilizando el Parser (de forma an√°loga a la escritura natural de las f√≥rmulas).

$\longrightarrow$ <u>Definici√≥n de f√≥rmulas a partir de constructores (M√≥dulo *SintaxSemanticsLPO*)</u>

Antes de introducirnos en el estudio de la sintaxis de f√≥rmulas vamos a presentar la sintaxis y definici√≥n de t√©rminos. Recordemos que la estuctura de los t√©rminos corresponde a una definici√≥n recursiva con <u>variables</u> y <u>constantes</u> como *casos base* y <u>funciones</u>.

Aunque la definici√≥n en la librer√≠a sigue esta idea, se ha decidido modelar las <u>constantes</u> como funciones independientes de variables, de forma que en la librer√≠a se tiene que un t√©rmino es o bien una variable o bien una funci√≥n.

    type Term = Var String
              | Func String (List Term)

De forma que las constantes corresponder√≠an a objetos con la estructura *Func String [ ]*.

De forma que podemos definir t√©rminos de forma sencilla mediante el uso de estos constructores. Volviendo al ejemplo presentado anteriormente, (*Constantes*: *Marco*, *C√©sar*; *Variables*: $x$, $y$, $x_1$, ...; *Funciones*: f(C√©sar), f(x), f(f(x))):

```elm{l context="8"}

import Modules.SintaxSemanticsLPO exposing (..)

cesar = Func "cesar" []

marco = Func "marco" []

x = Var "x"

x_1 = Var "x_1"

f_cesar = Func "f" [cesar]

f_f_cesar = Func "f" [Func "f" [cesar]]
```

Ahora que ya podemos definir t√©rminos en LPO podemos pasar a ver la definici√≥n de f√≥rmulas. Si recordamos, las f√≥rmulas est√°n definidas con una estructura recursiva, de forma que las f√≥rmulas corresponden o bien a √°tomos (*caso base*), o bien a la aplicaci√≥n de las conectivas y/o cuantificadores sobre otras f√≥rmulas (*caso recursivo*).

Bien, pues la implementaci√≥n dada en la librer√≠a para las f√≥rmulas sigue fielmente dicha definici√≥n. De forma que: (definiendo el tipo *Variable* como alias de *Term*)

    type alias Variable = Term

    type FormulaLPO = Pred String (List Term)
                    | Equal Term Term
                    | Neg FormulaLPO
                    | Conj FormulaLPO FormulaLPO
                    | Disj FormulaLPO FormulaLPO
                    | Impl FormulaLPO FormulaLPO
                    | Equi FormulaLPO FormulaLPO
                    | Exists Variable FormulaLPO
                    | Forall Variable FormulaLPO
                    | Insat

De forma que esto nos permite expresar sint√°cticamente todas las f√≥rmulas en LPO. Para los ejemplos expuestos:

```elm{l context="9"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)


f1 : FormulaLPO
f1 = Pred "P" [Func "cesar" []]

```

^^^elm{m=(toLatexFLPO f1) context="9"}^^^

```elm{l context="9"}

f2 : FormulaLPO
f2 = Pred "L" [Func "cesar" [], Func "marco" []]

```

^^^elm{m=(toLatexFLPO f2) context="9"}^^^


```elm{l context="9"}

f3 : FormulaLPO
f3 = Pred "IA" [Func "cesar" [], Func "f"  [Var "x"]]

```

^^^elm{m=(toLatexFLPO f3) context="9"}^^^

```elm{l context="9"}

f4 : FormulaLPO
f4 = Forall (Var "x") (Exists (Var "y") (Pred "L" [Var "x", Var "y"]))

```

^^^elm{m=(toLatexFLPO f4) context="9"}^^^

```elm{l context="9"}

f5 : FormulaLPO
f5 = Forall (Var "x") (Impl (Pred "R" [Var "x"]) (Disj (Pred "L" [Var "x",Func "cesar" []]) (Pred "O" [Var "x",Func "cesar" []])))

```

^^^elm{m=(toLatexFLPO f5) context="9"}^^^

$\longrightarrow$ <u>Definici√≥n de f√≥rmulas LPO con Parser (M√≥dulo *IO_LPO*)</u>

Aunque ya podemos definir todas las f√≥rmulas en LPO, su escritura resulta una tarea muy pesada, para aliviar esa carga se ha desarrollado un Parser que permite la lectura de f√≥rmulas a partir de una cadena de texto en el que las f√≥rmulas se escriben de forma an√°loga a como se dan en el lenguaje formal de la l√≥gica. Se establecen algunas reglas sint√°cticas en su uso:

- Las <u>variables</u> se escriben con una letra en min√∫scula seguidas de caracteres alphanum√©ricos o el s√≠mbolo '_'. Algunos ejemplos: *'x'* , *'x_1'*, *'x1'*, ...

- Las *funciones* se definen siguiendo la notaci√≥n prefija, seg√∫n el patr√≥n:<br><br>

    <center><i> [S√≠mbolo de funci√≥n] [par√°metros]</i></center>

    Tal que: <br><br>

    - El *s√≠mbolo de funci√≥n* debe comenzar por el car√°cter '_', seguido de una serie de caracteres, entre estos se admiten caracteres alfanum√©ricos y tambi√©n s√≠mbolos, excepto '[', ']', '(', ')', '{', '}', ';'. <br><br>

    - En los *par√°metros* se pueden dar 2 casos, o bien la funci√≥n corresponde a una <u>constante</u> y por tanto no tiene par√°metros, con lo cual bastar√≠a escribir el s√≠mbolo de funci√≥n (ejemplos: *'_a'*, *'_PEDRO'*, *'_1'*) o bien es una <u>funci√≥n</u> (dependiente de, al menos, un t√©rmino), en tal caso los argumentos se dan en una lista acotada por corchetes ('[', ']') y tras cada argumento ha de ir un ';' (ejemplos: *'_f[x;]'*, *'_g[x;y;]'*, *'_+[x;\_1;\_¬∑[y;\_2;]]'*).

- Los <u>predicados</u> se definen utilizando la notaci√≥n prefija seg√∫n el patr√≥n:<br><br>

    <center><i> [s√≠mbolo de predicado] [par√°metros]</i></center>

    Tal que: <br><br>

    - El *s√≠mbolo de predicado* debe comenzar por un car√°cter en may√∫scula o un s√≠mbolo (exceptuando '_',  '!', '(', ')', '[', ']', '}', '}' (tambi√©n se admiten d√≠gitos num√©ricos pero no se recomienda), seguido de una serie de caracteres, entre estos se admiten caracteres alfanum√©ricos y tambi√©n s√≠mbolos (exceptuando '(', ')', '[', ']', '}', '}'). Son palabras reservadas (y por tanto no se pueden usar como predicados) *"NOT", "AND", "OR", "IMPLIES", "EQUIV", "EXISTS", "FORALL", "INSAT"* <br><br>

    - En los *par√°metros* se pueden dar 2 casos, o bien la funci√≥n es un <u>predicado proposicional</u> (no tiene par√°metros), con lo cual bastar√≠a escribir el s√≠mbolo de predicado (ejemplos: *'P'*, *'Q\_1'*) o bien es un <u>predicado n-ario</u> (dependiente de, al menos, un par√°metro), en tal caso los argumentos se dan en una lista acotada por corchetes ('[', ']') y tras cada argumento ha de ir un ';' (ejemplos:'P[x;]', '>=[x;y;]', 'MAX[x;\_1;\_¬∑[y;\_2;]]').<br><br>

    Hay una excepci√≥n, *predicado de igualdad* (binaria) se utilizar√° de forma infija separando los t√©rminos con el s√≠mbolo '=' (ejemplos: 'x=y' , 'x\_4=\_3', '\_f[x;]=\_f[y;]') (El predicado de igualdad es de uso exclusivamente binario).

    <center><i> [t√©rmino] = [t√©rmino]</i></center><br><br>

- Los <u>cuantificadores</u> se expresan de forma an√°loga al lenguaje formal de LPO seg√∫n el patr√≥n:

    <center><i> [s√≠mbolo de cuantificador] [variable] [f√≥rmula]</i></center><br><br>

    Tal que: <br><br>

    - Los *s√≠mbolos de cuantificadores* corresponden a:

    <table style="margin-left: auto; margin-right: auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Cuantificador</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">S√≠mbolo Logicus</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Existencial (‚àÉ)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'EXISTS'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Universal (‚àÄ)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'FORALL'</td></tr></tbody></table><br>

    - La *variable* debe ir entre llaves ('{', '}'), respetando las reglas establecidas para la definici√≥n de variables.<br><br>

    - La *f√≥rmula* escrita respetando los criterios dados para la escritura de las f√≥rmulas.<br><br>


 - Las conectivas se usar√°n de forma infija (salvo para la *negaci√≥n*),  utilizando los siguientes s√≠mbolos, manti√©ndose la prioridad de las conectivas definida (en el orden de prioridad descendente expuesto en la tabla).

<table style="margin-left: auto; margin-right: auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Conectiva</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">S√≠mbolo Logicus</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Negaci√≥n (¬¨)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'NOT'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Conjunci√≥n (‚àß)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'AND'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Disyunci√≥n (‚à®)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'OR'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Implicaci√≥n (ü°í)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'IMPLIES'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Equivalencia (ü°ò)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'EQUIV'</td></tr></tbody></table><br>

- Los par√©ntesis se utilizan de igual forma en que se han definido en el lenguaje formal de la l√≥gica proposicional, con los s√≠mbolos '(' y ')'. No son necesarios los par√©ntesis externos de las f√≥rmulas.<br><br>

- En caso de uso repetido de una misma conectiva y/o cuantificador, se realizar√° asociaci√≥n por la derecha.<br><br>

Al igual que ocurr√≠a en el Parser de LP una vez le√≠da la f√≥rmula con la funci√≥n *fromStringToFLPO* es necesario extraerla utilizando la funci√≥n *extractReadFLPO*.

Vamos a mostrar algunos ejemplos de definici√≥n de las f√≥rmulas utilizando el Parser de LPO.

- Ejemplo 1: $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$

```elm{l context="10"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)

f1 : FormulaLPO
f1 = fromStringToFLPO "FORALL{x}(R[x;] IMPLIES (L[x;_cesar;] OR O[x; _cesar;]))" |> extractReadFLPO

-- Ejecutamos (toLatexFLPO f1) para mostrar la f√≥rmula
```

Que corresponde a:

^^^elm{m=(toLatexFLPO f1) context="10"}^^^

- Ejemplo 2 (tomando el lenguaje matem√°tico), definamos la propiedad biyectiva. Para expresarla consideremos el siguiente lenguaje: $L= \{O, I, f\}$, tal que:

    - $O$ es un predicado de aridad 1 que expresa si el objeto pertenece al conjunto origen.

    - $I$ es un predicado de aridad 1 que expresa si el objeto pertenece al conjunto imagen.

    - $f$ es una funci√≥n que dado un elemento del conjunto origen obtiene el correspondiente elemento del conjunto imagen y dado un elemento del conjunto imagen obtiene el correspondiente del conjunto origen.

    La propiedad biyectiva se formula como: <br><br>

    <center><i> Una relaci√≥n es biyectiva si para todo elemento del conjunto origen existe un √∫nico elemento del conjunto imagen con el que est√° relacionado y todo elemento del conjunto imagen est√° relacionado con alg√∫n elemento del origen</i></center><br>

    Esto es: $$ \forall x,y \in O \, (x \neq y \rightarrow f(x) \neq f(y)) \wedge \forall x \in I \, \exists y \in O \, (f(x)=y)$$<br>

    ```elm{l context="10"}

    biyectiva : FormulaLPO
    biyectiva = fromStringToFLPO
                    "FORALL{x} FORALL{y} (O[x;] AND O[y;] AND NOT (x=y) IMPLIES NOT (_f[x;]=_f[y;])) AND FORALL{x}(I[x;] IMPLIES EXISTS{y}(O[y;] AND _f[y;]=x))"
                |> extractReadFLPO

    -- Ejecutamos (toLatexFLPO biyectiva) para mostrar la f√≥rmula
    ```

    ^^^elm{m=(toLatexFLPO biyectiva) context="10"}^^^

    $\longrightarrow$ <u>√Årboles de formaci√≥n LPO en Logicus</u>

    La librer√≠a tambi√©n permite la representaci√≥n de los √°rboles de formaci√≥n LPO. La funci√≥n *formtree* (del m√≥dulo *IO_LPO*) muestra la representaci√≥n del √°rbol de formaci√≥n en formato texto DOT, de forma an√°loga a como lo hac√≠a en el caso de LP

    Por ejemplo para la f√≥rmula $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$:

    ```elm {l context="11"}

    import Modules.IO_LPO exposing (..)
    import Modules.SintaxSemanticsLPO exposing (..)
    import Modules.AuxForLitvis exposing (showGraphViz)

    f : FormulaLPO
    f = fromStringToFLPO "FORALL{x}(R[x;] IMPLIES (L[x;_cesar;] OR O[x; _cesar;]))" |> extractReadFLPO

    ft_f : String
    ft_f = formTree f
    ```
    De forma que se obtiene:

    $$ \textrm{√Årbol de formaci√≥n de } \forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$$

    ^^^elm {m=(showGraphViz "g2" ft_f) context="11"}^^^

##### Alcance de los cuantificadores.

Hemos estudiado la sint√°xis formal de las f√≥rmulas, pero a√∫n faltan algunos detalles por completar para establecer qu√© f√≥rmulas est√°n bien formadas y cu√°les no. Un tema importante es el tratamiento de la cuantificaci√≥n, esto es, a qu√© aparciones u ocurrencias (denominadas estancias) de una variable afecta un cuantificador.

> Una ocurrencia de una variable est√° afectada por un cuantificador (se dice que es una **estancia u ocurrencia ligada**) si hay un cuantificador sobre dicha variable actu√°ndo sobre la (sub)f√≥rmula que la contiene. En otro caso diremos que se trata de una **estancia u ocurrencia libre**

Para comprenderlo mejor vamos a explicar un ejemplo:

$$ \underbrace{\forall x}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {1}}}} \, \boxed{( P(\underbrace{x}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{x ligada}\end{array}}, \underbrace{y}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{y libre}\end{array}}) ->  \underbrace{\exists y}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {2}}}} \, \boxed{R(\underbrace{y}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{y ligada}\end{array}}, \underbrace{x}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{x ligada}\end{array}})}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {2}}}} )}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {1}}}}$$

En la f√≥rmula podemos apreciar que el cuantificador, $\forall x$, afecta a toda la f√≥rmula siguiente, por tanto todas las ocurrencias de $x$ que aparezcan en la f√≥rmula ser√°n ocurrencias ligadas. Sin embargo, $P(x,y)$ no est√° afectado por ning√∫n otro cuantificador, por tanto, la ocurrencia de $y$ en $P(x,y)$ es libre. Por otra parte, $R(x,y)$ s√≠ est√° afectado por el cuantificador $\exists y$,  por tanto tanto la ocurrencia de $x$ como la de $y$ en $R(y, x)$ son ligadas.

De forma similar se definen las variables *libres* y *ligadas* como:

> Una variable $x$ se dice **varible libre** en una f√≥rmula $F$ si existe alguna ocurrencia libre de $x$ en $F$. <br>
Una variable $x$ se dice **varible ligada** en una f√≥rmula $F$ si existe alguna ocurrencia ligada de $x$ en $F$.

De forma que en una f√≥rmula una variable puede ser al mismo tiempo *variable libre* y *variable ligada*.

Por ejemplo, en la f√≥rmula anterior $x$ es una variable *exclusivamente cerrada* (todas sus ocurrencias son ligadas), sin embargo $y$ es una variable *libre* y *ligada* (hay una ocurrencia libre y otra ligada).

En base a los conceptos anteriores se definen los conceptos:

> Se dice que un **t√©rmino** es **cerrado** si no contiene ninguna variable.

Por ejemplo: $C√©sar$, $f(Marco)$, $f(f(C√©sar))$; son t√©rminos cerrados en el lenguaje $LR$.

> Se dice que una **f√≥rmula** es **cerrada** si no contiene variables libres, o equivalentemente si todas las estancias de todas las variables son ligadas.

Por ejemplo las f√≥rmulas $\forall x (L(x, C√©sar) \vee O(C√©sar, x))$, $\forall x L(x, C√©sar) \rightarrow \neg \exists y O(C√©sar, y)$ son una *f√≥rmulas cerradas*, mientras que las f√≥rmulas $\forall x L(x, C√©sar) \vee O(C√©sar, x)$ , $\forall x L(x, C√©sar) \rightarrow \neg \exists y IA(y, x)$ no lo son.

> Se dice que una **f√≥rmula** es **abierta** si no contiene cuantificadores, esto es todas las variables son, exclusivamente, *variables libres*.

Por ejemplo son f√≥rmulas abiertas $P(x)$, $R(C√©sar)$, $P(x) \leftrightarrow \neg IA(f(x), Marco)$.

Los algoritmos de decisi√≥n que vamos a estudiar trabajan √∫nicamente sobre f√≥rmulas cerradas, por lo que hemos de *clausurar* todas aquellas f√≥rmulas que no sean cerradas, cuantificando las variables libres de la f√≥rmula.

$\boxed{Continuar√°}$
