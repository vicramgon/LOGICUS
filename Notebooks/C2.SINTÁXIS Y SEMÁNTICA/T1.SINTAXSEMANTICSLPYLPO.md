---
elm:
  source-directories:
    - ../../elm-sources/src
  dependencies:
      elm/browser: latest
      elm/core: latest
      elm/file: latest
      elm/html: latest
      elm/parser: latest
      elm-community/graph: latest
      elm-community/list-extra: latest
      elm-community/maybe-extra: latest
      munksgaard/char-extra: latest
      gicentre/elm-vegalite: latest
      avh4/elm-fifo: latest
      elm/bytes: latest
      elm/json: latest
      elm/time: latest
      elm/url: latest
      elm/virtual-dom: latest
      elm-community/intdict: latest
      Chadtech/elm-bool-extra: latest
---

<!-- Cargamos algunas funciones js que necesitamos -->

<script src="../js/d3.min.js"></script>
<script src="../js/viz.js" type="javascript/worker"></script>
<script src="../js/d3-graphviz.js"></script>
<script type="text/javascript">

    function plotDot(graphId){
        d3.select('#svgContainer' + graphId)
        .graphviz()
        .renderDot(document.getElementById("inDOT" + graphId).value.replace(/\\n/g, "\n").replace(/\\"/gm, '"'));

        document.getElementById("outputGraph" + graphId).style.display = "inline-block";
        document.getElementById("inputGraph" + graphId).style.display = "none";
    };

    function generatePng(graphId){
        var svgElement = document.getElementById('svgContainer' + graphId).querySelector('svg');
        var svgString = new XMLSerializer().serializeToString(svgElement);
        var canvas = document.getElementById("canvas" + graphId);
        canvas.width = svgElement.getBBox().width*1.33;
        canvas.height = svgElement.getBBox().height*1.33;
        var ctx = canvas.getContext("2d");
        var DOMURL = self.URL || self.webkitURL || self;
        var img = new Image();
        var svg = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});
        var url = DOMURL.createObjectURL(svg);
        img.onload = function() {
            ctx.drawImage(img, 0, 0);
            var png = canvas.toDataURL("image/png");

            document.querySelector("#pngContainer" + graphId).innerHTML = '<a id="downloadPNG'+ graphId +'" href="'+png+'" download/> PNG Image </a>';
            imgdownload = document.getElementById("downloadPNG"+ graphId)
            imgdownload.click();
            DOMURL.revokeObjectURL(png);
        };
        img.src = url;
    };
</script>


## **TEMA 1**
Sintaxis y Semántica en LP y LPO
====================

Descripción general del capítulo
--------------------------------

En este capítulo se recogen, de forma detallada, los módulos implementados que abordan el ámbito de la sintaxis y semántica de la Lógica Proposicional y Primer Orden. Complementariamente, en el *Anexo A. Parsers* se encuentra el desarrollo de varios Parsers, que nos permiten acercar la escritura natural de las fórmulas a la definición en el sistema.

### <u> Estructura del capítulo </u>

El capítulo se encuentra estructurado en distintas secciones, a través de las cuales se abordan los conceptos fundamentales del ámbito sintáctico-semántico de la LP y la LPO, presentados conjuntamente con los módulos que implementan dichos conceptos:

-   **Módulo SintaxSemanticsLP**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sintácticoS Y semánticos de la Lógica Proposicional.

-   **Módulo SintaxSemanticsLPO**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sintácticos y semánticos de la Lógica de Primer Orden.

-   **Módulo IO\_LP**. Recoge las implementaciones de los métodos relacionados con la lectura y representación de las fórmulas LP.

-   **Módulo IO\_LPO**. Recoge las implementaciones de los métodos relacionados con la lectura y representación de las fórmulas LPO.


1.1. Conceptos básicos de la Lógica Proposicional
--------------------------------------------

### Caracterización básica de la Lógica Proposicional

La Lógica surge como método de modelado del siguiente problema:

> *Dado un conjunto de asertos (afirmaciones), $\mathcal{BC}$ (*Base de conocimiento*), y una afirmación, $\mathcal{A}$, decidir si $\mathcal{A}$ ha de ser necesariamente cierta supuestas ciertas las fórmulas de $\mathcal{BC}$.*


De manera que para abordar este problema resultan necesarios los siguientes elementos:

-   Un lenguaje que permita expresar de manera formal y precisa las afirmaciones, hechos e hipótesis. (<u>Sintaxis</u>)

-   Una definición clara de qué se considera *afirmación cierta*  (<u>Semántica</u>)

-   Mecanismos efectivos (y a poder ser eficientes) que garanticen la corrección (y preferentemente la completitud) en las deducciones. (<u>Algoritmos de decisión</u>)

A lo largo de los distintos capítulos abordaremos estos puntos para las dos representaciones más comunes, la Lógica Proposicional (*LP* o *PL*) y la Lógica de Primer Orden (*LPO* o *FOL*).

Por el momento vamos a comenzar este primer capítulo abordando los dos primeros puntos para la Lógica Proposicional y la Lógica de Primer Orden, dando una somera introducción al tercero para cada caso dejando el desarrollo de los algoritmos de decisión, que se irán abordando a lo largo del resto de capítulos.

#### Características fundamentales de la LP.

-   Sus expresiones (denominadas f*órmulas proposicionales* o *proposiciones*) modelan afirmaciones que pueden considerarse *ciertas* o *falsas*.

-   Las fórmulas proposicionales (en adelante fórmulas (si no existe ambigüedad)), se construyen mediante un conjunto de expresiones  básicas (*fórmulas atómicas* o *átomos*) y conjunto de operadores (*conectivas lógicas*). Dichas conectivas permiten modelar los  siguientes tipos de afirmaciones:

    -   *Conjunción*: ‘... tal ... Y ... cual ...’

    -   *Disyunción*: ‘... tal ... O ... cual ...’

    -   *Implicación*: ‘SI tal ... ENTONCES ... cual ...’

    -   *Equivalencia*: ‘... tal ... SI Y SÓLO SI ... cual ...’

    -   *Negación*: ‘NO es cierto tal ...’

    Profundizaremos en este aspecto en la próxima sección, cuando  veamos la *Sintaxis de la LP*.

-   El lenguaje sólo permite modelar este tipo de afirmaciones, por lo que muchas veces puede ser difícil (o imposible) representar el problema en este tipo de Lógica, y es necesario recurrir a otras más  ricas (*LPO, Lógicas Modales, Lógica Fuzzy, etc*). Especificaremos este apartado cuando tratemos las limitaciones de la LP e introduzcamos la LPO.

-   Aunque esta Lógica puede resultar de una aparente sencillez, el problema *SAT* corresponde a la categoría de problemas NP-completos, esto es, no existe ningún algoritmo capaz de resolver el problema planteado en un tiempo polinomial de ejecución. Trataremos de nuevo este aspecto en la introducción a los algoritmos de decisión.

1.2. Fundamentos de la lógica proposicional
--------------------------------------------

Vamos a abordar desde un punto de vista teórico-práctico, los elementos base que conforman la Lógica Proposicional, esto es la Síntaxis y la Semántica, mostrando unificadamente los desarrollos formales como las implementaciones llevadas a cabo para modelar cada uno de ellos.

### Sintáxis de la lógica Proposicional

#### El alfabeto proposicional

El concepto ‘*alfabeto proposicional*’ referencia al conjunto de símbolos que forman parte de este lenguaje. Podemos distinguir las siguientes categorías:

-   **Variables proposicionales o átomos**. Ya hemos señalado previamente que todo problema está representado por relaciones entre un conjunto finito de afirmaciones básicas, dichas afirmaciones se representan por símbolos proposicionales: $VP = \{p_0, p_1, \ldots, p, q, r\}$. <br><br>

    Aunque, formalmente, no existe ninguna restricción, vamos a adoptar el siguiente criterio en relación a la sintaxis de los símbolos proposicionales:<br><br>

    > Los símbolos proposicionales deben comenzar por una letra minúscula, seguida (opcionalmente) de otros caractéres en minúscula o dígitos numéricos, exclusivamente.

-   **Conectivas Lógicas**. Modelan las relaciones entre las distintas afirmaciones básicas (átomos). Podemos distinguir:

    -   De aridad 1 o monoaria : *Negación* ($\neg$).

    -   De aridad 2 o binarias: *Conjunción* ($\wedge$), *Disyunción* ($\vee$), *Condicional* ($\rightarrow$), *Bicondicional* ($\leftrightarrow$).<br><br>

-   **Símbolos Auxiliares**: ‘*(*’ y ‘*)*’. Permiten expresar relaciones de prioridad entre conectivas lógicas y evitar la ambigiüedad en la interpretación de las fórmulas.

#### Fórmula Proposicional

Se denomina expresión del lenguaje proposicional a cada una sucesión finita (y no vacía) de sus símbolos y conectivas.Un ejemplo de expresión puede ser la siguiente $a \rightarrow b )ca\vee$, otro puede corresponder a $(a \rightarrow b ) \vee c$. Parece claro que el primero posee “una coherencia” o“equilibrio que no parece tener el primero. De esta forma, las expresiones "bien formadas" las denominaremos **fórmulas proposicionales**.

> Formalmente, El conjunto de las fórmulas proposicionales, $PROP$, es el menor conjunto de expresiones que verifica:
> - $VP \subseteq PROP$
> - Es cerrado bajo las conectivas lógicas, esto es:
    - Si una fórmula $F \in PROP$, entonces $\neg F \in PROP$
    - Si las fórmulas $F, G \in PROP$, entonces $(F \wedge G), (F \vee G), (F \rightarrow G), (F \leftrightarrow G) \in PROP$

De manera que se tiene una definición recursiva del concepto de *Fórmula Proposiciona*, tal que el caso base corresponde a una fórmula básica (*átomo*) y el caso recursivo corresponde a la aplicación de una conectiva sobre una o dos fórmulas (según la aridad de la conectiva).

##### Árboles de formación

Cada una de las fórmulas proposicionales lleva asociado un grafo de tipo árbol (esencialmente único), que muestra el desarrollo de formación de la fórmula, siguiendo la definición recursiva de la misma.

Por ejemplo a la fórmula: $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$ le corresponde el árbol de formación:

<center> <img src="images/T1Img1.png" title="Árbol formación (ejemplo)"></center><br>

##### Prioridad de conectivas y Reducción de paréntesis.

Para facilitar la escritura y lectura de las fórmulas vamos a adoptar algunos criterios:

1.  Omitimos los paréntesis externos.<br><br>
2.  Tomaremos como orden de precedencia de las conectivas (de mayor a  menor): $\neg$, $\wedge$, $\vee$ , $\rightarrow$, $\leftrightarrow$. (Para la conectiva $\leftrightarrow$ se recomienda mantener los paréntesis en todos los casos).<br><br>
3.  Cuando una conectiva se usa repetidamente, se asocia por la derecha.<br><br>

##### Principio de inducción sobre fórmulas

Gracias a la definición de $PROP$ (y su estructura recursiva), para probar que toda fórmula proposicional satisface una cierta propiedad ($\Psi$), podemos hacerlo aplicando el método de inducción sobre fórmulas.

De esta forma, probamos:

1.  (*Caso base*). Probar que todos los elementos de $VP$ tienen la propiedad $\Psi$.

2.  (*Paso de inducción*).

    -  Si $F \in PROP$ tiene la propiedad $\Psi$, entonces $\neg F$ tiene la propiedad $\Psi$.

    -  Si $F, G \in PROP$, tienen la propiedad $\Psi$ entonces $(F \wedge G), (F \vee G), (F \rightarrow G), (F \leftrightarrow G) \in PROP$ tienen la propiedad $\Psi$

##### Escritura de las fórmulas en Logicus

Vamos a exponer cuál es la sintaxis de las fórmulas utilizando la librería Logicus, que nos permitirá definir fórmulas y aplicar diversos algoritmos sobre las mismas.

En la librería podemos definir las fórmulas de dos formas distintas, o bien acudiendo directamente a los constructores de las fórmulas (largo y engorroso), o bien utilizando el Parser (de forma análoga a la escritura natural de las fórmulas).

$\longrightarrow$ <u>Definición de fórmulas a partir de constructores</u>

Si recordamos la definición recursiva que se ha dado para las fórmulas, expusimos que las mismas pueden corresponder o bien a átomos (*caso base*), o bien a la aplicación de las conectivas, teniendo en cuenta la aridad de éstas, sobre fórmulas proposicionales (*caso recursivo*).

Bien, pues la implementación dada en la librería para las fórmulas corresponde fielmente a dicha definición. De forma que:

- Los símbolos proposicionales se definen como cadenas de caractéres, (recordando el criterio, estos caracteres deben ir en minúscula).<br><br>

        type alias PSymb = String

- Las fórmulas proposicionales se definen según la estructura recursiva presentada.<br><br>

        type FormulaLP = Atom PSymb                 -- caso base
                        | Neg FormulaLP             --⎫
                        | Conj FormulaLP FormulaLP  --⎪
                        | Disj FormulaLP FormulaLP  --⎬ casos recursivos
                        | Impl FormulaLP FormulaLP  --⎪
                        | Equi FormulaLP FormulaLP  --⎭
                        | Insat                     -- fórmula insatisfactible

Esto nos permite definir todas las fórmulas proposicionales. Para poder hacer uso de la librería logicus tenemos que importar de los módulos correspondientes las funciones y tipos necesarios para nuestro trabajo.

Expongamos algunos ejemplos:

a. $(p \wedge q) \vee (p \wedge r) \quad$ b. $ (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q \quad$ c. $(p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p$<br>

```elm {l context="1"}

import Modules.IO_LP exposing (toLatexFLP)
import Modules.SintaxSemanticsLP exposing (FormulaLP(..))

a : FormulaLP
a = Disj (Conj (Atom "p") (Atom "q")) (Conj (Atom "p") (Atom "r"))
```
^^^elm {m=(">" ++ toLatexFLP "a" a) context="1"}^^^

```elm {l context="1"}
b : FormulaLP
b = Impl (Disj (Conj (Atom "p") (Atom "r")) (Conj (Neg (Atom "p")) (Atom "q"))) (Neg (Atom "q"))
```

^^^elm {m=(">" ++ toLatexFLP "b" b) context="1"}^^^

```elm{l context="1"}
c : FormulaLP
c = Conj (Conj (Equi (Atom "p") (Atom "q")) (Impl (Atom "p") (Neg (Atom "q")))) (Atom "p")
```

^^^elm {m=(">" ++ toLatexFLP "c" c) context="1"}^^^

Como se puede apreciar, escribir las fórmulas de esta forma puede resultar una tarea ardua y propensa a errores, por eso, se ha desarrollado un parser que nos permite escribir de forma más cómoda,sintética y visual las fórmulas. Para poder utilizarlo se han establecido una serie de requisitos sintácticos, análogos a los presentados anteriormente:

- Los símbolos proposicionales deben comenzar por un caracter en minúscula seguido, opcionalmente, de caracteres en minúscula, dígitos o el símbolo '_'.<br><br>

- Para las conectivas se usarán los siguientes símbolos, mantiéndose la prioridad de las conectivas definida (en el orden de prioridad descendente expuesto en la tabla).

<table style="margin-left: auto; margin-right: auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Conectiva Lógica</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Símbolo Logicus</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Negación (¬)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'NOT'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Conjunción (∧)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'AND'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Disyunción (∨)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'OR'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Implicación (🡒)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'IMPLIES'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Equivalencia (🡘)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'EQUIV'</td></tr></tbody></table><br>

- Los paréntesis se utilizan de igual forma en que se han definido en el lenguaje formal de la lógica proposicional, con los símbolos '(' y ')'. No son necesarios los paréntesis externos de las fórmulas.<br><br>

- En caso de uso repetido de una misma conectiva, se realizará asociación por la derecha.

A partir de este momento todas las fórmulas de los ejemplos se definirán utilizando el Parser por lo que llegados a este punto se recomienda tener claras las reglas sintácticas a seguir, aunque, son análogas a las planteadas por el lenguaje formal de la lógica proposicional.

Para definir los ejemplos expuestos anteriormente:

```elm {l context="2"}
import Modules.SintaxSemanticsLP exposing (FormulaLP(..))
import Modules.IO_LP exposing (toLatexFLP, fromStringToFLP, extractReadFLP)

a : FormulaLP
a = fromStringToFLP "(p AND q) OR (p AND t)" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "a" a) context="2"}^^^
```elm{l context="2"}
b : FormulaLP
b = fromStringToFLP "(p AND r) OR (NOT p AND q) IMPLIES NOT q" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "b" b) context="2"}^^^
```elm{l context="2"}
c : FormulaLP
c = fromStringToFLP "(p EQUIV q) AND (p IMPLIES NOT q) AND p" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "c" c) context="2"}^^^

Nótese que la función *fromStringToFLP* proporciona una tupla de dos elementos el primero de ellos corresponde a la fórmula leída y el segundo a una cadena de texto. Bien, si cometemos algún error sintáctico en la escritura de la fórmula el Parser no será capaz de interpretarla correctamente por lo que devolverá una tupla *(Nothing,error)*, en el que el segundo elemento corresponderá al mensaje de error y el primer elemento a un objeto vacío.

Una vez leída la fórmula correctamente podemos extraerla utilizando la función *extractReadFLP*. Si utilizamos dicha función sobre una fórmula leída incorrectamente, se extraerá como fórmula la fórmula insatisfactible.

$\longrightarrow$ <u>Árboles de formación en Logicus</u>

La librería también permite la representación de los árboles de formación. La función *formtree* muestra la representación del árbol de formación en formato texto DOT.

Por ejemplo para la fórmula $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$:

```elm {l context="3"}
import Modules.IO_LP exposing (toLatexFLP, fromStringToFLP, extractReadFLP, formTree)
import Modules.SintaxSemanticsLP exposing (FormulaLP(..))
import Modules.AuxForLitvis exposing (showGraphViz)

a : FormulaLP
a = fromStringToFLP "NOT ( NOT (p OR q) IMPLIES (NOT r AND s))" |> extractReadFLP

fta : String
fta = formTree a
```
De forma que se obtiene:

^^^elm {m=(showGraphViz "G1" fta) context="3"}^^^

#### Conjuntos de fórmulas

Definido $PROP$, los conjuntos de fórmulas no son más que subconjuntos de $PROP$, esto es, corresponden a agrupaciones de fórmulas proposicionales.


##### Conjuntos de fórmulas en Logicus

Los conjuntos proposicionales se definen como listas de fórmulas proposicionales. De esta forma:


    type alias LPSet = List FormulaLP

De forma que la definición de estos se realiza como listas de objetos *FormulaLP*. Si por ejemplo queremos definir el conjunto:
$$ M = \left\lbrace (p \wedge q) \vee (p \wedge r), (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q, (p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p \right\rbrace$$

Podríamos hacerlo:

```elm{l context="4"}

import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)

a : FormulaLP
a = fromStringToFLP "(p AND q) OR (p AND r)" |> extractReadFLP

b : FormulaLP
b = fromStringToFLP "(p AND r) OR (NOT p AND q) IMPLIES NOT q" |> extractReadFLP

c: FormulaLP
c = fromStringToFLP "(p EQUIV q) AND (p IMPLIES NOT q) AND p" |> extractReadFLP

m : LPSet
m = [a,b,c]
```

De forma que se obtiene:

^^^elm{m=(">" ++ toLatexLPSet "M" m) context="4"}^^^

### Semántica de la Lógica Proposicional

#### Interpretaciones, Modelos, Satisfactibilidad y Validez Lógica

Una vez provista la sintaxis, pasamos a desarrollar la semántica de la Lógica Proposicional. Como ya comentamos, hemos de abordar la interpretación de certeza o veracidad de las fórmulas. Para esto es necesario conocer los conceptos de *valor de verdad* y *función de verdad*.

> -  **Valor de verdad**. Los elementos del conjunto $\{0,1\}$ se denominan valores de verdad o valores booleanos. Representan si un hecho es cierto o no, de forma que el valor $1$ se asocia a *verdadero* y el valor $0$ a *falso*.<br><br>
>  -   **Funciones de verdad**. Corresponden a funciones que devuelven un valor de verdad según el valor de verdad de los argumentos. Así, el significado (valor de verdad asociado) de cada una de las conectivas lógicas viene dado por una función de verdad, de forma que:<br>
    $$\begin{array}{l l} H_{\neg}(i) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = 0\\
        0 & \textrm{si } i = 1\\
        \end{array} \right. & H_{\wedge}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j = 1\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\vee}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right. & H_{\rightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = 1, j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\leftrightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\end{array}$$

Visto esto, pasamos a estudiar el valor de verdad de las fórmulas proposicionales. Para ello debemos definir el valor de verdad de las variables proposicionales, (denominadas *valoraciones* o *interpretaciones*) y a partir de éstas y las funciones de verdad de las conectivas,podemos extender cada valoración,$v$,de forma única,al conjunto de todas las fórmulas de manera que se verifica:

$$\begin{array}{c c} v((F \wedge G))= H_{\wedge}(v(F), v(G)) & v((F \vee G))= H_{\vee}(v(F), v(G))\\\\ v((F \rightarrow G))= H_{\rightarrow}(v(F), v(G)) & v((F \leftrightarrow G))= H_{\leftrightarrow}(v(F), v(G)) \end{array}$$

> Dada una fórmula $F \in PROP$, se dice que $v(F)$ es el valor de verdad de $F$ respecto de la valoración $v$.

De esta forma, es sencillo realizar el cálculo del valor de verdad de una fórmula respecto de una valoración, recurriendo al árbol de formación de la fórmula, evaluando las subfórmulas, desde las hojas (variables proposicionales) hasta el nodo raíz (la fórmula completa).

Por ejemplo el cálculo de la valoración de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$:

<center> <img src="images/T1Img3.png" title="Cálculo de la valoración con el AF."></center><br>

Además del cáculo a través del Árbol de Formación, existe otro método (equivalente) para el cálculo del valor de verdad de una fórmula respecto de una valoración, cálculo a través de Tabla. Dado que, dada una valoración,$v$, el valor de verdad de una fórmula $F$ respecto de $v$ está determinado por los valores de verdad de las subfórmulas de $F$, podemos construir una tabla que recorra los valores de sus subfórmulas. Para el ejemplo anterior:

<table style="margin-left: auto; margin-right: auto; width:80%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p ∨ q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬(p ∨ q)</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬r ∨ s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬(p ∨ q) <span style="font-weight:400;font-style:normal">∨</span> <span style="font-style:normal">¬(r ∨ s)</span></th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬(<span style="font-style:normal">¬(p ∨ q) </span>∨ (¬r ∨ s))</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr></tbody></table><br>

##### Tablas de Verdad

Una tabla de verdad corresponde a una estructura similar a la anterior (nosotros sólo reflejaremos el valor de las variables proposicionales y el valor de verdad de la fórmula completa), en la que en cada fila se presenta la valoración y el valor de verdad de la fórmula respecto a la misma, para toda interpretación posible (que corresponda a las variables proposicionales presentes en la fórmula).

Para la fórmula anterior, su tabla de verdad correspondería a:

<table style="margin:auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬(<span style="font-style:normal">¬(p ∨ q) </span>∨ (¬ r ∨ s))</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr></tbody></table>


##### Modelos, Satisfactibilidad y Validez Lógica

Una vez estudiado lo anterior, vamos dar unas cuantas definiciones:

> -  **Modelo.** Se dice que una fórmula $F$ es válida en una valoración $v$ o equivalentemente que $v$ es **modelo** de $F$ si $v(F)=1$ y se denota por $v \models F$. En caso contrario, se dice que $v$ es **contramodelo** de $F$ y se denota $v \not \models F$.<br><br>
> - **Satisfactibilidad.** Una fórmula $F$ se dice **satisfactible** (o consistente) si existe una valoración $v$ que es modelo de $F$. En caso contrario se dice que $F$ es **insatisfactible** (o inconsistente), y se representa por $\perp$.<br><br>
> - **Validez lógica o Tautología**. Una fórmula $F$ se dice **tautología** (o (lógicamente) válida) si toda valoración es modelo de $F$ y se denota $\models F$.<br>

$\longrightarrow$ <u>Relación entre Validez y Satisfactibilidad</u>

> *LEMA*: Para cada $F \in PROP$ se verifica:
> -  Si $F$ es tautología, entonces $F$ es satisfactible.<br>
> -  $F$ es tautología si y sólo si $F$ es insatisfactible.<br>

<br>

##### Semántica de Fórmulas LP en Logicus

La librería dispone de funciones que modelan todos los conceptos semánticos que hemos visto hasta ahora.

$\longrightarrow$ <u>Valores, Funciones de Verdad e Interpretaciones</u>

Como hemos estudiado los **valores de verdad** corresponden a 1 (*verdadero*) y 0 (*falso*). Elm ya provee esos valores booleanos en el tipo *Bool*, por lo que no es necesario realizar ninguna definición alternativa para este concepto.

Las definición de las funciones de verdad asociadas a las conectivas corresponden directamente a la aplicación de dichas funciones en la evaluación de las fórmulas. Antes de ver la evaluación resulta necesario ver la definición que se ha dado para las interpretaciones. Para ello, se ha elegido una representación "dispersa" de manera que una interpretación corresponde a una lista de símbolos proposicionales (variables proposicionales) que son los que son considerados verdaderos, los términos que no aparecen en la lista serán considerados como falsos.

    type alias Interpretation = List PSymb

Con esta definición resulta sencillo llevar a cabo la evaluación de las fórmulas. Tal y como se ha planteado formamelte, podemos distinguir el proceso de evaluación en 2 casos:

- **Evaluación de variables**. Una variable será verdadera si en la interpretación le otorga dicho valor, esto es, según la definición dada, será verdadera si pertenece a la lista de la interpretación, y será falsa en caso contrario.

- **Evaluación de conectivas**. Según la definición formal dada:
$$\begin{array}{l l} H_{\neg}(i) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = 0\\
        0 & \textrm{si } i = 1\\
        \end{array} \right. & H_{\wedge}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j = 1\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\vee}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right. & H_{\rightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = 1, j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\leftrightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\end{array}$$

De forma que:

    valuation : FormulaLP -> Interpretation -> Bool
    valuation pr i =
        case pr of
            Atom p -> List.member p i
            Neg p -> not (valuation p i)
            Conj p q -> valuation p i &&  valuation q i
            Disj p q ->   valuation p i ||  valuation q i
            Impl p q ->   not (valuation p i) ||  valuation q i
            Equi p q ->   valuation (Impl p q) i &&  valuation (Impl q p) i
            Insat -> Basics.False

NOTA: nótese que la fórmula insatisfactible, lógicamente, es falsa respecto de cualquier valoración.

De forma que la función *valuation* nos permite calcular la valoración de una fórmula respecto de una valoración. Por ejemplo, calculemos la valoración de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$:

```elm{l context="5"}

import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)

f : FormulaLP
f = fromStringToFLP "NOT (NOT (p OR q) OR (NOT r OR s))" |> extractReadFLP

i : Interpretation
i = ["p", "q"]
```

^^^elm{r=(valuation f i) context="5"}^^^

$\longrightarrow$ <u>Tabla de Verdad, Modelos, Satisfactibilidad y Validez </u>

Como se ha expuesto anteriormente una tabla de verdad recoge las valoraciones de una fórmula respecto a todas las posibles interpretaciones que integran a sus símbolos proposicionales. Bien dada la definición de las interpretaciones resulta bien sencillo el cálculo de todas las posibles interpretaciones, de hecho el conjunto de interpretaciones corrsponde a todos los posibles subconjuntos del conjunto formado por los símbolos proposicionales que participan en la fórmula. De esta forma:

    symbInProp : FormulaLP -> Set.Set PSymb
    symbInProp f=
        case f of
            Atom p -> Set.singleton p
            Neg p -> symbInProp p
            Conj p q -> Set.union (symbInProp p ) (symbInProp q)
            Disj p q -> Set.union (symbInProp p ) (symbInProp q)
            Impl p q -> Set.union (symbInProp p ) (symbInProp q)
            Equi p q -> Set.union (symbInProp p ) (symbInProp q)
            Insat -> Set.empty

    allInterpretations : FormulaLP -> List Interpretation
    allInterpretations x =  Aux.powerset <| List.sort <| Set.toList <| symbInProp x

Y la tabla de verdad corresponde al conjunto de pares (*Interpretación, Valoración*), que corresponde a las entradas cada una de las entradas (filas) de la tabla.

    truthTable : FormulaLP -> List (Interpretation, Bool)
    truthTable x = List.map (\xs ->  (xs,valuation x xs)) <| allInterpretations x

Para el ejemplo anterior:

```elm{l context="6"}
import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)
import Modules.AuxForLitvis exposing (showTable)
import Modules.AuxiliarFunctions exposing (uncurry)
import Bool.Extra exposing (toString)

f : FormulaLP
f = fromStringToFLP "NOT (NOT (p OR q) OR (NOT r OR s))" |> extractReadFLP

-- Ejecutamos: truthTable f |> truthTableToMDFormat (symbInProp f) |> uncurry (showTable)
```

^^^elm{m=(truthTable f |> truthTableToMDFormat (symbInProp f) |> uncurry (showTable)) context="6"}^^^

Una vez calculadas todas las posibles interpretaciones resulta sencillo calcular los modelos y contramodelos de una fórmula proposicional, sin más que seleccionar aquellos que sean evaluados como verdaderos o falsos, respectivamente. Tal que:

    models : FormulaLP -> List Interpretation
    models x = List.filter (\y -> valuation x y) (allInterpretations x)

    countermodels : FormulaLP -> List Interpretation
    countermodels x = List.filter (\y -> not(valuation x y)) (allInterpretations x)

De forma que para la fórmula anterior, el conjunto de modelos y contramodelos correspondería a:

```elm{l context="6"}

modelos_f : List Interpretation
modelos_f =  models f
```

^^^elm{m=(interpretations2MDFormat modelos_f) context="6"}^^^

```elm{l context="6"}

contramodelos_f : List Interpretation
contramodelos_f = countermodels f
```

^^^elm{m=(interpretations2MDFormat contramodelos_f) context="6"}^^^

Del mismo modo resulta casi trivial decidir la satisfactibilidad y validez de las fórmulas proposicionales, sin más que comprobar si todas las interpretaciones hacen a la fórmula verdadera (*tautología*), alguna de ellas la hace verdadera (*fórmula satisfactible*), o no la hace ninguna de ellas (*fórmula insatisfactible*). Así:


    satisfactibility : FormulaLP -> Bool
    satisfactibility x = List.any (\xs-> valuation x xs) (allInterpretations x)

    validity : FormulaLP -> Bool
    validity x = List.all (\xs-> valuation x xs) (allInterpretations x)

    insatisfactibility : FormulaLP -> Bool
    insatisfactibility x = List.all (\xs-> not(valuation x xs)) (allInterpretations x)

De forma que en el caso dela fórmula anterior, sabemos que es satisfactible ya que el conjunto de modelos no era vacío, y que no es tautología ya que el de contramodelos tampoco lo era. Utilizando las funciones provistas por la librería:

```elm{l context="6"}

isSatisfactible_f : Bool
isSatisfactible_f = satisfactibility f
```
^^^elm{m=(toString isSatisfactible_f) context="6"}^^^

```elm{l context="6"}

isTaut_f : Bool
isTaut_f = validity f
```
^^^elm{m=(toString isTaut_f) context="6"}^^^

```elm{l context="6"}

isInsatisfactible_f : Bool
isInsatisfactible_f = insatisfactibility f
```

^^^elm{m=(toString isInsatisfactible_f) context="6"}^^^

#### Conjuntos de Fórmulas. Modelos y Consistencia.

De forma análoga a la presentada para las fórmulas proposicionales podemos definir los conceptos anteriores, aplicados a conjuntos de fórmulas de forma que:

>- **Modelo.** Se dice que una valoración $v$ es **modelo** de un conjunto de fórmulas $U$ si para toda fórmula $F \in U$ se tiene que $v(F)=1$ y se denota por $v \models U$. En caso contrario, se dice **contramodelo**.<br><br>
> -   **Consistencia** Un conjunto de fórmulas $U$ se dice **consistente** si existe una valoración $v$ que es modelo de $U$. En caso contrario se dice que $U$ es **inconsistente**.


##### Consecuencia Lógica.

>Una fórmula $F$ es consecuencia lógica (o se sigue) de un conjunto de fórmulas $U$, y se denota por $U \models F$, si toda valoración que es modelo de $U$ es también modelo de $F$.

Es precisamente este concepto el que permite formular el problema básico en el marco de la lógica proposicional, que planteamos como objetivo de la LP.

##### Relación entre consecuencia lógica, consistencia y validez

> *PROPOSICIÓN*: Sea $U = \{F_1, F_2, \ldots, F_n \} \subseteq PROP$ y $F \in PROP$ son equivalentes:
>- $(U = \{F_1, F_2, \ldots, F_n \}) \models F$<br><br>
>- $\left(\bigwedge \limits_{F_i} U = (F_1 \wedge F_2 \wedge \ldots \wedge F_n)\right) \rightarrow F \in TAUT$<br><br>
>- $\left( U \cup \{\neg F\} = \{F_1 , F_2 , \ldots , F_n , \neg F\} \right) \models \perp$

##### Semántica de Conjuntos LP en Logicus

Al igual que en el caso de las fórmulas proposicionales podemos realizar una traslación directa de los conceptos formalmente expuestos a las implementaciones, de forma que el cálculo de las posibles interpretaciones, análogamente al caso de las fórmulas, se reduce al cálculo de los posibles subconjuntos de los símbolos proposicionales presentes en las fórmulas, correspondientes a la unión de los conjuntos de símbolos asociados a cada una de las fórmulas. De esta forma:

    setSymbols : List FormulaLP -> Set.Set PSymb
    setSymbols xs = List.foldr (\x acc -> Set.union acc (symbInProp x)) Set.empty xs

    allSetInterpretations : List FormulaLP -> List Interpretation
    allSetInterpretations xs = Aux.powerset <| Set.toList <| setSymbols xs

De forma que el cálculo de los modelos, contramodelos, consistencia e inconsistencia se reduce a aplicar las definiciones sobre el conjunto de fórmulas:

    isSetModel : List FormulaLP -> Interpretation -> Bool
    isSetModel xs i =  List.all (\x -> valuation x i) xs

    allSetModels : List FormulaLP -> List Interpretation
    allSetModels xs = List.filter (isSetModel xs) (allSetInterpretations xs)

    allSetCounterModels : List FormulaLP -> List Interpretation
    allSetCounterModels xs = List.filter (\x -> not(isSetModel xs x)) <| allSetInterpretations xs

    isConsistent : List FormulaLP -> Bool
    isConsistent xs = List.any (\x -> isSetModel xs x) <| allSetInterpretations xs

    isInconsistent: List FormulaLP -> Bool
    isInconsistent xs = not(isConsistent xs)

$\longrightarrow$ <u>Consecuencia lógica</u>

Dada la definición de conseciencia lógica y teniendo en cuenta la relación entre consecuencia lógica, consistencia y validez (último caso), funcionalmente hemos planteado dos desarrollos alternativos para el concepto de Consecuencia Lógica:

(1) Acudiendo a la propia definición. (2) Acudiendo al tercer punto de la proposición anterior.

    isConsecuence : List FormulaLP -> FormulaLP -> Bool
    -- isConsecuence xs x = List.all (\y -> valuation x y) <| allSetModels xs
    isConsecuence xs x = isInconsistent (xs ++ [Neg x])

NOTA: Se ha dejado la segunda como implementación final.

Veámos un ejemplo, dado el conjunto de fórmulas $U=\{p \rightarrow q,q \rightarrow p \wedge r\}$ y la fórmula $ F = p \rightarrow (p \rightarrow q) \rightarrow r$, veámos si se cumple $U \models F$.

```elm{l context="7"}

import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)
import Bool.Extra exposing (toString)

u1 : FormulaLP
u1 = fromStringToFLP "p IMPLIES q" |> extractReadFLP

u2 : FormulaLP
u2 =  fromStringToFLP "q IMPLIES p AND r" |> extractReadFLP

uSet : LPSet
uSet = [u1, u2]

f : FormulaLP
f = fromStringToFLP "p IMPLIES (p IMPLIES q) IMPLIES r" |> extractReadFLP

-- Ejecutamos toString <| isConsecuence uSet  f
```

^^^elm{m=(toString <| isConsecuence uSet  f) context="7"}^^^

De hecho, acudiendo a la definición podemos ver que, en efecto, todo modelo del conjunto $U$ es también modelo de la fórmula $F$.

```elm{l context="7"}

modelos_U : List Interpretation
modelos_U = allSetModels uSet

modelos_F : List Interpretation
modelos_F = models f

{-Ejecutamos:
    interpretations2MDFormat modelos_U
    interpretations2MDFormat modelos_F
  -}
```
De forma que los modelos de $U$ corresponden a:

^^^elm{m=(interpretations2MDFormat modelos_U) context="7"}^^^

Y los de $F$:

^^^elm{m=(interpretations2MDFormat modelos_F) context="7"}^^^

De forma que, en efecto, todo modelo de $U$ es también modelo de $F$, luego $F$ se sigue de $U$.

### Algoritmos de decisión en LP

Como hemos señalado vamos a presentar de forma somera los algoritmos de decisión en LP, e iremos desarrollando algunos de los algoritmos más importantes a lo largo de los distintos capítulos.

> Dado un conjunto de fórmulas $U$, un **algoritmo de decisión** para $U$ es aquél que dada una fórmula $A \in PROP$, devuelve `SI` cuando $A \in U$ y `NO` cuando $A \not\in U$

Esto da pie a la definición de algunos problemas con un especial interés:

> - $SAT = \{A \in PROP: \, A \textit{ es satisfactible}\}$.
> - $TAUT = \{A \in PROP: \, A \textit{ es tautología}\}$.
> - Fijado $U \subseteq PROP$, la *Teoría de $U$* corresponde a: $\mathcal{T}(U) = \{A \in PROP: \, U \models A\}$.

Precisamente, un algoritmo de decisión para $\mathcal{T}(U)$ proporciona una respuesta al Problema Básico que planteamos al comienzo del capítulo. Por tanto, podemos reducir dicho problema a uno nuevo:
> Obtener un algoritmo que, dado un conjunto finito de fórmulas proposicionales, $U$, y una fórmula, $F$, decida si $U \models F$.

Y este a su vez se reduce a comprobar la satisfactibilidad de una cierta fórmula (o bien la validez de otra), hemos aquí el problema conocido como *Problema $SAT$*.

Notemos que ya hemos visto un algoritmo, el de las Tablas de Verdad, que resuelve, de forma simple, el problema, pero la complejidad de dicho algoritmo es exponencial en el número de símbolos proposicionales, lo que lo hace inabordable para fórmulas de cierta complejidad , incluso computacionalmente.

Hemos de señalar que existen otros algoritmos de decisión del problema $SAT$, algunos de los cuales abordaremos a lo largo de los siguientes capítulos, pero aún no se ha encontrado ninguno capaz de resolver el problema eficientemente (complejidad polinomial), y, de hecho, se duda (fuertemente) de la existencia del mismo. De hecho, determinar la satisfactibilidad de una fórmula proposicional se trata de un problema NP-completo.

1.3 De Proposiciones a Predicados.
Conceptos Básicos de Lógica de Primer Orden
----------------------------------------------------

### Limitaciones de la Lógica Proposicional

Aunque la lógica proposicional posee un semántica sencilla y existen algoritmos de decisión (poco eficientes) para sus problemas básicos, como $SAT$ o la consecuencia lógica, la expresividad de LP es bastante limitada, esto hace que muchos problemas no sean modelables en LP, bien porque requieren un gran número de fórmulas o fórmulas de gran tamaño, o
bien porque no puedan ni siquiera expresarse en este lenguaje. El siguiente ejemplo presenta un razonamiento que es válido, sin embargo no es expresable en LP:

​1. Todo hombre es mortal.
2. Sócrates es hombre.
3. Por tanto, Sócrates es mortal.

¿Cómo expresar el concepto de ser hombre?¿Como expresar quién es Sócrates?, pero aún más ¿Cómo expresar que todos es mortal?. Es aquí precisamente donde comienza el ámbito de la Lógica de PrimerOrden.

### Caracterización de la Lógica de Primer Orden

La Lógica de Primer Orden (LPO) extiende la Lógica Proposicional, ganando capacidad expresiva, que permite abordar cuestiones como:

- Realizar cuantificación sobre los objetos de un dominio, esto es, expresar en qué medida se tiene una propiedad sobre un conjunto de objetos.

- Representar propiedades de los objetos particulares del dominio por medio de predicados y funciones.

- Trabajar con subconjuntos de objetos que pueden venir caracterizados por propiedades que se describen por medio de predicados y funciones.



1.4. Fundamentos de la Lógica de Primer Orden
----------------------------------------------------

De forma análoga a como se ha visto para la lógica proposicional vamos a estudiar los elementos que definen la Lógica de Primer Orden (Sintáxis y Semántica) dejando para capítulos futuros el desarrollo de los Algoritmos de Decisión.

### Sintáxis de la Lógica de Primer Orden

Formalmente,

> La **Lógica de Primer Orden** o **Lógica de Predicados** es un sistema formal diseñado para estudiar los métodos inferenciales en los leguajes de primer orden.

Un **lenguaje de primer orden** corresponde a un lenguaje formal que consta de:

- <u>Símbolos lógicos</u> (comunes a todos los lenguajes): En los que se engloban:

    -   Un conjunto de *Variables:* $V = \{x, x_0, x_1, \ldots, y, y_0, \ldots \}$

    -   *Conectivas lógicas :* $\neg$ (negación), $\wedge$ (conjunción), $\vee$ (disyunción), $\rightarrow$ (implicación), $\leftrightarrow$ (equivalencia).

    -   *Cuantificadores:* $\exists$ (existencial), $\forall$ (universal).

    -   *Símbolos auxiliares:* $`('$ y $`)'$<br><br>

-   <u>Símbolos no lógicos</u> (propios de cada lenguaje): En los que se engloban:

    -   Un conjunto de *Constantes:* $L_{C}= \{a, b, \ldots, a_{0}, a_{1}, \ldots \}$

    -   Un conjunto de *símbolos de función:* $L_{F} = \{f_{0}, f_{1}, \ldots\}$, cada uno con su aridad correspondiente.

    -   Un conjunto de **símbolos de predicado:** $L_P=\{P_{0}, P_{1}, \ldots, Q, Q_0, \ldots\}$, cada uno con su aridad correspondiente.

        Dos notas:

        -   Los símpolos de predicado de aridad 0 actúan como símbolos proposicionales.

        -   El símbolo de igualdad (‘$=$’) no es un predicado común a todos los lenguajes de primer orden, pero si es corriente su aparición. La familia de lenguajes que incluyen este predicado es denominada *Lenguajes de Primer Orden con Igualdad*.

Este aparato permite la construcción de distintas expresiones, que componen las fórmulas de LPO. Vamos a exponer una diferenciación de dichas expresiones, distinguiendo *términos* y *fórmulas*.

#### Términos en LPO

Los términos se identifican con posibles objetos del mundo. Englobando los siguientes elementos:

- <u>Constantes</u> para hablar de objetos específicos.
- <u>Variables</u> para hablar de objetos genéricos.
- <u>Funciones</u> aplicadas a otros términos más pequeños, según su aridad.

Para ejemplificar los conceptos expuestos a lo largo del tema vamos a modelar el mundo romano:
(los superíndices indican la aridad)

$$LR = \{\underbrace{\boldsymbol{César}, \boldsymbol{Marco}}_{constantes}, \underbrace{P^{1}, L^{2}, O^{2}, R^{1}, IA^{2}}_{\textit{símbolos de predicado}}, \underbrace{f^{1}}_{\textit{símbolo de función}} \}$$

tal que, donde, $César$ y $Marco$ son constantes, $P$ y $R$ son predicados unarios que denotan *ser pompeyano* y *ser romano*, respectivamente; $L$, $O$, $IA$ son predicados binarios que denotan *ser leal a*, *odiar a* , *intentar asesinar a*, respectivamente; y $f$ una función unaria que represente el concepto de *padre de*.

De forma que son términos de $LR$:



- *Constantes*: *Marco*, *César*.
- *Variables*: $x$, $y$, $x_1$, ...
- *Funciones*: f(César), f(x), f(f(x)), ...

#### Fórmulas en LPO

Las fórmulas se identifican con afirmaciones sobre los objetos del mundo, permitiendo hablar de la veracidad o falsedad de las afirmaciones. Están formadas a partir de predicados sobre términos, y construcciones lógicas de estos predicados (conjunciones, implicaciones, cuantificaciones, etc.). Veámos esto formalmente.

Las fórmulas pueden corresponder a:

- <u>Átomos o Fórmulas atómicas</u>. Corresponden a las expresiones $p(t_1, t_2, \ldots, t_n)$, tal que $p$ es un símbolo de predicado de aridad $n$ y $t_i$ son términos.

- <u>Fórmulas no atómicas</u>. Corresponden a expresiones formadas a partir de fórmulas atómicas, mediante el empleo de conectivas y/o cuantificadores.

De esta forma, son fórmulas de $L$:

- Toda fórmula atómica.

- Si F y G son fórmulas de de $L$ entonces $\neg F$, $F \wedge G$, $F \vee G$, $F \rightarrow G$, $F \leftrightarrow G$, también son fórmulas de $L$.

- Si x es una variable y F es una fórmula de $L$, entonces $\exists x \, F$ y $\forall x \, F$ son también fórmulas de $L$.

Volviendo al mundo romano, algunas posibles fórmulas del lenguaje $LR$:

- *Átomos*: $P(\boldsymbol{César})$, $L(\boldsymbol{César}, \boldsymbol{Marco})$, $IA(\boldsymbol{Marco}, f(x))$.
- *Fórmulas compuestas*: $\forall x \exists y \, L(x,y)$, $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{César}) \vee O(x, \boldsymbol{César}) \right)$

$\longrightarrow$ <u>Reglas de simplificación de la notación</u>

Para facilitar la lectura y escritura de las fórmulas vamos a tomar varios criterios de notación:

- Se omitirán los paréntesis externos.
- Las prioridades de las conectivas siguen el mismo orden que el expuesto en LP: $\neg, \wedge, \vee, \rightarrow, \leftrightarrow$ (para la última se recomienda mantener los paréntesis).
- Los cuantificadores tienen prioridad sobre las conectivas.

##### Árboles de formación.

Al iguan que en las fórmulas de LP, la definición de las fórmulas en LPO presenta una estructura recursiva:

- *Caso base*. Fórmulas atómicas.
- *Casos recursivos* Aplicación de las conectivas y cuantificadores sobre fórmulas de LPO.

Y de forma análoga a la presentada en LP, se puede plasmar dicha estructura recursiva en un grafo tipo árbol (esencialmente único), de forma que el nodo raíz corresponde a la fórmula completa y las hojas corresponden a las fórmulas atómicas que participan en la fórmula. Al igual que en LP, toda fórmula que aparezca en algún nodo (ya sea un nodo interno o una hoja) diremos que es **subfórmula** de la fórmula original.

Para la fórmula $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{César}) \vee O(x, \boldsymbol{César}) \right)$, se tendría el AF asociado:<br><br>

<center> <img src="images/T1Img4.png" title="Árbol de formación en LPO (ejemplo)."></center><br>


##### Sintaxis de Fórmulas LPO en Logicus

Al igual que hicimos con la lógica LP, vamos a exponer cuál es la sintaxis de las fórmulas utilizando la librería Logicus, que nos permitirá definir fórmulas y aplicar diversos algoritmos sobre las mismas.

Bajo la librería podemos definir las fórmulas de dos formas distintas, o bien acudiendo directamente a los constructores de las fórmulas (largo y engorroso), o bien utilizando el Parser (de forma análoga a la escritura natural de las fórmulas).

$\longrightarrow$ <u>Definición de fórmulas a partir de constructores (Módulo *SintaxSemanticsLPO*)</u>

Antes de introducirnos en el estudio de la sintaxis de fórmulas vamos a presentar la sintaxis y definición de términos. Recordemos que la estuctura de los términos corresponde a una definición recursiva con <u>variables</u> y <u>constantes</u> como *casos base* y <u>funciones</u>.

Aunque la definición en la librería sigue esta idea, se ha decidido modelar las <u>constantes</u> como funciones independientes de variables, de forma que en la librería se tiene que un término es o bien una variable o bien una función.

    type Term = Var String
              | Func String (List Term)

De forma que las constantes corresponderían a objetos con la estructura *Func String [ ]*.

De forma que podemos definir términos de forma sencilla mediante el uso de estos constructores. Volviendo al ejemplo presentado anteriormente, (*Constantes*: *Marco*, *César*; *Variables*: $x$, $y$, $x_1$, ...; *Funciones*: f(César), f(x), f(f(x))):

```elm{l context="8"}

import Modules.SintaxSemanticsLPO exposing (..)

cesar = Func "cesar" []

marco = Func "marco" []

x = Var "x"

x_1 = Var "x_1"

f_cesar = Func "f" [cesar]

f_f_cesar = Func "f" [Func "f" [cesar]]
```

Ahora que ya podemos definir términos en LPO podemos pasar a ver la definición de fórmulas. Si recordamos, las fórmulas están definidas con una estructura recursiva, de forma que las fórmulas corresponden o bien a átomos (*caso base*), o bien a la aplicación de las conectivas y/o cuantificadores sobre otras fórmulas (*caso recursivo*).

Bien, pues la implementación dada en la librería para las fórmulas sigue fielmente dicha definición. De forma que: (definiendo el tipo *Variable* como alias de *Term*)

    type alias Variable = Term

    type FormulaLPO = Pred String (List Term)
                    | Equal Term Term
                    | Neg FormulaLPO
                    | Conj FormulaLPO FormulaLPO
                    | Disj FormulaLPO FormulaLPO
                    | Impl FormulaLPO FormulaLPO
                    | Equi FormulaLPO FormulaLPO
                    | Exists Variable FormulaLPO
                    | Forall Variable FormulaLPO
                    | Insat

De forma que esto nos permite expresar sintácticamente todas las fórmulas en LPO. Para los ejemplos expuestos:

```elm{l context="9"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)


f1 : FormulaLPO
f1 = Pred "P" [Func "cesar" []]

```

^^^elm{m=(toLatexFLPO f1) context="9"}^^^

```elm{l context="9"}

f2 : FormulaLPO
f2 = Pred "L" [Func "cesar" [], Func "marco" []]

```

^^^elm{m=(toLatexFLPO f2) context="9"}^^^


```elm{l context="9"}

f3 : FormulaLPO
f3 = Pred "IA" [Func "cesar" [], Func "f"  [Var "x"]]

```

^^^elm{m=(toLatexFLPO f3) context="9"}^^^

```elm{l context="9"}

f4 : FormulaLPO
f4 = Forall (Var "x") (Exists (Var "y") (Pred "L" [Var "x", Var "y"]))

```

^^^elm{m=(toLatexFLPO f4) context="9"}^^^

```elm{l context="9"}

f5 : FormulaLPO
f5 = Forall (Var "x") (Impl (Pred "R" [Var "x"]) (Disj (Pred "L" [Var "x",Func "cesar" []]) (Pred "O" [Var "x",Func "cesar" []])))

```

^^^elm{m=(toLatexFLPO f5) context="9"}^^^

$\longrightarrow$ <u>Definición de fórmulas LPO con Parser (Módulo *IO_LPO*)</u>

Aunque ya podemos definir todas las fórmulas en LPO, su escritura resulta una tarea muy pesada, para aliviar esa carga se ha desarrollado un Parser que permite la lectura de fórmulas a partir de una cadena de texto en el que las fórmulas se escriben de forma análoga a como se dan en el lenguaje formal de la lógica. Se establecen algunas reglas sintácticas en su uso:

- Las <u>variables</u> se escriben con una letra en minúscula seguidas de caracteres alphanuméricos o el símbolo '_'. Algunos ejemplos: *'x'* , *'x_1'*, *'x1'*, ...

- Las *funciones* se definen siguiendo la notación prefija, según el patrón:<br><br>

    <center><i> [Símbolo de función] [parámetros]</i></center>

    Tal que: <br><br>

    - El *símbolo de función* debe comenzar por el carácter '_', seguido de una serie de caracteres, entre estos se admiten caracteres alfanuméricos y también símbolos, excepto '[', ']', '(', ')', '{', '}', ',', ';'. <br><br>

    - En los *parámetros* se pueden dar 2 casos, o bien la función corresponde a una <u>constante</u> y por tanto no tiene parámetros, con lo cual bastaría escribir el símbolo de función (ejemplos: *'_a'*, *'_PEDRO'*, *'_1'*) o bien es una <u>función</u> (dependiente de, al menos, un término), en tal caso los argumentos se dan en una lista acotada por corchetes ('[', ']') y tras cada argumento ha de ir un ';' (ejemplos: *'_f[x;]'*, *'_g[x;y;]'*, *'_+[x;\_1;\_·[y;\_2;]]'*).

- Los <u>predicados</u> se definen utilizando la notación prefija según el patrón:<br><br>

    <center><i> [símbolo de predicado] [parámetros]</i></center>

    Tal que: <br><br>

    - El *símbolo de predicado* debe comenzar por un carácter en mayúscula o un símbolo (exceptuando '_',  '!', '(', ')', '[', ']', '}', '}' (también se admiten dígitos numéricos pero no se recomienda), seguido de una serie de caracteres, entre estos se admiten caracteres alfanuméricos y también símbolos (exceptuando '(', ')', '[', ']', '}', '}'). Son palabras reservadas (y por tanto no se pueden usar como predicados) *"NOT", "AND", "OR", "IMPLIES", "EQUIV", "EXISTS", "FORALL", "INSAT"* <br><br>

    - En los *parámetros* se pueden dar 2 casos, o bien la función es un <u>predicado proposicional</u> (no tiene parámetros), con lo cual bastaría escribir el símbolo de predicado (ejemplos: *'P'*, *'Q\_1'*) o bien es un <u>predicado n-ario</u> (dependiente de, al menos, un parámetro), en tal caso los argumentos se dan en una lista acotada por corchetes ('[', ']') y tras cada argumento ha de ir un ';' (ejemplos:'P[x;]', '>=[x;y;]', 'MAX[x;\_1;\_·[y;\_2;]]').<br><br>

    Hay una excepción, *predicado de igualdad* (binaria) se utilizará de forma infija separando los términos con el símbolo '=' (ejemplos: 'x=y' , 'x\_4=\_3', '\_f[x;]=\_f[y;]') (El predicado de igualdad es de uso exclusivamente binario).

    <center><i> [término] = [término]</i></center><br><br>

- Los <u>cuantificadores</u> se expresan de forma análoga al lenguaje formal de LPO según el patrón:

    <center><i> [símbolo de cuantificador] [variable] [fórmula]</i></center><br><br>

    Tal que: <br><br>

    - Los *símbolos de cuantificadores* corresponden a:

    <table style="margin-left: auto; margin-right: auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Cuantificador</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Símbolo Logicus</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Existencial (∃)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'EXISTS'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Universal (∀)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'FORALL'</td></tr></tbody></table><br>

    - La *variable* debe ir entre llaves ('{', '}'), respetando las reglas establecidas para la definición de variables.<br><br>

    - La *fórmula* escrita respetando los criterios dados para la escritura de las fórmulas.<br><br>


 - Las conectivas se usarán de forma infija (salvo para la *negación*),  utilizando los siguientes símbolos, mantiéndose la prioridad de las conectivas definida (en el orden de prioridad descendente expuesto en la tabla).

<table style="margin-left: auto; margin-right: auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Conectiva</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Símbolo Logicus</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Negación (¬)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'NOT'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Conjunción (∧)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'AND'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Disyunción (∨)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'OR'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Implicación (🡒)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'IMPLIES'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Equivalencia (🡘)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'EQUIV'</td></tr></tbody></table><br>

- Los paréntesis se utilizan de igual forma en que se han definido en el lenguaje formal de la lógica proposicional, con los símbolos '(' y ')'. No son necesarios los paréntesis externos de las fórmulas.<br><br>

- En caso de uso repetido de una misma conectiva y/o cuantificador, se realizará asociación por la derecha.<br><br>

Al igual que ocurría en el Parser de LP una vez leída la fórmula con la función *fromStringToFLPO* es necesario extraerla utilizando la función *extractReadFLPO*.

Vamos a mostrar algunos ejemplos de definición de las fórmulas utilizando el Parser de LPO.

- Ejemplo 1: $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{César}) \vee O(x, \boldsymbol{César}) \right)$

```elm{l context="10"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)

f1 : FormulaLPO
f1 = fromStringToFLPO "FORALL{x}(R[x;] IMPLIES (L[x;_cesar;] OR O[x; _cesar;]))" |> extractReadFLPO

-- Ejecutamos (toLatexFLPO f1) para mostrar la fórmula
```

Que corresponde a:

^^^elm{m=(toLatexFLPO f1) context="10"}^^^

- Ejemplo 2 (tomando el lenguaje matemático), definamos la propiedad biyectiva. Para expresarla consideremos el siguiente lenguaje: $L= \{O, I, f\}$, tal que:

    - $O$ es un predicado de aridad 1 que expresa si el objeto pertenece al conjunto origen.

    - $I$ es un predicado de aridad 1 que expresa si el objeto pertenece al conjunto imagen.

    - $f$ es una función que dado un elemento del conjunto origen obtiene el correspondiente elemento del conjunto imagen y dado un elemento del conjunto imagen obtiene el correspondiente del conjunto origen.

    La propiedad biyectiva se formula como: <br><br>

    <center><i> Una relación es biyectiva si para todo elemento del conjunto origen existe un único elemento del conjunto imagen con el que está relacionado y todo elemento del conjunto imagen está relacionado con algún elemento del origen</i></center><br>

    Esto es: $$ \forall x,y \in O \, (x \neq y \rightarrow f(x) \neq f(y)) \wedge \forall x \in I \, \exists y \in O \, (f(x)=y)$$<br>

    ```elm{l context="10"}

    biyectiva : FormulaLPO
    biyectiva = fromStringToFLPO
                    "FORALL{x} FORALL{y} (O[x;] AND O[y;] AND NOT (x=y) IMPLIES NOT (_f[x;]=_f[y;])) AND FORALL{x}(I[x;] IMPLIES EXISTS{y}(O[y;] AND _f[y;]=x))"
                |> extractReadFLPO

    -- Ejecutamos (toLatexFLPO biyectiva) para mostrar la fórmula
    ```

    ^^^elm{m=(toLatexFLPO biyectiva) context="10"}^^^

    $\longrightarrow$ <u>Árboles de formación LPO en Logicus</u>

    La librería también permite la representación de los árboles de formación LPO. La función *formtree* (del módulo *IO_LPO*) muestra la representación del árbol de formación en formato texto DOT, de forma análoga a como lo hacía en el caso de LP

    Por ejemplo para la fórmula $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{César}) \vee O(x, \boldsymbol{César}) \right)$:

    ```elm {l context="11"}
    import Modules.IO_LPO exposing (..)
    import Modules.SintaxSemanticsLPO exposing (..)
    import Modules.AuxForLitvis exposing (showGraphViz)

    f : FormulaLPO
    f = fromStringToFLPO "FORALL{x}(R[x;] IMPLIES (L[x;_cesar;] OR O[x; _cesar;]))" |> extractReadFLPO

    ft_f : String
    ft_f = formTree f
    ```
    De forma que se obtiene:

    ^^^elm {m=(showGraphViz "G2" ft_f) context="11"}^^^

##### Alcance de los cuantificadores, FBF, clausura de fórmulas y renombramiento de variables.

Hemos estudiado la sintáxis formal de las fórmulas, pero aún faltan algunos detalles por completar para establecer qué fórmulas están bien formadas y cuáles no. Un tema importante es el tratamiento de la cuantificación, esto es, a qué aparciones u ocurrencias (denominadas estancias) de una variable afecta un cuantificador.

> Una ocurrencia de una variable está afectada por un cuantificador (se dice que es una **estancia u ocurrencia ligada**) si hay un cuantificador sobre dicha variable actuándo sobre la (sub)fórmula que la contiene. En otro caso diremos que se trata de una **estancia u ocurrencia libre**

Para comprenderlo mejor vamos a explicar un ejemplo:

$$ \underbrace{\forall x}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {1}}}} \, \boxed{( P(\underbrace{x}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{x ligada}\end{array}}, \underbrace{y}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{y libre}\end{array}}) \rightarrow  \underbrace{\exists y}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {2}}}} \, \boxed{R(\underbrace{y}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{y ligada}\end{array}}, \underbrace{x}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{x ligada}\end{array}})}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {2}}}} )}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {1}}}}$$

En la fórmula podemos apreciar que el cuantificador, $\forall x$, afecta a toda la fórmula siguiente, por tanto todas las ocurrencias de $x$ que aparezcan en la fórmula serán ocurrencias ligadas. Sin embargo, $P(x,y)$ no está afectado por ningún otro cuantificador, por tanto, la ocurrencia de $y$ en $P(x,y)$ es libre. Por otra parte, $R(x,y)$ sí está afectado por el cuantificador $\exists y$,  por tanto tanto la ocurrencia de $x$ como la de $y$ en $R(y, x)$ son ligadas.

De forma similar se definen las variables *libres* y *ligadas* como:

> Una variable $x$ se dice **varible libre** en una fórmula $F$ si existe alguna ocurrencia libre de $x$ en $F$. <br>
Una variable $x$ se dice **varible ligada** en una fórmula $F$ si existe alguna ocurrencia ligada de $x$ en $F$.

De forma que en una fórmula una variable puede ser al mismo tiempo *variable libre* y *variable ligada*.

Por ejemplo, en la fórmula anterior $x$ es una variable *exclusivamente cerrada* (todas sus ocurrencias son ligadas), sin embargo $y$ es una variable *libre* y *ligada* (hay una ocurrencia libre y otra ligada).

En base a los conceptos anteriores se definen los conceptos:

> Se dice que un **término** es **cerrado** si no contiene ninguna variable.

Por ejemplo: $César$, $f(Marco)$, $f(f(César))$; son términos cerrados en el lenguaje $LR$.

> Se dice que una **fórmula** es **cerrada** si no contiene variables libres, o equivalentemente si todas las estancias de todas las variables son ligadas.

Por ejemplo las fórmulas $\forall x (L(x, César) \vee O(César, x))$, $\forall x L(x, César) \rightarrow \neg \exists y O(César, y)$ son una *fórmulas cerradas*, mientras que las fórmulas $\forall x L(x, César) \vee O(César, x)$ , $\forall x L(x, César) \rightarrow \neg \exists y IA(y, x)$ no lo son.

> Se dice que una **fórmula** es **abierta** si no contiene cuantificadores, esto es todas las variables son, exclusivamente, *variables libres*.

Por ejemplo son fórmulas abiertas $P(x)$, $R(César)$, $P(x) \leftrightarrow \neg IA(f(x), Marco)$.

Incidiremos más en este aspecto cuando veámos la semántica en LPO.

$\longrightarrow$ <u>Fórmulas bien formadas y renombramiento de variables</u>

Aunque las fórmulas estén bien escritas sintácticamente, incluso aunque sean cerradas, es posible que su interpretación sea ambigua, esta ambigüedad suele venir dada por un mal uso de los cuantificadores y las variables, por ejemplo tengamos la fórmula:

$$\forall z\,\forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, \boxed{z}\right) \wedge P\left(x, y\right) \right) \right) \right)$$

La ocurrencia de $z$ señalada, es claramente ligada, pero ¿a qué cuantificador?

> Diremos que una **fórmula** está **bien formada** (*FBF* o *WFF*) si es correcta sintácticamente y no contiene dos cuantificadores anidados actuando sobre la misma variable.

Claramente, la **fórmula** presentada no está **bien formada** y hay una ambigüedad en la interpretación de la fórmula, para resolver dicha ambigüedad vamos a adoptar el siguiente criterio:

"Una ocurencia está ligada (si es que lo está) al cuantificador de nivel superior más cercano en el árbol de formación"

De forma que la ocurrencia anterior la tomaremos ligada al existencial. Nótese que en el árbol de formación es el cuantificador referido a $z$ de orden superior más cercano:

<center> <img src="images/T1Img6.png" title="Árbol formación (ejemplo)"></center><br>

Además de adoptar un criterio, podemos, mejor, realizar un renombramiento de las variables, manteniendo el sentido original de las fórmulas, de forma que la fórmula anterior podríamos renombrarla mejor como:
$$\forall z_1\,\forall x_1\,\exists y_1\,\left( P\left(x_1, y_1\right)\rightarrow \left( P\left(x_1, z_1\right) \vee \exists z_2\,\left( P\left(y_1, z_2\right) \wedge P\left(x_1, y_1\right) \right) \right) \right)$$

No es el único caso en el que es necesario renombrar las variables, por ejemplo, tengamos la fórmula:

$$\forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, \raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {$z$}}}\right) \vee \exists z\,\left( P\left(y, \boxed{z}\right) \wedge P\left(x, y\right) \right) \right) \right)$$

La primera ocurrencia de $z$ señalada es libre y la segunda es ligada, claramente el mismo símbolo de variable representa objetos distintos, lo que produce una cierta ambigüedad en la fórmula. Sin embargo, podemos renombrar la fórmula como:
$$\forall x_1\,\exists y_1\,\left( P\left(x_1, y_1\right)\rightarrow \left( P\left(x_1, z\right) \vee \exists z_1\,\left( P\left(y_1, z_1\right) \wedge P\left(x_1, y_1\right) \right) \right) \right)$$

De forma que desaparece toda posible ambigüedad.

Nótese que para renombrar se ha escogido el siguiente criterio : *Se renombrarán todas las ocurrencias ligadas de cada variable añadiendo el subíndice correspondiente según el orden y cardinalidad de aparición del cuantificador (sobre dicha variable) al que está ligada dicha ocurrencia (tomando el orden según el recorrido en profundidad del $AF$ de la fórmula)*

$\longrightarrow$ <u>Clausura de las fórmulas LPO.</u>

Los algoritmos de decisión que vamos a estudiar trabajan únicamente sobre fórmulas cerradas, por lo que hemos de *clausurar* todas aquellas fórmulas que no sean cerradas, cuantificando las variables libres de la fórmula (aplicando un renombramiento sobre aquellas variables que sean, simultáneamente, libres y ligadas).

Se admiten dos tipos de clausura para las fórmulas:

- <u>Clausura universal</u> se trata de cerrar la fórmula a base de cuantificar universalmente (por la izquierda) las variables libres de las fórmulas. Si $v_1, \ldots, v_n$ corresponden a las variables libres de una fórmula $F$, la clausura universal de la fórmula corresponde a la fórmula $\forall v_1 \ldots \forall v_n \, F$

- <u>Clausura existencial</u> se trata de cerrar la fórmula a base de cuantificar existencialmente (por la izquierda) las variables libres de las fórmulas. Si $v_1, \ldots, v_n$ corresponden a las variables libres de una fórmula $F$, la clausura universal de la fórmula corresponde a la fórmula $\exists v_1 \ldots \exists v_n \, F$

Veremos algunas cuestiones más sobre este aspecto cuando veamos la *Semántica en LPO*.

$\longrightarrow$ <u>Fórmulas abiertas/cerradas, FBF, renombramiento y clausura de fórmulas en Logicus</u>

La librería Logicus permite, en el módulo *SintaxSemanticsLPO* trabajar con los conceptos que hemos estado viendo.

$-$ *Variables libres y ligadas*

Recordemos que una variable es libre/ligada si existe alguna ocurrencia de dicha variable que sea libre/ligada. En la librería Logicus las funciones *varIsFreeInFLPO* y *varIsLinkedInFLPO* resuelven este aspecto:

    varIsFreeInFLPO : Variable -> FormulaLPO -> Bool
    varIsFreeInFLPO v f=
        case f of
            Pred _ terms -> List.member v (varsInListTerm terms)
            Equal t1 t2 -> List.member v (varsInListTerm [t1, t2])
            Neg p -> varIsFreeInFLPO v p
            Conj p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Disj p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Impl p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Equi p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Exists var p -> not(var == v) && varIsFreeInFLPO v p
            Forall var p -> not(var == v) && varIsFreeInFLPO v p
            Insat -> True

    varIsLinkedInFLPO : Variable -> FormulaLPO -> Bool
    varIsLinkedInFLPO v f=
        case f of
            Pred _ _ -> False
            Equal _ _ -> False
            Neg p -> varIsLinkedInFLPO v p
            Conj p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Disj p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Impl p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Equi p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Exists var p -> (var == v && List.member v (varsInFormula p)) || varIsLinkedInFLPO v p
            Forall var p -> (var == v && List.member v (varsInFormula p)) || varIsLinkedInFLPO v p
            Insat -> False

De forma que podemos preguntar, por ejemplo si las variables $x$, $y$, $z$ son libres y/o ligadas en $$F: \exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la fórmula

```elm {l context="12"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f = fromStringToFLPO "EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{z} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO
```
2. Preguntamos si cada una de las variables son libres/ligadas:

```elm {l context="12"}
isxF = varIsFreeInFLPO (Var "x") f
isxL = varIsLinkedInFLPO (Var "x") f
```
^^^elm {m=("Es $x$ libre? " ++ (toString isxF) ++ "<br>Es $x$ ligada? " ++ (toString isxL) ) context="12"}^^^

```elm {l context="12"}
isyF = varIsFreeInFLPO (Var "y") f
isyL = varIsLinkedInFLPO (Var "y") f
```
^^^elm {m=("Es $y$ libre? " ++ (toString isyF) ++ "<br>Es $y$ ligada? " ++ (toString isyL) ) context="12"}^^^

```elm {l context="12"}
iszF = varIsFreeInFLPO (Var "z") f
iszL = varIsLinkedInFLPO (Var "z") f
```
^^^elm {m=("Es $z$ libre? " ++ (toString iszF) ++ "<br>Es $z$ ligada? " ++ (toString iszL) ) context="12"}^^^


$-$ *Fórmulas abiertas y cerradas*

Recordemos que una fórmula es abierta si todas sus variables son exclusivamente abiertas, o equivalentemente si no contiene cuantificadores. Y una fórmula es cerrada si todas sus variables son exclusivamente cerradas. En la librería Logicus las funciones *isOpenFLPO* y *isClosedFLPO* resuelven este aspecto:

    isOpenFLPO : FormulaLPO -> Bool
    isOpenFLPO f =
    case f of
        Pred _ _ -> True
        Equal _ _ -> True
        Neg p -> isOpenFLPO p
        Conj p q -> isOpenFLPO p && isOpenFLPO q
        Disj p q -> isOpenFLPO p && isOpenFLPO q
        Impl p q -> isOpenFLPO p && isOpenFLPO q
        Equi p q -> isOpenFLPO p && isOpenFLPO q
        Exists _ _ -> False
        Forall _ _ -> False
        Insat -> True

    isClosedFLPO : FormulaLPO -> Bool
    isClosedFLPO f = List.all (\v -> varIsLinkedInFLPO v f) (varsInFormula f)

De forma que podemos preguntar, por ejemplo, si las fórmulas $F$, $G$ y $H$ son abiertas, cerradas o ninguna de las dos:

 $$ F: L(x, César) \vee O(César, y)$$ $$G: \forall x \, L(x, César) \vee \exists y \, O(César, y)$$ $$H: \forall x \, L(x, César) \vee O(César, y)$$

 1. Definimos las fórmulas

 ```elm {l context="13"}

 import Modules.SintaxSemanticsLPO exposing (..)
 import Modules.IO_LPO exposing (..)
 import Bool.Extra exposing (toString)

 f : FormulaLPO
 f =  fromStringToFLPO "L[x;_César;] OR O[_César; y;]" |> extractReadFLPO

 g : FormulaLPO
 g =  fromStringToFLPO "FORALL{x} L[x;_César;] OR EXISTS{y} O[_César; y;]" |> extractReadFLPO

 h : FormulaLPO
 h =  fromStringToFLPO "FORALL{x} L[x;_César;] OR O[_César; y;]" |> extractReadFLPO

 ```

 2. Preguntamos si cada una de las fórmulas son abiertas/cerradas:

 ```elm {l context="13"}
 isOF = isOpenFLPO f
 isCF = isClosedFLPO f
 ```
 ^^^elm {m=("Es $F$ abierta? " ++ (toString isOF) ++ "<br>Es $F$ cerrada? " ++ (toString isCF) ) context="13"}^^^

 ```elm {l context="13"}
 isOG = isOpenFLPO g
 isCG = isClosedFLPO g
 ```
 ^^^elm {m=("Es $G$ abierta? " ++ (toString isOG) ++ "<br>Es $G$ cerrada? " ++ (toString isCG) ) context="13"}^^^

 ```elm {l context="13"}
 isOH = isOpenFLPO h
 isCH = isClosedFLPO h
 ```
 ^^^elm {m=("Es $H$ abierta? " ++ (toString isOH) ++ "<br>Es $H$ cerrada? " ++ (toString isCH) ) context="13"}^^^

$-$ *Fórmulas bien formadas  y renombramiento de variables.*

Recordemos que consideramos una fórmula bien formada a aquella que es sintácticamente correcta y que no contiene cuantificadores anidados sobre una misma variable. La función *checkWFF* permite comprobar si una fórmula está bien formada o no:

    checkWFF : FormulaLPO -> Bool
    checkWFF x = checkWFFAux x []

    checkWFFAux : FormulaLPO -> List Variable -> Bool
    checkWFFAux x ls =
        case x of
            Pred _ _ -> True
            Equal _ _-> True
            Neg p -> checkWFFAux p ls
            Conj p q -> checkWFFAux p ls && checkWFFAux q ls
            Disj p q -> checkWFFAux p ls && checkWFFAux q ls
            Impl p q -> checkWFFAux p ls && checkWFFAux q ls
            Equi p q -> checkWFFAux p ls && checkWFFAux q ls
            Exists v p -> not(List.member v ls) && checkWFFAux p ls && checkWFFAux p (ls ++ [v])
            Forall v p -> not(List.member v ls) && checkWFFAux p ls && checkWFFAux p (ls ++ [v])
            Insat -> True

Recordemos el criterio que establecimos en el renombramiento de variables: *Se renombrarán todas las ocurrencias ligadas de cada variable añadiendo el subíndice correspondiente según el orden y cardinalidad de aparición del cuantificador (sobre dicha variable) al que está ligada dicha ocurrencia (tomando el orden según el recorrido en profundidad del $AF$ de la fórmula)*

En la librería, la función *renameVars* que permite renombrar las variables de una fórmula siguiendo este mismo criterio:

    renameVars : FormulaLPO -> FormulaLPO
    renameVars f = Tuple.first <| renameVarsAux f  Dict.empty

    renameVarsAux : FormulaLPO -> Dict String Int -> (FormulaLPO, Dict String Int)
    renameVarsAux f vars =
        let varsSub = Dict.map (\ k v ->  Var (k ++ "_" ++ String.fromInt v)) vars in
            case f of
                Pred n terms ->  (Pred n <| List.map (\ t -> applySubsToTerm varsSub t) terms, vars)
                Equal t1 t2 -> (Equal (applySubsToTerm varsSub t1) (applySubsToTerm varsSub t2), vars)
                Neg p ->  
                    let
                        (f1, d1) = renameVarsAux p vars
                    in
                        (Neg f1 , d1)
                Conj p q ->
                    let
                        (f1, d1) = renameVarsAux p vars
                    in
                        let
                            (f2,d2) = renameVarsAux q d1
                        in
                            (Conj f1 f2, d2)
                Disj p q ->
                    let
                        (f1, d1) = renameVarsAux p vars
                    in
                        let
                            (f2,d2) = renameVarsAux q d1
                        in
                            (Disj f1 f2, d2)
                Impl p q ->
                    let
                        (f1, d1) = renameVarsAux p vars
                    in
                        let
                            (f2,d2) = renameVarsAux q d1
                        in
                            (Impl f1 f2, d2)
                Equi p q ->
                    let
                        (f1, d1) = renameVarsAux p vars
                    in
                        let
                            (f2,d2) = renameVarsAux q d1
                        in
                            (Equi f1 f2, d2)
                Exists v p ->
                    let
                        vSymb = getVarSymb v
                    in
                        let
                            vNewIndex = (Maybe.withDefault 0 <| Dict.get vSymb vars) + 1
                        in
                            let
                                newVars = Dict.insert vSymb vNewIndex vars
                            in
                                let
                                    (f1, d1) = renameVarsAux p newVars
                                in
                                    (Exists (Var (vSymb ++ "_" ++ String.fromInt vNewIndex)) f1, d1)
                Forall v p ->
                    let
                        vSymb = getVarSymb v
                    in
                        let
                            vNewIndex = (Maybe.withDefault 0 <| Dict.get vSymb vars) + 1
                        in
                            let
                                newVars = Dict.insert vSymb vNewIndex vars
                            in
                                let
                                    (f1, d1) = renameVarsAux p newVars
                                in
                                    (Forall (Var (vSymb ++ "_" ++ String.fromInt vNewIndex)) f1, d1)
                Insat -> (Insat, vars)

*NOTA: La función 'applySubsToTerm' la veremos cuando estudiemos las sustituciones (en el siguiente apartado)*.

De forma que podemos aplicar las funciones anteriores al siguiente ejemplo, tal que : $$F: \forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists y\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la fórmula:

```elm {l context="14"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f =  fromStringToFLPO "FORALL{x} EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{y} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO

```

2. Veámos si está bien formada:

```elm {l context="14"}
isWFF_F = checkWFF f
```

^^^elm {m=("Está $F$ bien formada? " ++ (toString isWFF_F) ) context="14"}^^^

3. Aplicamos el renombramiento de variables:

```elm {l context="14"}
f2 = renameVars f
```

^^^elm {m=((toLatexFLPO f2)) context="14"}^^^

4. Comprobemos si $F_2$ está bien formada:

```elm {l context="14"}
isWFF_F2 = checkWFF f2
```

^^^elm {m=("Está $F$ bien formada? " ++ (toString isWFF_F2) ) context="14"}^^^

$-$ *Clausura de las fórmulas*

Como ya hemos comentado los métodos que vamos a estudiar se basan en el trato de fórmulas cerradas, por lo que cuando las fórmulas no lo son, es necesario clausurarlas universal o existencialmente. La librería Logicus implementa ambos métodos de clausura en las funciones *universalClausureFLPO* y *existencialClausureFLPO*.

    universalClausureFLPO : FormulaLPO -> FormulaLPO
    universalClausureFLPO f = renameVars <| universalClausureFLPOAux f (List.filter (\ v -> varIsFreeInFLPO v f) <| varsInFormula f)

    universalClausureFLPOAux : FormulaLPO -> List Variable -> FormulaLPO
    universalClausureFLPOAux f ls =
        case ls of
            [] -> f
            x::xs -> universalClausureFLPOAux (Forall x f) xs

    existencialClausureFLPO : FormulaLPO -> FormulaLPO
    existencialClausureFLPO f = renameVars <| existencialClausureFLPOAux f (List.filter (\ v -> varIsFreeInFLPO v f) <| varsInFormula f)

    existencialClausureFLPOAux : FormulaLPO -> List Variable -> FormulaLPO
    existencialClausureFLPOAux f ls =
        case ls of
            [] -> f
            x::xs -> existencialClausureFLPOAux (Exists x f) xs

De forma que, si tenemos la fórmula: $$F: \exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la función

```elm {l context="15"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f =  fromStringToFLPO "EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{z} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO

```

2. La clausura universal de la fórmula correspondería a:

```elm {l context="15"}
f2 = universalClausureFLPO f
```

^^^elm {m=((toLatexFLPO f2)) context="15"}^^^

2. La clausura existencial de la fórmula correspondería a:

```elm {l context="15"}
f3 = existencialClausureFLPO f
```

^^^elm {m=((toLatexFLPO f3)) context="15"}^^^

#### Sustituciones en LPO

> Una sustitución (finita) o simplemente **sustitución**, **$\theta$** corresponde a una función que asigna a un conjunto finito de variables un conjunto finito de términos  $\theta(x_i)=t_i \, (i=1,\ldots, n)$. Se denomina *dominio* de la función al conjunto de variables que no permanecen invariantes ante la sustitución, esto es, $dom(\theta) = \{x_i / \theta(x_i) \neq x_i\}$.
>
> Para denotar una sustitución, lo hacemos por $\theta=\{x_1/t_1, \ldots, x_n/t_n\}$ o también $\theta=\{(x_1,t_1), \ldots, (x_n,t_n)\}$.

##### Aplicación de sustituciones a términos.

La aplicación de una sustitución a un término consiste en intercambiar las variables que participan en dicho término según la correspondencia que establece la sustitución y se denota por $\theta(t)$ o también $t\{x_1/t_1, \ldots, x_n/t_n\}$. Formalmente: $$\theta(t) = \left\lbrace \begin{array}{lll} \theta(x_i) & si \, t=x_i & [t \textit{ es una variable}]\\ f(\theta(t_1), \ldots, \theta(t_m)) & si \, t=f(t_1, \ldots, t_m) & [t \textit{ es una función de aridad } m ]\\  \end{array}\right.$$

Por ejemplo, tengamos la sustitución $\theta = \{x/(x+y), z/\boldsymbol{0}, u/\boldsymbol{1}\}$ y el término $t=(x+y)+z$, de esta forma tendríamos $\theta(t)=((x+y) + y) + \boldsymbol{0}$.

Nótese el carácter simultáneo de la susutitución, esto es, la sustitución de todos las variables se realiza simultáneamente de forma que **no** se tiene  $\{x_i/x_j, x_j/t_j\} \equiv \{x_i/t_j, x_j/t_j\}$. Por ejemplo, tengamos el término del ejemplo anterior y la sustitución $\theta_2 = \{x/(x+y), y/\boldsymbol{0}\}$, entonces: $$((x+y)+z)\{x/(x+y), y/\boldsymbol{0}\} \neq ((x+\boldsymbol{0})+\boldsymbol{0})+z$$ $$((x+y)+z)\{x/(x+y), y/\boldsymbol{0}\} = ((x+y)+\boldsymbol{0})+z$$

##### Aplicación de sustituciones a fórmulas.
La aplicación de una sustitución a un término consiste en intercambiar todas las ocurrencias **libres** de las variables del dominio de la sustitución en $F$ por los términos que les corresponden en la sustitución. Se denota por $\theta(F)$ o también $F\{x_1/t_1, \ldots, x_n/t_n\}$ de forma que:

$$\theta(F) \equiv \left\lbrace \begin{array}{ll} P(\theta(t_1), \ldots, \theta(t_n)) & si \, F\equiv P(t_1, \ldots, t_n)\\ \neg \theta(G) & si \, F \equiv \neg G \\ \theta(G) \wedge \theta(H) & si \, F \equiv G \wedge H \\ \theta(G) \vee \theta(H) & si \, F \equiv G \vee H \\ \theta(G) \rightarrow \theta(H) & si \, F \equiv G \rightarrow H \\ \theta(G) \leftrightarrow \theta(H) & si \, F \equiv G \leftrightarrow H \\ \exists x \, G\{x_i/t_i : x_i \in dom(\theta) \wedge x_i \neq x\} & si \, F \equiv \exists x  \, G \\ \forall x \, G\{x_i/t_i : x_i \in dom(\theta) \wedge x_i \neq x\} & si \, F \equiv \forall x  \, G \\ \end{array}\right.$$

 $\longrightarrow$ <u>Sustituciones admisibles</u>

 No toda sustitución es admisible para una fórmula, por ejemplo, téngase la fórmula $F \equiv \exists x \, \neg(x=y)$ y téngase la sustitución $\theta = \{y/x\}$, entonces $\theta(F) = \exists x \neg (x=x)$. Claramente el sentido de la fórmula ha cambiado, mientras que en la primera fórmula se establece que debe haber, al menos, dos objetos distintos en la segunda se tiene que existe al menos un objeto que es distinto de sí mismo (que es sencillamente falso.)

 De esta forma:

 > Una variable, $x_i \in dom(\theta)$, de una fórmula, $F$, es sustituible por el término correspondiente, $t_i$, si y sólo si la aplicación de la sustitución, $\theta(F)$ no produce nuevas ocurrencias ligadas.

 Formalmente, una variable $x_i$ de $F$ es sustituible por $t_i$ si se da alguna de las siguientes condiciones:

 1. $F$ es atómica.
 2. $F  \equiv \neg G$ y $x_i$ es sustituible por $t_i$ en $G$
 3. $F  \equiv G \left( \wedge | \vee | \rightarrow | \leftrightarrow \right) H$ y $x_i$ es sustituible por $t_i$ en $G$ y en $H$.
 4. $F \equiv \exists x G$ tal que o bien $(x=x_i)$, o bien $(x \neq x_i) \wedge (x \textit{ no ocurre en } t_i) \wedge (x_i \textit{ es sustituible en G})$.
 5. $F \equiv \forall x G$ tal que o bien $(x=x_i)$, o bien $(x \neq x_i) \wedge (x \textit{ no ocurre en } t_i) \wedge (x_i \textit{ es sustituible en G})$.

 De ahora en adelante, cuando escribamos $F\{x/t\}$ supondremos que $x$ es sustituible por $t$ en $F$.

 [*NOTA:* Si dada una fórmula $F(x_1, \ldots, x_n)$, el orden de las variables está claro podemos abreviar $F\{x_1/t_1, \ldots, x_n/t_n\}$ por $F(t_1, \ldots, t_n)$]

 $\longrightarrow$ <u>Sustituciones en Logicus</u>

Según lo estudiado, las sustituciones establecen una correspondencia entre dos elementos, incluso notadas como un conjunto de pares variable-término. Esto es directamente expresable en el *Elm* como *List Variable Term*, incluso si tomamos únicamente las *Strings* de las variables podríamos expresarlo como *List String Term* o mejor como *Dict String Term* (que no permite elementos repetidos en la clave (*String*)):

    type alias Substitution = Dict String Term

De forma que podemos definir una sustitución a través de la función *Dict.fromList*. Por ejemplo, definamos la sustitución $\theta = \{x/(x+y), z/\boldsymbol{0}, u/z\}$

```elm {l context="16"}
import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Dict exposing (..)

theta : Substitution
theta =  Dict.fromList [("x", Func "+" [Var "x", Var "y"]), ("z", Func "0" []), ("u", Var "z")]

```
Aunque no resulta demasiado engorrosa esta definición de las sustituciones se ha provisto un parser en la función *fromStringToSubstitutionLPO* para poder definir más cómodamente las sustituciones siguiendo la notación según el patrón:
<center><i>{[variable] / [término], [variable] / [término], ..., [variable] / [término]}</i></center>

Tal que:

- Se nota como una secuencia escrita entre llaves y separada por comas.
- Los elementos de la secuencia corresponden a pares variable término, separados por ' / ', de forma que la variable ha de seguir los criterios dados, anteriormente, para la sintáxis de variables y los términos, análogamente, la sintáxis dada para la definición de términos.

Así la sustitución anterior se puede dar como:

```elm {l context="16"}

theta2 : Substitution
theta2 =  fromStringToSubstitutionLPO "{x/_+[x;y;], z/_0 , u/z}" |> extractReadSubstitutionLPO

```

^^^elm {m=(Debug.toString(theta2)) context="16"}^^^

*(NOTA: Recuérdese que las constantes se definiían como funciones sin argumentos, esto seguidas de un espacio.)*

$-$ *Aplicación de sustituciones a funciones*

La librería Logicus provee la función *applySubsToFormula* que permite aplicar una sustitución a una fórmula siguiendo los criterios estudiados anteriormente. Dada la definición recursiva de sustitución y término la implementación es directamente la aplicación de esa definición, tanto para los términos como para las fórmulas.

    applySubsToVar : Substitution -> Variable -> Term
    applySubsToVar s x = Maybe.withDefault x <| Dict.get (getVarSymb x) s

    applySubsToTerm : Substitution -> Term -> Term
    applySubsToTerm s t=
        case t of
            Var _ -> applySubsToVar s t
            Func sf ts -> Func sf (List.map (\term -> applySubsToTerm s term) ts)

    applySubsToFormula : Substitution -> FormulaLPO -> FormulaLPO
    applySubsToFormula s f =
        case f of
            Pred n ts ->  Pred n <| List.map (\t -> applySubsToTerm s t) ts
            Equal t1 t2 -> Equal (applySubsToTerm s t1)  (applySubsToTerm s t2)
            Neg p ->  Neg <| applySubsToFormula s p
            Conj p q -> Conj (applySubsToFormula s p) (applySubsToFormula s q)
            Disj p q -> Disj (applySubsToFormula s p) (applySubsySubsToFormula : SubstitToFormula s q)
            Impl p q -> Impl (applySubsToFormula s p) (applySubsToFormula s q)
            Equi p q -> Equi (applySubsToFormula s p) (applySubsToFormula s q)
            Exists v p ->
                let
                    s2 = Dict.filter (\ k _ -> k /=  getVarSymb v) s
                in
                    Exists v (applySubsToFormula s2 p)
            Forall v p ->  
                let
                    s2 = Dict.filter (\ k _ -> k /=  getVarSymb v) s
                in
                    Forall v (applySubsToFormula s2 p)
            Insat -> Insat

De forma que, por ejemplo, para aplicar la sustitución  $\theta = \{x/(x+y), y/\boldsymbol{0}, u/\boldsymbol{1}\}$ a la fórmula $F \equiv Z(x) \wedge Z(y) \rightarrow \exists z \, ((x·y)=z \wedge Z(z))$ (*el producto de números enteros es interno*).

```elm {l context="17"}
import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Dict exposing (..)

f : FormulaLPO
f = fromStringToFLPO "Z[x;] AND Z[y;] IMPLIES EXISTS{z} ((_·[x;y;]=z) AND Z[z;])" |> extractReadFLPO

theta : Substitution
theta =  fromStringToSubstitutionLPO "{x/_+[x;y;], y/_0 , z/_0}" |> extractReadSubstitutionLPO

f2 = applySubsToFormula theta f
```
^^^elm {m=(toLatexFLPO f2) context="17"}^^^

### Semántica de la Lógica de Primer Orden

Vista la forma en la que se escriben y se leen las fórmulas en la Lógica de Primer, el objetivo de la semántica es dotar de significado a los términos y fórmulas de un Lenguaje de Primer Orden. Para ello vamos a ver los elementos que conforman la semántica:

> Sea $L$ un lenguaje de primer orden. Una **$L$–estructura** (o $interpretación$) corresponde a un par $\mathcal{M}= (M, I)$ donde $M$ es un conjunto no vacío llamado **universo** (o dominio) de la $L$-estructura e $I$ es una aplicación tal que:
>1. Aporta una interpretación para cada constante, dicha interpretación se denota por $c^{\mathcal{M}}$, de forma que $\forall c \in L: \, c^\mathcal{M} \in M$. Esto es, a cada constante le asigna uno y sólo uno de los elementos del universo.
>2. Aporta una interpretación para cada uno de los símbolos de función en $L$, tal que si $f$ corresponde a un símbolo de función $n$-aria ($n>0$): $f^{\mathcal{M}} : M^{n} \longrightarrow M$
>3. Aporta una interpretación booleana para cada uno de los símbolos de predicado en $L$, tal que si $P$ corresponde a un símbolo de predicado $n$-ario: $f^{\mathcal{M}} : P^{n} \longrightarrow \{0,1\}$, O equivalente se puede dar una interpretación de que conjuntos $n$-arios cumplen dicho predicado de forma que $P^{n} \subseteq M^{n} $.
>En caso de trabajar con un LPO con igualdad: $=^{\mathcal{M}}: \{(a,a): a \in M\} $.

(Para facilitar la lectura, si no hay ambigüedad escribiremos $M$ en vez de $\mathcal{M}$)

Vamos a exponer algunos ejemplos de $L$-estructuras.

Tomemos el lenguaje $LA = \{\underbrace{\boldsymbol{0}, \boldsymbol{1}}_{const.}, \overbrace{<^{\left(2\right)} , =^{\left(2\right)}}^{pred.}, \underbrace{·^{\left(2\right)}, +^{\left(2\right)}}_{func.}\}$

Una $L$-estructura podría ser: $$ \mathcal{M_1} = \left\lbrace\begin{array}{l} M_1 = \mathbb{N} \\ \boldsymbol{0}^{M_1} = 0; \boldsymbol{1}^{M_1} = 1; \\ +^{M_1} : \mathbb{N^2} \longrightarrow \mathbb{N}, \, +^{M_1}(n_1, n_2) =  n_1 + n_2 \\ ·^{M_1} : \mathbb{N^2} \longrightarrow \mathbb{N}, \, ·^{M_1}(n_1, n_2) =  n_1 · n_2 \\ <^{M_1} : \mathbb{N^2} \longrightarrow Bool, \, <^{M_1} = \{(i,j): (i,j) \in \mathbb{N^2} \wedge (i < j)\}  \\  =^{M_1} : \mathbb{N^2} \longrightarrow Bool, =^{M_1} = \{(i,i) : i \in \mathbb{N}\}  \\ \end{array}\right.$$

Pero otra podría corresponder a: $$ \mathcal{M_2} = \left\lbrace\begin{array}{l} M_2 = \mathbb{Q} \\ \boldsymbol{0}^{M_2} = \frac{1}{2}; \boldsymbol{1}^{M_2} = 2; \\ +^{M_2} : \mathbb{Q}^2 \longrightarrow \mathbb{Q}, \, +^{M_2}(n_1, n_2) =  | n_1 - n_2 | \\ ·^{M_2} : \mathbb{Q}^2 \longrightarrow \mathbb{Q}, \, ·^{M_2}(n_1, n_2) =  n_1 \\ <^{M_2} : \mathbb{Q}^2 \longrightarrow Bool, \, <^{M_2} = \{(i,j): (i,j) \in \mathbb{Q^2} \wedge (i · j > 0)\}  \\  =^{M_2} : \mathbb{Q^2} \longrightarrow Bool, =^{M_2} = \{(i,i) : i \in \mathbb{N}\}  \\ \end{array}\right.$$

Recordemos que el predicado de igualdad es invariante en cualquier $L$-estructura y expresa la igualdad entre objetos.

$\longrightarrow$ <u>$L$-estructuras en logicus</u>

Como hemos señalado una $L$-estructura se compone de 2 elementos un universo y una interpretación, de forma que:

    type alias L_estructure a = (Universe a , Interpretation a)

El universo correspondía a un conjunto de objetos:

    type alias Universe a = List a

Las interpretaciones corresponden a la definición de aplicaciones de $U^n \longrightarrow U$ para los símbolos de funciones y $U^n \longrightarrow Bool$ para los símbolos de predicados. Luego:

    type alias Interpretation a =
        { i_const : Dict String a
         , i_funct : Dict String ((List a) -> a)
         , i_pred : Dict String ((List a) -> Bool)
        }

Esto nos permite definir toda $L$-estructura sobre universos finitos, por ejemplo, tomando el lenguaje de la aritmética y la $L$-estructura (de forma que cada elemento del universo tiene asociada la constante correspondiente):

$$ \mathcal{M} = \left\lbrace\begin{array}{l} M = \mathbb{N_{10}} \\ +^{M} : \mathbb{(N_{10})^2} \longrightarrow \mathbb{N_{10}}, \, +^{M}(n_1, n_2) =  n_1 + n_2 \\ ·^{M} : \mathbb{(N_{10})^2} \longrightarrow \mathbb{N_{10}}, \, ·^{M}(n_1, n_2) =  n_1 · n_2 \\ <^{M} : \mathbb{(N_{10})^2} \longrightarrow Bool, \, <^{M}(n_1, n_2) = n_1 < n_2  \\  =^{M} : \mathbb{(N_{10})^2} \longrightarrow Bool, =^{M}(n_1, n_2) = (n_1 = n_2)  \\ \end{array}\right.$$

Recordemos que el predicado de igualdad no necesita definición y que las constantes en logicus también se definen como funciones, de forma que:

```elm {l context="18"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Dict exposing (..)

m : Universe Int
m = [0,1,2,3,4,5,6,7,8,9,10]

isuma : List Int -> Int
isuma ls = List.sum ls

iprod : List Int -> Int
iprod ls = List.product ls

imenor : List Int -> Bool
imenor ls=
  case ls of
    [x,y] -> x < y
    _ -> False

i : Interpretation Int
i = { i_const = Dict.fromList <| List.map (\x -> (String.fromInt x, x)) m
    , i_funct = Dict.fromList [("+", isuma), ("·", iprod)]
    , i_pred = Dict.fromList [("<", imenor)]}

m_estr : L_estructure Int
m_estr = (m, i)
```
^^^elm {m=(Debug.toString m_estr) context="18"}^^^

#### Interpretación de las fórmulas en LPO.

Antes de explicar la interpretación de las fórmulas vamos ver cómo se interpretar los términos que las conforman:

> Dada una $L$-estructura $\mathcal{M}$ a cada término término $t$ de $L$, **sin variables** , le corresponde un objeto o elemento de $M$, que viene dado por la interpretación de la $L$-estructura ($t^{\mathcal{M}}$), de forma que: $$t^{\mathcal{M}} = \left\lbrace \begin{array}{ll} c^{\mathcal{M}} & \textrm{si } t \equiv c \, (\textrm{con } c=cte) \\ f^{\mathcal{M}}(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) & \textrm{si } t \equiv f(t_1, \ldots, t_n) \end{array}\right.$$

De forma que una vez interpretados los términos, podemos llevar a cabo la interpretación de las fórmulas, de forma que:

> Dada una $L$-estructura $\mathcal{M}$ decimos que una fórmula **cerrada**, $F$, se satisface en $\mathcal{M}$ (y se denota por $\mathcal{M} \models F$) si se da alguno de los siguientes supuestos:
> 1. $F \equiv P(t_1, \ldots, t_n)$ y además $P^{\mathcal{M}}(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) = True$ o, equivalentemente, $(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) \in P^\mathcal{M}$
> 2. $F \equiv \neg F_1$ y además $\mathcal{M} \not \models F_1$
> 3. $F \equiv F_1 \vee F_2$ y se tiene que  $\mathcal{M} \models F_1$ o  $\mathcal{M} \models F_2$ (análogo para el resto de conectivas).
> 4. $F \equiv \exists x \, F_1$ y además hay algún elemento $e \in M$ (representado por el término $e$) tal que $\mathcal{M} \models F_1\{x/e\}$.
> 5. $F \equiv \forall x \, F_1$ y además todo elemento $e \in M$ (representado por el término $e$) verifica $\mathcal{M} \models F_1\{x/e\}$.

En caso de que $F$ no sea cerrada se tiene, por definición:

$$\left( \mathcal{M} \models F \right) \Leftrightarrow \left(\mathcal{M} \models \forall{x_1, \ldots, x_n} F(x_1, \ldots, x_n)\right)$$

$\longrightarrow$ <u>Interpretación de términos y fórmulas en Logicus</u>

Acudiendo a la definición expuesta:

    interpretsTerm : Term -> Interpretation a ->  Maybe a
    interpretsTerm t i =
        case t of
            Var _ -> Nothing
            Func s [] -> Dict.get s i.i_const
            Func s args ->         
                let f = Dict.get s i.i_funct in
                    case f of
                        Nothing -> Nothing
                        Just x ->
                            let ls = List.map (\t2 -> interpretsTerm t2 i) args in
                                if List.any isNothing ls then
                                    Nothing
                                else
                                    Just <| x (values ls)

(Recuérdese que sólo se admiten interpretaciones sobre términos sin variables, luego, si en un término aparecen variables no es posible realizar su interpretación por lo que el objeto devuelto corresponde a un objeto vacío.)

Análogamente, según la definición recursiva dada para la interpretación de las fórmulas:

    interpretsFLPO : FormulaLPO -> L_estructure a -> Maybe Bool
    interpretsFLPO f estr = interpretsFLPOAux (universalClausureFLPO f) estr

    interpretsFLPOAux : FormulaLPO -> L_estructure a -> Maybe Bool
    interpretsFLPOAux f (m,i) =
        case f of
            Pred sp terms ->
                let ip = Dict.get sp i.i_pred in
                    case ip of
                        Nothing -> Nothing
                        Just x ->
                            let ls = List.map (\t -> interpretsTerm t i) terms in
                                if List.any isNothing ls then
                                    Nothing
                                else
                                    Just <| x (values ls)
            Equal t1 t2->
                let it1 = interpretsTerm t1 i
                    it2 = interpretsTerm t2 i
                in
                    if isNothing it1 || isNothing it2 then
                        Nothing
                    else Just  (it1 == it2)

            Neg f1 -> andThen (\if1 -> Just (not if1)) (interpretsFLPOAux f1 (m,i))
            Conj f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x && y)
            Disj f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x || y)
            Impl f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (not x || y)
            Equi f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x == y)
            Exists v f1 ->
                let ls = combine <| List.map (\o -> interpretsFLPOAux (applySubsToFormula (Dict.singleton (getVarSymb v) (Func o [])) f1) (m,i)) (Dict.keys i.i_const)in
                    case ls of
                        Nothing -> Nothing
                        Just li -> Just <| List.any (\x -> x) li
            Forall v f1 ->
                let ls = combine <| List.map (\o -> interpretsFLPOAux (applySubsToFormula (Dict.singleton (getVarSymb v) (Func o [])) f1) (m,i)) (Dict.keys i.i_const)in
                    case ls of
                        Nothing -> Nothing
                        Just li -> Just <| List.all (\x -> x) li
            Insat -> Just False

(De forma que la función devolverá un objeto vacío si existe algún símbolo en la fórmula que no esté recogido en la $L$-estructura, por tanto imposible de interpretar).

Veámos algunos ejemplos, probando si se cumplen algunas propiedades sobre el ejemplo anterior:

1. El elemento neutro de la suma es el 0: $\forall x \in \mathbb{N}_{10}: \, (x+0)=x$

```elm {l context="18"}

f1 = fromStringToFLPO "_+[x;_0;] = _0 " |> extractReadFLPO

-- Ejecutamos interpretsFLPO f1 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f1 m_estr) context="18"}^^^

2. Todo número múltiplo de 4 es también múltiplo de 2: $\forall x (\exists y (4·y)=x \rightarrow \exists y (2·y)=x)$

```elm {l context="18"}

f2 = fromStringToFLPO "FORALL{x} (EXISTS{y} (_·[_4;y;] =x) IMPLIES EXISTS{y} (_·[_2;y;] = x))" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f2 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f2 m_estr) context="18"}^^^

Sin embargo, el recíproco no es cierto:

```elm {l context="18"}

f3 = fromStringToFLPO "FORALL{x} (EXISTS{y} (_·[_2;y;] =x) IMPLIES EXISTS{y} (_·[_4;y;] = x))" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f3 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f3 m_estr) context="18"}^^^

3. Veámos que la suma no es interna, esto es, $\neg \forall x \forall y \exists z (z = (x+y))$

```elm {l context="18"}

f4 = fromStringToFLPO "NOT FORALL{x} FORALL{y} EXISTS{z} (z=_+[x;y;])" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f4 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f4 m_estr) context="18"}^^^

4. Veámos que no se tiene que para todo número existe uno que es mayor, $\forall x \exists y (x < y)$
```elm {l context="18"}

f5 = fromStringToFLPO "FORALL{x} EXISTS{y} (<[x;y;])" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f5 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f5 m_estr) context="18"}^^^

####  Satisfactibilidad, Validez y Consecuencia Lógica en LPO.

Igual que veíamos que una fórmula en LP es satisfactible si existía al menos un modelo, en LPO se dice que una fórmula es **satisfactible** si existe, al menos, un modelo para dicha fórmula, esto es si existe una $L$-estructura en la que se satisface ($\mathcal{M} \models F$). De forma análoga un conjunto de fórmulas $\Sigma$ es **consistente** si existe una $L$-estructura tal que toda fórmula de $\Sigma$ se satisface en $\mathcal{M}$

Una fórmula se dice **lógicamente válida** si para toda $L$-estructura ($\mathcal{M}$) se tiene $\mathcal{M} \models F$ (por ejemplo, $\forall{x} P(x) \vee \exists x \neg P(x)$)

Por último, de igual forma que veíamos el concepto de consecuencia lógica en LP, en LPO se tiene que una fórmula $F$ es **consecuencia lógica** de un conjunto de fórmulas $\Sigma$ (y se denota por $\Sigma \models F$) si se tiene que para toda $L$-estructura $\mathcal{M}$, $\mathcal{M} \models \Sigma \Rightarrow \mathcal{M} \models F$

Al contrario que en LP, en el que existían algoritmos (aunque ineficientes) que permitían determinar los problemas de consistencia y consecuencia lógica, en LPO este mismo problema no es decidible, esto es no existen algoritmos que permitan determinar, de forma completa, la consistencia de un conjunto de fórmulas (equivalente al problema de la consecuencia lógica).

Durante los siguientes temas estudiaremos algoritmos que tratarán de resolver el problema, aunque no sean decisivos en todos los casos.
