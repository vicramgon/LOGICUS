---
elm:
  source-directories:
    - ../../elm-sources/src
  dependencies:
      elm/browser: latest
      elm/core: latest
      elm/file: latest
      elm/html: latest
      elm/parser: latest
      elm-community/graph: latest
      elm-community/list-extra: latest
      elm-community/maybe-extra: latest
      munksgaard/char-extra: latest
      gicentre/elm-vegalite: latest
      avh4/elm-fifo: latest
      elm/bytes: latest
      elm/json: latest
      elm/time: latest
      elm/url: latest
      elm/virtual-dom: latest
      elm-community/intdict: latest
      Chadtech/elm-bool-extra: latest
---

<!-- Cargamos algunas funciones js que necesitamos -->

<script src="../js/d3.min.js"></script>
<script src="../js/viz.js" type="javascript/worker"></script>
<script src="../js/d3-graphviz.js"></script>
<script type="text/javascript">

    function plotDot(graphId){
        d3.select('#svgContainer' + graphId)
        .graphviz()
        .renderDot(document.getElementById("inDOT" + graphId).value.replace(/\\n/g, "\n").replace(/\\"/gm, '"'));

        document.getElementById("outputGraph" + graphId).style.display = "inline-block";
        document.getElementById("inputGraph" + graphId).style.display = "none";
    };

    function generatePng(graphId){
        var svgElement = document.getElementById('svgContainer' + graphId).querySelector('svg');
        var svgString = new XMLSerializer().serializeToString(svgElement);
        var canvas = document.getElementById("canvas" + graphId);
        canvas.width = svgElement.getBBox().width*1.33;
        canvas.height = svgElement.getBBox().height*1.33;
        var ctx = canvas.getContext("2d");
        var DOMURL = self.URL || self.webkitURL || self;
        var img = new Image();
        var svg = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});
        var url = DOMURL.createObjectURL(svg);
        img.onload = function() {
            ctx.drawImage(img, 0, 0);
            var png = canvas.toDataURL("image/png");

            document.querySelector("#pngContainer" + graphId).innerHTML = '<a id="downloadPNG'+ graphId +'" href="'+png+'" download/> PNG Image </a>';
            imgdownload = document.getElementById("downloadPNG"+ graphId)
            imgdownload.click();
            DOMURL.revokeObjectURL(png);
        };
        img.src = url;
    };
</script>


## **TEMA 1**
Sintaxis y Sem√°ntica en LP y LPO
====================

Descripci√≥n general del cap√≠tulo
--------------------------------

En este cap√≠tulo se recogen, de forma detallada, los m√≥dulos implementados que abordan el √°mbito de la sintaxis y sem√°ntica de la L√≥gica Proposicional y Primer Orden. Complementariamente, en el *Anexo A. Parsers* se encuentra el desarrollo de varios Parsers, que nos permiten acercar la escritura natural de las f√≥rmulas a la definici√≥n en el sistema.

### <u> Estructura del cap√≠tulo </u>

El cap√≠tulo se encuentra estructurado en distintas secciones, a trav√©s de las cuales se abordan los conceptos fundamentales del √°mbito sint√°ctico-sem√°ntico de la LP y la LPO, presentados conjuntamente con los m√≥dulos que implementan dichos conceptos:

-   **M√≥dulo SintaxSemanticsLP**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sint√°cticoS Y sem√°nticos de la L√≥gica Proposicional.

-   **M√≥dulo SintaxSemanticsLPO**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sint√°cticos y sem√°nticos de la L√≥gica de Primer Orden.

-   **M√≥dulo IO\_LP**. Recoge las implementaciones de los m√©todos relacionados con la lectura y representaci√≥n de las f√≥rmulas LP.

-   **M√≥dulo IO\_LPO**. Recoge las implementaciones de los m√©todos relacionados con la lectura y representaci√≥n de las f√≥rmulas LPO.


1.1. Conceptos b√°sicos de la L√≥gica Proposicional
--------------------------------------------

### Caracterizaci√≥n b√°sica de la L√≥gica Proposicional

La L√≥gica surge como m√©todo de modelado del siguiente problema:

> *Dado un conjunto de asertos (afirmaciones), $\mathcal{BC}$ (*Base de conocimiento*), y una afirmaci√≥n, $\mathcal{A}$, decidir si $\mathcal{A}$ ha de ser necesariamente cierta supuestas ciertas las f√≥rmulas de $\mathcal{BC}$.*


De manera que para abordar este problema resultan necesarios los siguientes elementos:

-   Un lenguaje que permita expresar de manera formal y precisa las afirmaciones, hechos e hip√≥tesis. (<u>Sintaxis</u>)

-   Una definici√≥n clara de qu√© se considera *afirmaci√≥n cierta*  (<u>Sem√°ntica</u>)

-   Mecanismos efectivos (y a poder ser eficientes) que garanticen la correcci√≥n (y preferentemente la completitud) en las deducciones. (<u>Algoritmos de decisi√≥n</u>)

A lo largo de los distintos cap√≠tulos abordaremos estos puntos para las dos representaciones m√°s comunes, la L√≥gica Proposicional (*LP* o *PL*) y la L√≥gica de Primer Orden (*LPO* o *FOL*).

Por el momento vamos a comenzar este primer cap√≠tulo abordando los dos primeros puntos para la L√≥gica Proposicional y la L√≥gica de Primer Orden, dando una somera introducci√≥n al tercero para cada caso dejando el desarrollo de los algoritmos de decisi√≥n, que se ir√°n abordando a lo largo del resto de cap√≠tulos.

#### Caracter√≠sticas fundamentales de la LP.

-   Sus expresiones (denominadas f*√≥rmulas proposicionales* o *proposiciones*) modelan afirmaciones que pueden considerarse *ciertas* o *falsas*.

-   Las f√≥rmulas proposicionales (en adelante f√≥rmulas (si no existe ambig√ºedad)), se construyen mediante un conjunto de expresiones  b√°sicas (*f√≥rmulas at√≥micas* o *√°tomos*) y conjunto de operadores (*conectivas l√≥gicas*). Dichas conectivas permiten modelar los  siguientes tipos de afirmaciones:

    -   *Conjunci√≥n*: ‚Äò... tal ... Y ... cual ...‚Äô

    -   *Disyunci√≥n*: ‚Äò... tal ... O ... cual ...‚Äô

    -   *Implicaci√≥n*: ‚ÄòSI tal ... ENTONCES ... cual ...‚Äô

    -   *Equivalencia*: ‚Äò... tal ... SI Y S√ìLO SI ... cual ...‚Äô

    -   *Negaci√≥n*: ‚ÄòNO es cierto tal ...‚Äô

    Profundizaremos en este aspecto en la pr√≥xima secci√≥n, cuando  veamos la *Sintaxis de la LP*.

-   El lenguaje s√≥lo permite modelar este tipo de afirmaciones, por lo que muchas veces puede ser dif√≠cil (o imposible) representar el problema en este tipo de L√≥gica, y es necesario recurrir a otras m√°s  ricas (*LPO, L√≥gicas Modales, L√≥gica Fuzzy, etc*). Especificaremos este apartado cuando tratemos las limitaciones de la LP e introduzcamos la LPO.

-   Aunque esta L√≥gica puede resultar de una aparente sencillez, el problema *SAT* corresponde a la categor√≠a de problemas NP-completos, esto es, no existe ning√∫n algoritmo capaz de resolver el problema planteado en un tiempo polinomial de ejecuci√≥n. Trataremos de nuevo este aspecto en la introducci√≥n a los algoritmos de decisi√≥n.

1.2. Fundamentos de la l√≥gica proposicional
--------------------------------------------

Vamos a abordar desde un punto de vista te√≥rico-pr√°ctico, los elementos base que conforman la L√≥gica Proposicional, esto es la S√≠ntaxis y la Sem√°ntica, mostrando unificadamente los desarrollos formales como las implementaciones llevadas a cabo para modelar cada uno de ellos.

### Sint√°xis de la l√≥gica Proposicional

#### El alfabeto proposicional

El concepto ‚Äò*alfabeto proposicional*‚Äô referencia al conjunto de s√≠mbolos que forman parte de este lenguaje. Podemos distinguir las siguientes categor√≠as:

-   **Variables proposicionales o √°tomos**. Ya hemos se√±alado previamente que todo problema est√° representado por relaciones entre un conjunto finito de afirmaciones b√°sicas, dichas afirmaciones se representan por s√≠mbolos proposicionales: $VP = \{p_0, p_1, \ldots, p, q, r\}$. <br><br>

    Aunque, formalmente, no existe ninguna restricci√≥n, vamos a adoptar el siguiente criterio en relaci√≥n a la sintaxis de los s√≠mbolos proposicionales:<br><br>

    > Los s√≠mbolos proposicionales deben comenzar por una letra min√∫scula, seguida (opcionalmente) de otros caract√©res en min√∫scula o d√≠gitos num√©ricos, exclusivamente.

-   **Conectivas L√≥gicas**. Modelan las relaciones entre las distintas afirmaciones b√°sicas (√°tomos). Podemos distinguir:

    -   De aridad 1 o monoaria : *Negaci√≥n* ($\neg$).

    -   De aridad 2 o binarias: *Conjunci√≥n* ($\wedge$), *Disyunci√≥n* ($\vee$), *Condicional* ($\rightarrow$), *Bicondicional* ($\leftrightarrow$).<br><br>

-   **S√≠mbolos Auxiliares**: ‚Äò*(*‚Äô y ‚Äò*)*‚Äô. Permiten expresar relaciones de prioridad entre conectivas l√≥gicas y evitar la ambigi√ºedad en la interpretaci√≥n de las f√≥rmulas.

#### F√≥rmula Proposicional

Se denomina expresi√≥n del lenguaje proposicional a cada una sucesi√≥n finita (y no vac√≠a) de sus s√≠mbolos y conectivas.Un ejemplo de expresi√≥n puede ser la siguiente $a \rightarrow b )ca\vee$, otro puede corresponder a $(a \rightarrow b ) \vee c$. Parece claro que el primero posee ‚Äúuna coherencia‚Äù o‚Äúequilibrio que no parece tener el primero. De esta forma, las expresiones "bien formadas" las denominaremos **f√≥rmulas proposicionales**.

> Formalmente, El conjunto de las f√≥rmulas proposicionales, $PROP$, es el menor conjunto de expresiones que verifica:
> - $VP \subseteq PROP$
> - Es cerrado bajo las conectivas l√≥gicas, esto es:
    - Si una f√≥rmula $F \in PROP$, entonces $\neg F \in PROP$
    - Si las f√≥rmulas $F, G \in PROP$, entonces $(F \wedge G), (F \vee G), (F \rightarrow G), (F \leftrightarrow G) \in PROP$

De manera que se tiene una definici√≥n recursiva del concepto de *F√≥rmula Proposiciona*, tal que el caso base corresponde a una f√≥rmula b√°sica (*√°tomo*) y el caso recursivo corresponde a la aplicaci√≥n de una conectiva sobre una o dos f√≥rmulas (seg√∫n la aridad de la conectiva).

##### √Årboles de formaci√≥n

Cada una de las f√≥rmulas proposicionales lleva asociado un grafo de tipo √°rbol (esencialmente √∫nico), que muestra el desarrollo de formaci√≥n de la f√≥rmula, siguiendo la definici√≥n recursiva de la misma.

Por ejemplo a la f√≥rmula: $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$ le corresponde el √°rbol de formaci√≥n:

<center> <img src="images/T1Img1.png" title="√Årbol formaci√≥n (ejemplo)"></center><br>

##### Prioridad de conectivas y Reducci√≥n de par√©ntesis.

Para facilitar la escritura y lectura de las f√≥rmulas vamos a adoptar algunos criterios:

1.  Omitimos los par√©ntesis externos.<br><br>
2.  Tomaremos como orden de precedencia de las conectivas (de mayor a  menor): $\neg$, $\wedge$, $\vee$ , $\rightarrow$, $\leftrightarrow$. (Para la conectiva $\leftrightarrow$ se recomienda mantener los par√©ntesis en todos los casos).<br><br>
3.  Cuando una conectiva se usa repetidamente, se asocia por la derecha.<br><br>

##### Principio de inducci√≥n sobre f√≥rmulas

Gracias a la definici√≥n de $PROP$ (y su estructura recursiva), para probar que toda f√≥rmula proposicional satisface una cierta propiedad ($\Psi$), podemos hacerlo aplicando el m√©todo de inducci√≥n sobre f√≥rmulas.

De esta forma, probamos:

1.  (*Caso base*). Probar que todos los elementos de $VP$ tienen la propiedad $\Psi$.

2.  (*Paso de inducci√≥n*).

    -  Si $F \in PROP$ tiene la propiedad $\Psi$, entonces $\neg F$ tiene la propiedad $\Psi$.

    -  Si $F, G \in PROP$, tienen la propiedad $\Psi$ entonces $(F \wedge G), (F \vee G), (F \rightarrow G), (F \leftrightarrow G) \in PROP$ tienen la propiedad $\Psi$

##### Escritura de las f√≥rmulas en Logicus

Vamos a exponer cu√°l es la sintaxis de las f√≥rmulas utilizando la librer√≠a Logicus, que nos permitir√° definir f√≥rmulas y aplicar diversos algoritmos sobre las mismas.

En la librer√≠a podemos definir las f√≥rmulas de dos formas distintas, o bien acudiendo directamente a los constructores de las f√≥rmulas (largo y engorroso), o bien utilizando el Parser (de forma an√°loga a la escritura natural de las f√≥rmulas).

$\longrightarrow$ <u>Definici√≥n de f√≥rmulas a partir de constructores</u>

Si recordamos la definici√≥n recursiva que se ha dado para las f√≥rmulas, expusimos que las mismas pueden corresponder o bien a √°tomos (*caso base*), o bien a la aplicaci√≥n de las conectivas, teniendo en cuenta la aridad de √©stas, sobre f√≥rmulas proposicionales (*caso recursivo*).

Bien, pues la implementaci√≥n dada en la librer√≠a para las f√≥rmulas corresponde fielmente a dicha definici√≥n. De forma que:

- Los s√≠mbolos proposicionales se definen como cadenas de caract√©res, (recordando el criterio, estos caracteres deben ir en min√∫scula).<br><br>

        type alias PSymb = String

- Las f√≥rmulas proposicionales se definen seg√∫n la estructura recursiva presentada.<br><br>

        type FormulaLP = Atom PSymb                 -- caso base
                        | Neg FormulaLP             --‚é´
                        | Conj FormulaLP FormulaLP  --‚é™
                        | Disj FormulaLP FormulaLP  --‚é¨ casos recursivos
                        | Impl FormulaLP FormulaLP  --‚é™
                        | Equi FormulaLP FormulaLP  --‚é≠
                        | Insat                     -- f√≥rmula insatisfactible

Esto nos permite definir todas las f√≥rmulas proposicionales. Para poder hacer uso de la librer√≠a logicus tenemos que importar de los m√≥dulos correspondientes las funciones y tipos necesarios para nuestro trabajo.

Expongamos algunos ejemplos:

a. $(p \wedge q) \vee (p \wedge r) \quad$ b. $ (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q \quad$ c. $(p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p$<br>

```elm {l context="1"}

import Modules.IO_LP exposing (toLatexFLP)
import Modules.SintaxSemanticsLP exposing (FormulaLP(..))

a : FormulaLP
a = Disj (Conj (Atom "p") (Atom "q")) (Conj (Atom "p") (Atom "r"))
```
^^^elm {m=(">" ++ toLatexFLP "a" a) context="1"}^^^

```elm {l context="1"}
b : FormulaLP
b = Impl (Disj (Conj (Atom "p") (Atom "r")) (Conj (Neg (Atom "p")) (Atom "q"))) (Neg (Atom "q"))
```

^^^elm {m=(">" ++ toLatexFLP "b" b) context="1"}^^^

```elm{l context="1"}
c : FormulaLP
c = Conj (Conj (Equi (Atom "p") (Atom "q")) (Impl (Atom "p") (Neg (Atom "q")))) (Atom "p")
```

^^^elm {m=(">" ++ toLatexFLP "c" c) context="1"}^^^

Como se puede apreciar, escribir las f√≥rmulas de esta forma puede resultar una tarea ardua y propensa a errores, por eso, se ha desarrollado un parser que nos permite escribir de forma m√°s c√≥moda,sint√©tica y visual las f√≥rmulas. Para poder utilizarlo se han establecido una serie de requisitos sint√°cticos, an√°logos a los presentados anteriormente:

- Los s√≠mbolos proposicionales deben comenzar por un caracter en min√∫scula seguido, opcionalmente, de caracteres en min√∫scula, d√≠gitos o el s√≠mbolo '_'.<br><br>

- Para las conectivas se usar√°n los siguientes s√≠mbolos, manti√©ndose la prioridad de las conectivas definida (en el orden de prioridad descendente expuesto en la tabla).

<table style="margin-left: auto; margin-right: auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Conectiva L√≥gica</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">S√≠mbolo Logicus</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Negaci√≥n (¬¨)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'NOT'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Conjunci√≥n (‚àß)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'AND'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Disyunci√≥n (‚à®)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'OR'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Implicaci√≥n (ü°í)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'IMPLIES'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Equivalencia (ü°ò)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'EQUIV'</td></tr></tbody></table><br>

- Los par√©ntesis se utilizan de igual forma en que se han definido en el lenguaje formal de la l√≥gica proposicional, con los s√≠mbolos '(' y ')'. No son necesarios los par√©ntesis externos de las f√≥rmulas.<br><br>

- En caso de uso repetido de una misma conectiva, se realizar√° asociaci√≥n por la derecha.

A partir de este momento todas las f√≥rmulas de los ejemplos se definir√°n utilizando el Parser por lo que llegados a este punto se recomienda tener claras las reglas sint√°cticas a seguir, aunque, son an√°logas a las planteadas por el lenguaje formal de la l√≥gica proposicional.

Para definir los ejemplos expuestos anteriormente:

```elm {l context="2"}
import Modules.SintaxSemanticsLP exposing (FormulaLP(..))
import Modules.IO_LP exposing (toLatexFLP, fromStringToFLP, extractReadFLP)

a : FormulaLP
a = fromStringToFLP "(p AND q) OR (p AND t)" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "a" a) context="2"}^^^
```elm{l context="2"}
b : FormulaLP
b = fromStringToFLP "(p AND r) OR (NOT p AND q) IMPLIES NOT q" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "b" b) context="2"}^^^
```elm{l context="2"}
c : FormulaLP
c = fromStringToFLP "(p EQUIV q) AND (p IMPLIES NOT q) AND p" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "c" c) context="2"}^^^

N√≥tese que la funci√≥n *fromStringToFLP* proporciona una tupla de dos elementos el primero de ellos corresponde a la f√≥rmula le√≠da y el segundo a una cadena de texto. Bien, si cometemos alg√∫n error sint√°ctico en la escritura de la f√≥rmula el Parser no ser√° capaz de interpretarla correctamente por lo que devolver√° una tupla *(Nothing,error)*, en el que el segundo elemento corresponder√° al mensaje de error y el primer elemento a un objeto vac√≠o.

Una vez le√≠da la f√≥rmula correctamente podemos extraerla utilizando la funci√≥n *extractReadFLP*. Si utilizamos dicha funci√≥n sobre una f√≥rmula le√≠da incorrectamente, se extraer√° como f√≥rmula la f√≥rmula insatisfactible.

$\longrightarrow$ <u>√Årboles de formaci√≥n en Logicus</u>

La librer√≠a tambi√©n permite la representaci√≥n de los √°rboles de formaci√≥n. La funci√≥n *formtree* muestra la representaci√≥n del √°rbol de formaci√≥n en formato texto DOT.

Por ejemplo para la f√≥rmula $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$:

```elm {l context="3"}
import Modules.IO_LP exposing (toLatexFLP, fromStringToFLP, extractReadFLP, formTree)
import Modules.SintaxSemanticsLP exposing (FormulaLP(..))
import Modules.AuxForLitvis exposing (showGraphViz)

a : FormulaLP
a = fromStringToFLP "NOT ( NOT (p OR q) IMPLIES (NOT r AND s))" |> extractReadFLP

fta : String
fta = formTree a
```
De forma que se obtiene:

^^^elm {m=(showGraphViz "G1" fta) context="3"}^^^

#### Conjuntos de f√≥rmulas

Definido $PROP$, los conjuntos de f√≥rmulas no son m√°s que subconjuntos de $PROP$, esto es, corresponden a agrupaciones de f√≥rmulas proposicionales.


##### Conjuntos de f√≥rmulas en Logicus

Los conjuntos proposicionales se definen como listas de f√≥rmulas proposicionales. De esta forma:


    type alias LPSet = List FormulaLP

De forma que la definici√≥n de estos se realiza como listas de objetos *FormulaLP*. Si por ejemplo queremos definir el conjunto:
$$ M = \left\lbrace (p \wedge q) \vee (p \wedge r), (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q, (p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p \right\rbrace$$

Podr√≠amos hacerlo:

```elm{l context="4"}

import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)

a : FormulaLP
a = fromStringToFLP "(p AND q) OR (p AND r)" |> extractReadFLP

b : FormulaLP
b = fromStringToFLP "(p AND r) OR (NOT p AND q) IMPLIES NOT q" |> extractReadFLP

c: FormulaLP
c = fromStringToFLP "(p EQUIV q) AND (p IMPLIES NOT q) AND p" |> extractReadFLP

m : LPSet
m = [a,b,c]
```

De forma que se obtiene:

^^^elm{m=(">" ++ toLatexLPSet "M" m) context="4"}^^^

### Sem√°ntica de la L√≥gica Proposicional

#### Interpretaciones, Modelos, Satisfactibilidad y Validez L√≥gica

Una vez provista la sintaxis, pasamos a desarrollar la sem√°ntica de la L√≥gica Proposicional. Como ya comentamos, hemos de abordar la interpretaci√≥n de certeza o veracidad de las f√≥rmulas. Para esto es necesario conocer los conceptos de *valor de verdad* y *funci√≥n de verdad*.

> -  **Valor de verdad**. Los elementos del conjunto $\{0,1\}$ se denominan valores de verdad o valores booleanos. Representan si un hecho es cierto o no, de forma que el valor $1$ se asocia a *verdadero* y el valor $0$ a *falso*.<br><br>
>  -   **Funciones de verdad**. Corresponden a funciones que devuelven un valor de verdad seg√∫n el valor de verdad de los argumentos. As√≠, el significado (valor de verdad asociado) de cada una de las conectivas l√≥gicas viene dado por una funci√≥n de verdad, de forma que:<br>
    $$\begin{array}{l l} H_{\neg}(i) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = 0\\
        0 & \textrm{si } i = 1\\
        \end{array} \right. & H_{\wedge}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j = 1\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\vee}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right. & H_{\rightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = 1, j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\leftrightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\end{array}$$

Visto esto, pasamos a estudiar el valor de verdad de las f√≥rmulas proposicionales. Para ello debemos definir el valor de verdad de las variables proposicionales, (denominadas *valoraciones* o *interpretaciones*) y a partir de √©stas y las funciones de verdad de las conectivas,podemos extender cada valoraci√≥n,$v$,de forma √∫nica,al conjunto de todas las f√≥rmulas de manera que se verifica:

$$\begin{array}{c c} v((F \wedge G))= H_{\wedge}(v(F), v(G)) & v((F \vee G))= H_{\vee}(v(F), v(G))\\\\ v((F \rightarrow G))= H_{\rightarrow}(v(F), v(G)) & v((F \leftrightarrow G))= H_{\leftrightarrow}(v(F), v(G)) \end{array}$$

> Dada una f√≥rmula $F \in PROP$, se dice que $v(F)$ es el valor de verdad de $F$ respecto de la valoraci√≥n $v$.

De esta forma, es sencillo realizar el c√°lculo del valor de verdad de una f√≥rmula respecto de una valoraci√≥n, recurriendo al √°rbol de formaci√≥n de la f√≥rmula, evaluando las subf√≥rmulas, desde las hojas (variables proposicionales) hasta el nodo ra√≠z (la f√≥rmula completa).

Por ejemplo el c√°lculo de la valoraci√≥n de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$:

<center> <img src="images/T1Img3.png" title="C√°lculo de la valoraci√≥n con el AF."></center><br>

Adem√°s del c√°culo a trav√©s del √Årbol de Formaci√≥n, existe otro m√©todo (equivalente) para el c√°lculo del valor de verdad de una f√≥rmula respecto de una valoraci√≥n, c√°lculo a trav√©s de Tabla. Dado que, dada una valoraci√≥n,$v$, el valor de verdad de una f√≥rmula $F$ respecto de $v$ est√° determinado por los valores de verdad de las subf√≥rmulas de $F$, podemos construir una tabla que recorra los valores de sus subf√≥rmulas. Para el ejemplo anterior:

<table style="margin-left: auto; margin-right: auto; width:80%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p ‚à® q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(p ‚à® q)</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨r ‚à® s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(p ‚à® q) <span style="font-weight:400;font-style:normal">‚à®</span> <span style="font-style:normal">¬¨(r ‚à® s)</span></th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(<span style="font-style:normal">¬¨(p ‚à® q) </span>‚à® (¬¨r ‚à® s))</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr></tbody></table><br>

##### Tablas de Verdad

Una tabla de verdad corresponde a una estructura similar a la anterior (nosotros s√≥lo reflejaremos el valor de las variables proposicionales y el valor de verdad de la f√≥rmula completa), en la que en cada fila se presenta la valoraci√≥n y el valor de verdad de la f√≥rmula respecto a la misma, para toda interpretaci√≥n posible (que corresponda a las variables proposicionales presentes en la f√≥rmula).

Para la f√≥rmula anterior, su tabla de verdad corresponder√≠a a:

<table style="margin:auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(<span style="font-style:normal">¬¨(p ‚à® q) </span>‚à® (¬¨ r ‚à® s))</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr></tbody></table>


##### Modelos, Satisfactibilidad y Validez L√≥gica

Una vez estudiado lo anterior, vamos dar unas cuantas definiciones:

> -  **Modelo.** Se dice que una f√≥rmula $F$ es v√°lida en una valoraci√≥n $v$ o equivalentemente que $v$ es **modelo** de $F$ si $v(F)=1$ y se denota por $v \models F$. En caso contrario, se dice que $v$ es **contramodelo** de $F$ y se denota $v \not \models F$.<br><br>
> - **Satisfactibilidad.** Una f√≥rmula $F$ se dice **satisfactible** (o consistente) si existe una valoraci√≥n $v$ que es modelo de $F$. En caso contrario se dice que $F$ es **insatisfactible** (o inconsistente), y se representa por $\perp$.<br><br>
> - **Validez l√≥gica o Tautolog√≠a**. Una f√≥rmula $F$ se dice **tautolog√≠a** (o (l√≥gicamente) v√°lida) si toda valoraci√≥n es modelo de $F$ y se denota $\models F$.<br>

$\longrightarrow$ <u>Relaci√≥n entre Validez y Satisfactibilidad</u>

> *LEMA*: Para cada $F \in PROP$ se verifica:
> -  Si $F$ es tautolog√≠a, entonces $F$ es satisfactible.<br>
> -  $F$ es tautolog√≠a si y s√≥lo si $F$ es insatisfactible.<br>

<br>

##### Sem√°ntica de F√≥rmulas LP en Logicus

La librer√≠a dispone de funciones que modelan todos los conceptos sem√°nticos que hemos visto hasta ahora.

$\longrightarrow$ <u>Valores, Funciones de Verdad e Interpretaciones</u>

Como hemos estudiado los **valores de verdad** corresponden a 1 (*verdadero*) y 0 (*falso*). Elm ya provee esos valores booleanos en el tipo *Bool*, por lo que no es necesario realizar ninguna definici√≥n alternativa para este concepto.

Las definici√≥n de las funciones de verdad asociadas a las conectivas corresponden directamente a la aplicaci√≥n de dichas funciones en la evaluaci√≥n de las f√≥rmulas. Antes de ver la evaluaci√≥n resulta necesario ver la definici√≥n que se ha dado para las interpretaciones. Para ello, se ha elegido una representaci√≥n "dispersa" de manera que una interpretaci√≥n corresponde a una lista de s√≠mbolos proposicionales (variables proposicionales) que son los que son considerados verdaderos, los t√©rminos que no aparecen en la lista ser√°n considerados como falsos.

    type alias Interpretation = List PSymb

Con esta definici√≥n resulta sencillo llevar a cabo la evaluaci√≥n de las f√≥rmulas. Tal y como se ha planteado formamelte, podemos distinguir el proceso de evaluaci√≥n en 2 casos:

- **Evaluaci√≥n de variables**. Una variable ser√° verdadera si en la interpretaci√≥n le otorga dicho valor, esto es, seg√∫n la definici√≥n dada, ser√° verdadera si pertenece a la lista de la interpretaci√≥n, y ser√° falsa en caso contrario.

- **Evaluaci√≥n de conectivas**. Seg√∫n la definici√≥n formal dada:
$$\begin{array}{l l} H_{\neg}(i) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = 0\\
        0 & \textrm{si } i = 1\\
        \end{array} \right. & H_{\wedge}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j = 1\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\vee}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right. & H_{\rightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = 1, j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\leftrightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\end{array}$$

De forma que:

    valuation : FormulaLP -> Interpretation -> Bool
    valuation pr i =
        case pr of
            Atom p -> List.member p i
            Neg p -> not (valuation p i)
            Conj p q -> valuation p i &&  valuation q i
            Disj p q ->   valuation p i ||  valuation q i
            Impl p q ->   not (valuation p i) ||  valuation q i
            Equi p q ->   valuation (Impl p q) i &&  valuation (Impl q p) i
            Insat -> Basics.False

NOTA: n√≥tese que la f√≥rmula insatisfactible, l√≥gicamente, es falsa respecto de cualquier valoraci√≥n.

De forma que la funci√≥n *valuation* nos permite calcular la valoraci√≥n de una f√≥rmula respecto de una valoraci√≥n. Por ejemplo, calculemos la valoraci√≥n de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$:

```elm{l context="5"}

import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)

f : FormulaLP
f = fromStringToFLP "NOT (NOT (p OR q) OR (NOT r OR s))" |> extractReadFLP

i : Interpretation
i = ["p", "q"]
```

^^^elm{r=(valuation f i) context="5"}^^^

$\longrightarrow$ <u>Tabla de Verdad, Modelos, Satisfactibilidad y Validez </u>

Como se ha expuesto anteriormente una tabla de verdad recoge las valoraciones de una f√≥rmula respecto a todas las posibles interpretaciones que integran a sus s√≠mbolos proposicionales. Bien dada la definici√≥n de las interpretaciones resulta bien sencillo el c√°lculo de todas las posibles interpretaciones, de hecho el conjunto de interpretaciones corrsponde a todos los posibles subconjuntos del conjunto formado por los s√≠mbolos proposicionales que participan en la f√≥rmula. De esta forma:

    symbInProp : FormulaLP -> Set.Set PSymb
    symbInProp f=
        case f of
            Atom p -> Set.singleton p
            Neg p -> symbInProp p
            Conj p q -> Set.union (symbInProp p ) (symbInProp q)
            Disj p q -> Set.union (symbInProp p ) (symbInProp q)
            Impl p q -> Set.union (symbInProp p ) (symbInProp q)
            Equi p q -> Set.union (symbInProp p ) (symbInProp q)
            Insat -> Set.empty

    allInterpretations : FormulaLP -> List Interpretation
    allInterpretations x =  Aux.powerset <| List.sort <| Set.toList <| symbInProp x

Y la tabla de verdad corresponde al conjunto de pares (*Interpretaci√≥n, Valoraci√≥n*), que corresponde a las entradas cada una de las entradas (filas) de la tabla.

    truthTable : FormulaLP -> List (Interpretation, Bool)
    truthTable x = List.map (\xs ->  (xs,valuation x xs)) <| allInterpretations x

Para el ejemplo anterior:

```elm{l context="6"}
import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)
import Modules.AuxForLitvis exposing (showTable)
import Modules.AuxiliarFunctions exposing (uncurry)
import Bool.Extra exposing (toString)

f : FormulaLP
f = fromStringToFLP "NOT (NOT (p OR q) OR (NOT r OR s))" |> extractReadFLP

-- Ejecutamos: truthTable f |> truthTableToMDFormat (symbInProp f) |> uncurry (showTable)
```

^^^elm{m=(truthTable f |> truthTableToMDFormat (symbInProp f) |> uncurry (showTable)) context="6"}^^^

Una vez calculadas todas las posibles interpretaciones resulta sencillo calcular los modelos y contramodelos de una f√≥rmula proposicional, sin m√°s que seleccionar aquellos que sean evaluados como verdaderos o falsos, respectivamente. Tal que:

    models : FormulaLP -> List Interpretation
    models x = List.filter (\y -> valuation x y) (allInterpretations x)

    countermodels : FormulaLP -> List Interpretation
    countermodels x = List.filter (\y -> not(valuation x y)) (allInterpretations x)

De forma que para la f√≥rmula anterior, el conjunto de modelos y contramodelos corresponder√≠a a:

```elm{l context="6"}

modelos_f : List Interpretation
modelos_f =  models f
```

^^^elm{m=(interpretations2MDFormat modelos_f) context="6"}^^^

```elm{l context="6"}

contramodelos_f : List Interpretation
contramodelos_f = countermodels f
```

^^^elm{m=(interpretations2MDFormat contramodelos_f) context="6"}^^^

Del mismo modo resulta casi trivial decidir la satisfactibilidad y validez de las f√≥rmulas proposicionales, sin m√°s que comprobar si todas las interpretaciones hacen a la f√≥rmula verdadera (*tautolog√≠a*), alguna de ellas la hace verdadera (*f√≥rmula satisfactible*), o no la hace ninguna de ellas (*f√≥rmula insatisfactible*). As√≠:


    satisfactibility : FormulaLP -> Bool
    satisfactibility x = List.any (\xs-> valuation x xs) (allInterpretations x)

    validity : FormulaLP -> Bool
    validity x = List.all (\xs-> valuation x xs) (allInterpretations x)

    insatisfactibility : FormulaLP -> Bool
    insatisfactibility x = List.all (\xs-> not(valuation x xs)) (allInterpretations x)

De forma que en el caso dela f√≥rmula anterior, sabemos que es satisfactible ya que el conjunto de modelos no era vac√≠o, y que no es tautolog√≠a ya que el de contramodelos tampoco lo era. Utilizando las funciones provistas por la librer√≠a:

```elm{l context="6"}

isSatisfactible_f : Bool
isSatisfactible_f = satisfactibility f
```
^^^elm{m=(toString isSatisfactible_f) context="6"}^^^

```elm{l context="6"}

isTaut_f : Bool
isTaut_f = validity f
```
^^^elm{m=(toString isTaut_f) context="6"}^^^

```elm{l context="6"}

isInsatisfactible_f : Bool
isInsatisfactible_f = insatisfactibility f
```

^^^elm{m=(toString isInsatisfactible_f) context="6"}^^^

#### Conjuntos de F√≥rmulas. Modelos y Consistencia.

De forma an√°loga a la presentada para las f√≥rmulas proposicionales podemos definir los conceptos anteriores, aplicados a conjuntos de f√≥rmulas de forma que:

>- **Modelo.** Se dice que una valoraci√≥n $v$ es **modelo** de un conjunto de f√≥rmulas $U$ si para toda f√≥rmula $F \in U$ se tiene que $v(F)=1$ y se denota por $v \models U$. En caso contrario, se dice **contramodelo**.<br><br>
> -   **Consistencia** Un conjunto de f√≥rmulas $U$ se dice **consistente** si existe una valoraci√≥n $v$ que es modelo de $U$. En caso contrario se dice que $U$ es **inconsistente**.


##### Consecuencia L√≥gica.

>Una f√≥rmula $F$ es consecuencia l√≥gica (o se sigue) de un conjunto de f√≥rmulas $U$, y se denota por $U \models F$, si toda valoraci√≥n que es modelo de $U$ es tambi√©n modelo de $F$.

Es precisamente este concepto el que permite formular el problema b√°sico en el marco de la l√≥gica proposicional, que planteamos como objetivo de la LP.

##### Relaci√≥n entre consecuencia l√≥gica, consistencia y validez

> *PROPOSICI√ìN*: Sea $U = \{F_1, F_2, \ldots, F_n \} \subseteq PROP$ y $F \in PROP$ son equivalentes:
>- $(U = \{F_1, F_2, \ldots, F_n \}) \models F$<br><br>
>- $\left(\bigwedge \limits_{F_i} U = (F_1 \wedge F_2 \wedge \ldots \wedge F_n)\right) \rightarrow F \in TAUT$<br><br>
>- $\left( U \cup \{\neg F\} = \{F_1 , F_2 , \ldots , F_n , \neg F\} \right) \models \perp$

##### Sem√°ntica de Conjuntos LP en Logicus

Al igual que en el caso de las f√≥rmulas proposicionales podemos realizar una traslaci√≥n directa de los conceptos formalmente expuestos a las implementaciones, de forma que el c√°lculo de las posibles interpretaciones, an√°logamente al caso de las f√≥rmulas, se reduce al c√°lculo de los posibles subconjuntos de los s√≠mbolos proposicionales presentes en las f√≥rmulas, correspondientes a la uni√≥n de los conjuntos de s√≠mbolos asociados a cada una de las f√≥rmulas. De esta forma:

    setSymbols : List FormulaLP -> Set.Set PSymb
    setSymbols xs = List.foldr (\x acc -> Set.union acc (symbInProp x)) Set.empty xs

    allSetInterpretations : List FormulaLP -> List Interpretation
    allSetInterpretations xs = Aux.powerset <| Set.toList <| setSymbols xs

De forma que el c√°lculo de los modelos, contramodelos, consistencia e inconsistencia se reduce a aplicar las definiciones sobre el conjunto de f√≥rmulas:

    isSetModel : List FormulaLP -> Interpretation -> Bool
    isSetModel xs i =  List.all (\x -> valuation x i) xs

    allSetModels : List FormulaLP -> List Interpretation
    allSetModels xs = List.filter (isSetModel xs) (allSetInterpretations xs)

    allSetCounterModels : List FormulaLP -> List Interpretation
    allSetCounterModels xs = List.filter (\x -> not(isSetModel xs x)) <| allSetInterpretations xs

    isConsistent : List FormulaLP -> Bool
    isConsistent xs = List.any (\x -> isSetModel xs x) <| allSetInterpretations xs

    isInconsistent: List FormulaLP -> Bool
    isInconsistent xs = not(isConsistent xs)

$\longrightarrow$ <u>Consecuencia l√≥gica</u>

Dada la definici√≥n de conseciencia l√≥gica y teniendo en cuenta la relaci√≥n entre consecuencia l√≥gica, consistencia y validez (√∫ltimo caso), funcionalmente hemos planteado dos desarrollos alternativos para el concepto de Consecuencia L√≥gica:

(1) Acudiendo a la propia definici√≥n. (2) Acudiendo al tercer punto de la proposici√≥n anterior.

    isConsecuence : List FormulaLP -> FormulaLP -> Bool
    -- isConsecuence xs x = List.all (\y -> valuation x y) <| allSetModels xs
    isConsecuence xs x = isInconsistent (xs ++ [Neg x])

NOTA: Se ha dejado la segunda como implementaci√≥n final.

Ve√°mos un ejemplo, dado el conjunto de f√≥rmulas $U=\{p \rightarrow q,q \rightarrow p \wedge r\}$ y la f√≥rmula $ F = p \rightarrow (p \rightarrow q) \rightarrow r$, ve√°mos si se cumple $U \models F$.

```elm{l context="7"}

import Modules.IO_LP exposing (..)
import Modules.SintaxSemanticsLP exposing (..)
import Bool.Extra exposing (toString)

u1 : FormulaLP
u1 = fromStringToFLP "p IMPLIES q" |> extractReadFLP

u2 : FormulaLP
u2 =  fromStringToFLP "q IMPLIES p AND r" |> extractReadFLP

uSet : LPSet
uSet = [u1, u2]

f : FormulaLP
f = fromStringToFLP "p IMPLIES (p IMPLIES q) IMPLIES r" |> extractReadFLP

-- Ejecutamos toString <| isConsecuence uSet  f
```

^^^elm{m=(toString <| isConsecuence uSet  f) context="7"}^^^

De hecho, acudiendo a la definici√≥n podemos ver que, en efecto, todo modelo del conjunto $U$ es tambi√©n modelo de la f√≥rmula $F$.

```elm{l context="7"}

modelos_U : List Interpretation
modelos_U = allSetModels uSet

modelos_F : List Interpretation
modelos_F = models f

{-Ejecutamos:
    interpretations2MDFormat modelos_U
    interpretations2MDFormat modelos_F
  -}
```
De forma que los modelos de $U$ corresponden a:

^^^elm{m=(interpretations2MDFormat modelos_U) context="7"}^^^

Y los de $F$:

^^^elm{m=(interpretations2MDFormat modelos_F) context="7"}^^^

De forma que, en efecto, todo modelo de $U$ es tambi√©n modelo de $F$, luego $F$ se sigue de $U$.

### Algoritmos de decisi√≥n en LP

Como hemos se√±alado vamos a presentar de forma somera los algoritmos de decisi√≥n en LP, e iremos desarrollando algunos de los algoritmos m√°s importantes a lo largo de los distintos cap√≠tulos.

> Dado un conjunto de f√≥rmulas $U$, un **algoritmo de decisi√≥n** para $U$ es aqu√©l que dada una f√≥rmula $A \in PROP$, devuelve `SI` cuando $A \in U$ y `NO` cuando $A \not\in U$

Esto da pie a la definici√≥n de algunos problemas con un especial inter√©s:

> - $SAT = \{A \in PROP: \, A \textit{ es satisfactible}\}$.
> - $TAUT = \{A \in PROP: \, A \textit{ es tautolog√≠a}\}$.
> - Fijado $U \subseteq PROP$, la *Teor√≠a de $U$* corresponde a: $\mathcal{T}(U) = \{A \in PROP: \, U \models A\}$.

Precisamente, un algoritmo de decisi√≥n para $\mathcal{T}(U)$ proporciona una respuesta al Problema B√°sico que planteamos al comienzo del cap√≠tulo. Por tanto, podemos reducir dicho problema a uno nuevo:
> Obtener un algoritmo que, dado un conjunto finito de f√≥rmulas proposicionales, $U$, y una f√≥rmula, $F$, decida si $U \models F$.

Y este a su vez se reduce a comprobar la satisfactibilidad de una cierta f√≥rmula (o bien la validez de otra), hemos aqu√≠ el problema conocido como *Problema $SAT$*.

Notemos que ya hemos visto un algoritmo, el de las Tablas de Verdad, que resuelve, de forma simple, el problema, pero la complejidad de dicho algoritmo es exponencial en el n√∫mero de s√≠mbolos proposicionales, lo que lo hace inabordable para f√≥rmulas de cierta complejidad , incluso computacionalmente.

Hemos de se√±alar que existen otros algoritmos de decisi√≥n del problema $SAT$, algunos de los cuales abordaremos a lo largo de los siguientes cap√≠tulos, pero a√∫n no se ha encontrado ninguno capaz de resolver el problema eficientemente (complejidad polinomial), y, de hecho, se duda (fuertemente) de la existencia del mismo. De hecho, determinar la satisfactibilidad de una f√≥rmula proposicional se trata de un problema NP-completo.

1.3 De Proposiciones a Predicados.
Conceptos B√°sicos de L√≥gica de Primer Orden
----------------------------------------------------

### Limitaciones de la L√≥gica Proposicional

Aunque la l√≥gica proposicional posee un sem√°ntica sencilla y existen algoritmos de decisi√≥n (poco eficientes) para sus problemas b√°sicos, como $SAT$ o la consecuencia l√≥gica, la expresividad de LP es bastante limitada, esto hace que muchos problemas no sean modelables en LP, bien porque requieren un gran n√∫mero de f√≥rmulas o f√≥rmulas de gran tama√±o, o
bien porque no puedan ni siquiera expresarse en este lenguaje. El siguiente ejemplo presenta un razonamiento que es v√°lido, sin embargo no es expresable en LP:

‚Äã1. Todo hombre es mortal.
2. S√≥crates es hombre.
3. Por tanto, S√≥crates es mortal.

¬øC√≥mo expresar el concepto de ser hombre?¬øComo expresar qui√©n es S√≥crates?, pero a√∫n m√°s ¬øC√≥mo expresar que todos es mortal?. Es aqu√≠ precisamente donde comienza el √°mbito de la L√≥gica de PrimerOrden.

### Caracterizaci√≥n de la L√≥gica de Primer Orden

La L√≥gica de Primer Orden (LPO) extiende la L√≥gica Proposicional, ganando capacidad expresiva, que permite abordar cuestiones como:

- Realizar cuantificaci√≥n sobre los objetos de un dominio, esto es, expresar en qu√© medida se tiene una propiedad sobre un conjunto de objetos.

- Representar propiedades de los objetos particulares del dominio por medio de predicados y funciones.

- Trabajar con subconjuntos de objetos que pueden venir caracterizados por propiedades que se describen por medio de predicados y funciones.



1.4. Fundamentos de la L√≥gica de Primer Orden
----------------------------------------------------

De forma an√°loga a como se ha visto para la l√≥gica proposicional vamos a estudiar los elementos que definen la L√≥gica de Primer Orden (Sint√°xis y Sem√°ntica) dejando para cap√≠tulos futuros el desarrollo de los Algoritmos de Decisi√≥n.

### Sint√°xis de la L√≥gica de Primer Orden

Formalmente,

> La **L√≥gica de Primer Orden** o **L√≥gica de Predicados** es un sistema formal dise√±ado para estudiar los m√©todos inferenciales en los leguajes de primer orden.

Un **lenguaje de primer orden** corresponde a un lenguaje formal que consta de:

- <u>S√≠mbolos l√≥gicos</u> (comunes a todos los lenguajes): En los que se engloban:

    -   Un conjunto de *Variables:* $V = \{x, x_0, x_1, \ldots, y, y_0, \ldots \}$

    -   *Conectivas l√≥gicas :* $\neg$ (negaci√≥n), $\wedge$ (conjunci√≥n), $\vee$ (disyunci√≥n), $\rightarrow$ (implicaci√≥n), $\leftrightarrow$ (equivalencia).

    -   *Cuantificadores:* $\exists$ (existencial), $\forall$ (universal).

    -   *S√≠mbolos auxiliares:* $`('$ y $`)'$<br><br>

-   <u>S√≠mbolos no l√≥gicos</u> (propios de cada lenguaje): En los que se engloban:

    -   Un conjunto de *Constantes:* $L_{C}= \{a, b, \ldots, a_{0}, a_{1}, \ldots \}$

    -   Un conjunto de *s√≠mbolos de funci√≥n:* $L_{F} = \{f_{0}, f_{1}, \ldots\}$, cada uno con su aridad correspondiente.

    -   Un conjunto de **s√≠mbolos de predicado:** $L_P=\{P_{0}, P_{1}, \ldots, Q, Q_0, \ldots\}$, cada uno con su aridad correspondiente.

        Dos notas:

        -   Los s√≠mpolos de predicado de aridad 0 act√∫an como s√≠mbolos proposicionales.

        -   El s√≠mbolo de igualdad (‚Äò$=$‚Äô) no es un predicado com√∫n a todos los lenguajes de primer orden, pero si es corriente su aparici√≥n. La familia de lenguajes que incluyen este predicado es denominada *Lenguajes de Primer Orden con Igualdad*.

Este aparato permite la construcci√≥n de distintas expresiones, que componen las f√≥rmulas de LPO. Vamos a exponer una diferenciaci√≥n de dichas expresiones, distinguiendo *t√©rminos* y *f√≥rmulas*.

#### T√©rminos en LPO

Los t√©rminos se identifican con posibles objetos del mundo. Englobando los siguientes elementos:

- <u>Constantes</u> para hablar de objetos espec√≠ficos.
- <u>Variables</u> para hablar de objetos gen√©ricos.
- <u>Funciones</u> aplicadas a otros t√©rminos m√°s peque√±os, seg√∫n su aridad.

Para ejemplificar los conceptos expuestos a lo largo del tema vamos a modelar el mundo romano:
(los super√≠ndices indican la aridad)

$$LR = \{\underbrace{\boldsymbol{C√©sar}, \boldsymbol{Marco}}_{constantes}, \underbrace{P^{1}, L^{2}, O^{2}, R^{1}, IA^{2}}_{\textit{s√≠mbolos de predicado}}, \underbrace{f^{1}}_{\textit{s√≠mbolo de funci√≥n}} \}$$

tal que, donde, $C√©sar$ y $Marco$ son constantes, $P$ y $R$ son predicados unarios que denotan *ser pompeyano* y *ser romano*, respectivamente; $L$, $O$, $IA$ son predicados binarios que denotan *ser leal a*, *odiar a* , *intentar asesinar a*, respectivamente; y $f$ una funci√≥n unaria que represente el concepto de *padre de*.

De forma que son t√©rminos de $LR$:



- *Constantes*: *Marco*, *C√©sar*.
- *Variables*: $x$, $y$, $x_1$, ...
- *Funciones*: f(C√©sar), f(x), f(f(x)), ...

#### F√≥rmulas en LPO

Las f√≥rmulas se identifican con afirmaciones sobre los objetos del mundo, permitiendo hablar de la veracidad o falsedad de las afirmaciones. Est√°n formadas a partir de predicados sobre t√©rminos, y construcciones l√≥gicas de estos predicados (conjunciones, implicaciones, cuantificaciones, etc.). Ve√°mos esto formalmente.

Las f√≥rmulas pueden corresponder a:

- <u>√Åtomos o F√≥rmulas at√≥micas</u>. Corresponden a las expresiones $p(t_1, t_2, \ldots, t_n)$, tal que $p$ es un s√≠mbolo de predicado de aridad $n$ y $t_i$ son t√©rminos.

- <u>F√≥rmulas no at√≥micas</u>. Corresponden a expresiones formadas a partir de f√≥rmulas at√≥micas, mediante el empleo de conectivas y/o cuantificadores.

De esta forma, son f√≥rmulas de $L$:

- Toda f√≥rmula at√≥mica.

- Si F y G son f√≥rmulas de de $L$ entonces $\neg F$, $F \wedge G$, $F \vee G$, $F \rightarrow G$, $F \leftrightarrow G$, tambi√©n son f√≥rmulas de $L$.

- Si x es una variable y F es una f√≥rmula de $L$, entonces $\exists x \, F$ y $\forall x \, F$ son tambi√©n f√≥rmulas de $L$.

Volviendo al mundo romano, algunas posibles f√≥rmulas del lenguaje $LR$:

- *√Åtomos*: $P(\boldsymbol{C√©sar})$, $L(\boldsymbol{C√©sar}, \boldsymbol{Marco})$, $IA(\boldsymbol{Marco}, f(x))$.
- *F√≥rmulas compuestas*: $\forall x \exists y \, L(x,y)$, $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$

$\longrightarrow$ <u>Reglas de simplificaci√≥n de la notaci√≥n</u>

Para facilitar la lectura y escritura de las f√≥rmulas vamos a tomar varios criterios de notaci√≥n:

- Se omitir√°n los par√©ntesis externos.
- Las prioridades de las conectivas siguen el mismo orden que el expuesto en LP: $\neg, \wedge, \vee, \rightarrow, \leftrightarrow$ (para la √∫ltima se recomienda mantener los par√©ntesis).
- Los cuantificadores tienen prioridad sobre las conectivas.

##### √Årboles de formaci√≥n.

Al iguan que en las f√≥rmulas de LP, la definici√≥n de las f√≥rmulas en LPO presenta una estructura recursiva:

- *Caso base*. F√≥rmulas at√≥micas.
- *Casos recursivos* Aplicaci√≥n de las conectivas y cuantificadores sobre f√≥rmulas de LPO.

Y de forma an√°loga a la presentada en LP, se puede plasmar dicha estructura recursiva en un grafo tipo √°rbol (esencialmente √∫nico), de forma que el nodo ra√≠z corresponde a la f√≥rmula completa y las hojas corresponden a las f√≥rmulas at√≥micas que participan en la f√≥rmula. Al igual que en LP, toda f√≥rmula que aparezca en alg√∫n nodo (ya sea un nodo interno o una hoja) diremos que es **subf√≥rmula** de la f√≥rmula original.

Para la f√≥rmula $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$, se tendr√≠a el AF asociado:<br><br>

<center> <img src="images/T1Img4.png" title="√Årbol de formaci√≥n en LPO (ejemplo)."></center><br>


##### Sintaxis de F√≥rmulas LPO en Logicus

Al igual que hicimos con la l√≥gica LP, vamos a exponer cu√°l es la sintaxis de las f√≥rmulas utilizando la librer√≠a Logicus, que nos permitir√° definir f√≥rmulas y aplicar diversos algoritmos sobre las mismas.

Bajo la librer√≠a podemos definir las f√≥rmulas de dos formas distintas, o bien acudiendo directamente a los constructores de las f√≥rmulas (largo y engorroso), o bien utilizando el Parser (de forma an√°loga a la escritura natural de las f√≥rmulas).

$\longrightarrow$ <u>Definici√≥n de f√≥rmulas a partir de constructores (M√≥dulo *SintaxSemanticsLPO*)</u>

Antes de introducirnos en el estudio de la sintaxis de f√≥rmulas vamos a presentar la sintaxis y definici√≥n de t√©rminos. Recordemos que la estuctura de los t√©rminos corresponde a una definici√≥n recursiva con <u>variables</u> y <u>constantes</u> como *casos base* y <u>funciones</u>.

Aunque la definici√≥n en la librer√≠a sigue esta idea, se ha decidido modelar las <u>constantes</u> como funciones independientes de variables, de forma que en la librer√≠a se tiene que un t√©rmino es o bien una variable o bien una funci√≥n.

    type Term = Var String
              | Func String (List Term)

De forma que las constantes corresponder√≠an a objetos con la estructura *Func String [ ]*.

De forma que podemos definir t√©rminos de forma sencilla mediante el uso de estos constructores. Volviendo al ejemplo presentado anteriormente, (*Constantes*: *Marco*, *C√©sar*; *Variables*: $x$, $y$, $x_1$, ...; *Funciones*: f(C√©sar), f(x), f(f(x))):

```elm{l context="8"}

import Modules.SintaxSemanticsLPO exposing (..)

cesar = Func "cesar" []

marco = Func "marco" []

x = Var "x"

x_1 = Var "x_1"

f_cesar = Func "f" [cesar]

f_f_cesar = Func "f" [Func "f" [cesar]]
```

Ahora que ya podemos definir t√©rminos en LPO podemos pasar a ver la definici√≥n de f√≥rmulas. Si recordamos, las f√≥rmulas est√°n definidas con una estructura recursiva, de forma que las f√≥rmulas corresponden o bien a √°tomos (*caso base*), o bien a la aplicaci√≥n de las conectivas y/o cuantificadores sobre otras f√≥rmulas (*caso recursivo*).

Bien, pues la implementaci√≥n dada en la librer√≠a para las f√≥rmulas sigue fielmente dicha definici√≥n. De forma que: (definiendo el tipo *Variable* como alias de *Term*)

    type alias Variable = Term

    type FormulaLPO = Pred String (List Term)
                    | Equal Term Term
                    | Neg FormulaLPO
                    | Conj FormulaLPO FormulaLPO
                    | Disj FormulaLPO FormulaLPO
                    | Impl FormulaLPO FormulaLPO
                    | Equi FormulaLPO FormulaLPO
                    | Exists Variable FormulaLPO
                    | Forall Variable FormulaLPO
                    | Insat

De forma que esto nos permite expresar sint√°cticamente todas las f√≥rmulas en LPO. Para los ejemplos expuestos:

```elm{l context="9"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)


f1 : FormulaLPO
f1 = Pred "P" [Func "cesar" []]

```

^^^elm{m=(toLatexFLPO f1) context="9"}^^^

```elm{l context="9"}

f2 : FormulaLPO
f2 = Pred "L" [Func "cesar" [], Func "marco" []]

```

^^^elm{m=(toLatexFLPO f2) context="9"}^^^


```elm{l context="9"}

f3 : FormulaLPO
f3 = Pred "IA" [Func "cesar" [], Func "f"  [Var "x"]]

```

^^^elm{m=(toLatexFLPO f3) context="9"}^^^

```elm{l context="9"}

f4 : FormulaLPO
f4 = Forall (Var "x") (Exists (Var "y") (Pred "L" [Var "x", Var "y"]))

```

^^^elm{m=(toLatexFLPO f4) context="9"}^^^

```elm{l context="9"}

f5 : FormulaLPO
f5 = Forall (Var "x") (Impl (Pred "R" [Var "x"]) (Disj (Pred "L" [Var "x",Func "cesar" []]) (Pred "O" [Var "x",Func "cesar" []])))

```

^^^elm{m=(toLatexFLPO f5) context="9"}^^^

$\longrightarrow$ <u>Definici√≥n de f√≥rmulas LPO con Parser (M√≥dulo *IO_LPO*)</u>

Aunque ya podemos definir todas las f√≥rmulas en LPO, su escritura resulta una tarea muy pesada, para aliviar esa carga se ha desarrollado un Parser que permite la lectura de f√≥rmulas a partir de una cadena de texto en el que las f√≥rmulas se escriben de forma an√°loga a como se dan en el lenguaje formal de la l√≥gica. Se establecen algunas reglas sint√°cticas en su uso:

- Las <u>variables</u> se escriben con una letra en min√∫scula seguidas de caracteres alphanum√©ricos o el s√≠mbolo '_'. Algunos ejemplos: *'x'* , *'x_1'*, *'x1'*, ...

- Las *funciones* se definen siguiendo la notaci√≥n prefija, seg√∫n el patr√≥n:<br><br>

    <center><i> [S√≠mbolo de funci√≥n] [par√°metros]</i></center>

    Tal que: <br><br>

    - El *s√≠mbolo de funci√≥n* debe comenzar por el car√°cter '_', seguido de una serie de caracteres, entre estos se admiten caracteres alfanum√©ricos y tambi√©n s√≠mbolos, excepto '[', ']', '(', ')', '{', '}', ',', ';'. <br><br>

    - En los *par√°metros* se pueden dar 2 casos, o bien la funci√≥n corresponde a una <u>constante</u> y por tanto no tiene par√°metros, con lo cual bastar√≠a escribir el s√≠mbolo de funci√≥n (ejemplos: *'_a'*, *'_PEDRO'*, *'_1'*) o bien es una <u>funci√≥n</u> (dependiente de, al menos, un t√©rmino), en tal caso los argumentos se dan en una lista acotada por corchetes ('[', ']') y tras cada argumento ha de ir un ';' (ejemplos: *'_f[x;]'*, *'_g[x;y;]'*, *'_+[x;\_1;\_¬∑[y;\_2;]]'*).

- Los <u>predicados</u> se definen utilizando la notaci√≥n prefija seg√∫n el patr√≥n:<br><br>

    <center><i> [s√≠mbolo de predicado] [par√°metros]</i></center>

    Tal que: <br><br>

    - El *s√≠mbolo de predicado* debe comenzar por un car√°cter en may√∫scula o un s√≠mbolo (exceptuando '_',  '!', '(', ')', '[', ']', '}', '}' (tambi√©n se admiten d√≠gitos num√©ricos pero no se recomienda), seguido de una serie de caracteres, entre estos se admiten caracteres alfanum√©ricos y tambi√©n s√≠mbolos (exceptuando '(', ')', '[', ']', '}', '}'). Son palabras reservadas (y por tanto no se pueden usar como predicados) *"NOT", "AND", "OR", "IMPLIES", "EQUIV", "EXISTS", "FORALL", "INSAT"* <br><br>

    - En los *par√°metros* se pueden dar 2 casos, o bien la funci√≥n es un <u>predicado proposicional</u> (no tiene par√°metros), con lo cual bastar√≠a escribir el s√≠mbolo de predicado (ejemplos: *'P'*, *'Q\_1'*) o bien es un <u>predicado n-ario</u> (dependiente de, al menos, un par√°metro), en tal caso los argumentos se dan en una lista acotada por corchetes ('[', ']') y tras cada argumento ha de ir un ';' (ejemplos:'P[x;]', '>=[x;y;]', 'MAX[x;\_1;\_¬∑[y;\_2;]]').<br><br>

    Hay una excepci√≥n, *predicado de igualdad* (binaria) se utilizar√° de forma infija separando los t√©rminos con el s√≠mbolo '=' (ejemplos: 'x=y' , 'x\_4=\_3', '\_f[x;]=\_f[y;]') (El predicado de igualdad es de uso exclusivamente binario).

    <center><i> [t√©rmino] = [t√©rmino]</i></center><br><br>

- Los <u>cuantificadores</u> se expresan de forma an√°loga al lenguaje formal de LPO seg√∫n el patr√≥n:

    <center><i> [s√≠mbolo de cuantificador] [variable] [f√≥rmula]</i></center><br><br>

    Tal que: <br><br>

    - Los *s√≠mbolos de cuantificadores* corresponden a:

    <table style="margin-left: auto; margin-right: auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Cuantificador</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">S√≠mbolo Logicus</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Existencial (‚àÉ)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'EXISTS'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Universal (‚àÄ)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'FORALL'</td></tr></tbody></table><br>

    - La *variable* debe ir entre llaves ('{', '}'), respetando las reglas establecidas para la definici√≥n de variables.<br><br>

    - La *f√≥rmula* escrita respetando los criterios dados para la escritura de las f√≥rmulas.<br><br>


 - Las conectivas se usar√°n de forma infija (salvo para la *negaci√≥n*),  utilizando los siguientes s√≠mbolos, manti√©ndose la prioridad de las conectivas definida (en el orden de prioridad descendente expuesto en la tabla).

<table style="margin-left: auto; margin-right: auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Conectiva</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">S√≠mbolo Logicus</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Negaci√≥n (¬¨)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'NOT'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Conjunci√≥n (‚àß)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'AND'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Disyunci√≥n (‚à®)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'OR'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Implicaci√≥n (ü°í)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'IMPLIES'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Equivalencia (ü°ò)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'EQUIV'</td></tr></tbody></table><br>

- Los par√©ntesis se utilizan de igual forma en que se han definido en el lenguaje formal de la l√≥gica proposicional, con los s√≠mbolos '(' y ')'. No son necesarios los par√©ntesis externos de las f√≥rmulas.<br><br>

- En caso de uso repetido de una misma conectiva y/o cuantificador, se realizar√° asociaci√≥n por la derecha.<br><br>

Al igual que ocurr√≠a en el Parser de LP una vez le√≠da la f√≥rmula con la funci√≥n *fromStringToFLPO* es necesario extraerla utilizando la funci√≥n *extractReadFLPO*.

Vamos a mostrar algunos ejemplos de definici√≥n de las f√≥rmulas utilizando el Parser de LPO.

- Ejemplo 1: $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$

```elm{l context="10"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)

f1 : FormulaLPO
f1 = fromStringToFLPO "FORALL{x}(R[x;] IMPLIES (L[x;_cesar;] OR O[x; _cesar;]))" |> extractReadFLPO

-- Ejecutamos (toLatexFLPO f1) para mostrar la f√≥rmula
```

Que corresponde a:

^^^elm{m=(toLatexFLPO f1) context="10"}^^^

- Ejemplo 2 (tomando el lenguaje matem√°tico), definamos la propiedad biyectiva. Para expresarla consideremos el siguiente lenguaje: $L= \{O, I, f\}$, tal que:

    - $O$ es un predicado de aridad 1 que expresa si el objeto pertenece al conjunto origen.

    - $I$ es un predicado de aridad 1 que expresa si el objeto pertenece al conjunto imagen.

    - $f$ es una funci√≥n que dado un elemento del conjunto origen obtiene el correspondiente elemento del conjunto imagen y dado un elemento del conjunto imagen obtiene el correspondiente del conjunto origen.

    La propiedad biyectiva se formula como: <br><br>

    <center><i> Una relaci√≥n es biyectiva si para todo elemento del conjunto origen existe un √∫nico elemento del conjunto imagen con el que est√° relacionado y todo elemento del conjunto imagen est√° relacionado con alg√∫n elemento del origen</i></center><br>

    Esto es: $$ \forall x,y \in O \, (x \neq y \rightarrow f(x) \neq f(y)) \wedge \forall x \in I \, \exists y \in O \, (f(x)=y)$$<br>

    ```elm{l context="10"}

    biyectiva : FormulaLPO
    biyectiva = fromStringToFLPO
                    "FORALL{x} FORALL{y} (O[x;] AND O[y;] AND NOT (x=y) IMPLIES NOT (_f[x;]=_f[y;])) AND FORALL{x}(I[x;] IMPLIES EXISTS{y}(O[y;] AND _f[y;]=x))"
                |> extractReadFLPO

    -- Ejecutamos (toLatexFLPO biyectiva) para mostrar la f√≥rmula
    ```

    ^^^elm{m=(toLatexFLPO biyectiva) context="10"}^^^

    $\longrightarrow$ <u>√Årboles de formaci√≥n LPO en Logicus</u>

    La librer√≠a tambi√©n permite la representaci√≥n de los √°rboles de formaci√≥n LPO. La funci√≥n *formtree* (del m√≥dulo *IO_LPO*) muestra la representaci√≥n del √°rbol de formaci√≥n en formato texto DOT, de forma an√°loga a como lo hac√≠a en el caso de LP

    Por ejemplo para la f√≥rmula $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$:

    ```elm {l context="11"}
    import Modules.IO_LPO exposing (..)
    import Modules.SintaxSemanticsLPO exposing (..)
    import Modules.AuxForLitvis exposing (showGraphViz)

    f : FormulaLPO
    f = fromStringToFLPO "FORALL{x}(R[x;] IMPLIES (L[x;_cesar;] OR O[x; _cesar;]))" |> extractReadFLPO

    ft_f : String
    ft_f = formTree f
    ```
    De forma que se obtiene:

    ^^^elm {m=(showGraphViz "G2" ft_f) context="11"}^^^

##### Alcance de los cuantificadores, FBF, clausura de f√≥rmulas y renombramiento de variables.

Hemos estudiado la sint√°xis formal de las f√≥rmulas, pero a√∫n faltan algunos detalles por completar para establecer qu√© f√≥rmulas est√°n bien formadas y cu√°les no. Un tema importante es el tratamiento de la cuantificaci√≥n, esto es, a qu√© aparciones u ocurrencias (denominadas estancias) de una variable afecta un cuantificador.

> Una ocurrencia de una variable est√° afectada por un cuantificador (se dice que es una **estancia u ocurrencia ligada**) si hay un cuantificador sobre dicha variable actu√°ndo sobre la (sub)f√≥rmula que la contiene. En otro caso diremos que se trata de una **estancia u ocurrencia libre**

Para comprenderlo mejor vamos a explicar un ejemplo:

$$ \underbrace{\forall x}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {1}}}} \, \boxed{( P(\underbrace{x}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{x ligada}\end{array}}, \underbrace{y}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{y libre}\end{array}}) \rightarrow  \underbrace{\exists y}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {2}}}} \, \boxed{R(\underbrace{y}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{y ligada}\end{array}}, \underbrace{x}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{x ligada}\end{array}})}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {2}}}} )}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {1}}}}$$

En la f√≥rmula podemos apreciar que el cuantificador, $\forall x$, afecta a toda la f√≥rmula siguiente, por tanto todas las ocurrencias de $x$ que aparezcan en la f√≥rmula ser√°n ocurrencias ligadas. Sin embargo, $P(x,y)$ no est√° afectado por ning√∫n otro cuantificador, por tanto, la ocurrencia de $y$ en $P(x,y)$ es libre. Por otra parte, $R(x,y)$ s√≠ est√° afectado por el cuantificador $\exists y$,  por tanto tanto la ocurrencia de $x$ como la de $y$ en $R(y, x)$ son ligadas.

De forma similar se definen las variables *libres* y *ligadas* como:

> Una variable $x$ se dice **varible libre** en una f√≥rmula $F$ si existe alguna ocurrencia libre de $x$ en $F$. <br>
Una variable $x$ se dice **varible ligada** en una f√≥rmula $F$ si existe alguna ocurrencia ligada de $x$ en $F$.

De forma que en una f√≥rmula una variable puede ser al mismo tiempo *variable libre* y *variable ligada*.

Por ejemplo, en la f√≥rmula anterior $x$ es una variable *exclusivamente cerrada* (todas sus ocurrencias son ligadas), sin embargo $y$ es una variable *libre* y *ligada* (hay una ocurrencia libre y otra ligada).

En base a los conceptos anteriores se definen los conceptos:

> Se dice que un **t√©rmino** es **cerrado** si no contiene ninguna variable.

Por ejemplo: $C√©sar$, $f(Marco)$, $f(f(C√©sar))$; son t√©rminos cerrados en el lenguaje $LR$.

> Se dice que una **f√≥rmula** es **cerrada** si no contiene variables libres, o equivalentemente si todas las estancias de todas las variables son ligadas.

Por ejemplo las f√≥rmulas $\forall x (L(x, C√©sar) \vee O(C√©sar, x))$, $\forall x L(x, C√©sar) \rightarrow \neg \exists y O(C√©sar, y)$ son una *f√≥rmulas cerradas*, mientras que las f√≥rmulas $\forall x L(x, C√©sar) \vee O(C√©sar, x)$ , $\forall x L(x, C√©sar) \rightarrow \neg \exists y IA(y, x)$ no lo son.

> Se dice que una **f√≥rmula** es **abierta** si no contiene cuantificadores, esto es todas las variables son, exclusivamente, *variables libres*.

Por ejemplo son f√≥rmulas abiertas $P(x)$, $R(C√©sar)$, $P(x) \leftrightarrow \neg IA(f(x), Marco)$.

Incidiremos m√°s en este aspecto cuando ve√°mos la sem√°ntica en LPO.

$\longrightarrow$ <u>F√≥rmulas bien formadas y renombramiento de variables</u>

Aunque las f√≥rmulas est√©n bien escritas sint√°cticamente, incluso aunque sean cerradas, es posible que su interpretaci√≥n sea ambigua, esta ambig√ºedad suele venir dada por un mal uso de los cuantificadores y las variables, por ejemplo tengamos la f√≥rmula:

$$\forall z\,\forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, \boxed{z}\right) \wedge P\left(x, y\right) \right) \right) \right)$$

La ocurrencia de $z$ se√±alada, es claramente ligada, pero ¬øa qu√© cuantificador?

> Diremos que una **f√≥rmula** est√° **bien formada** (*FBF* o *WFF*) si es correcta sint√°cticamente y no contiene dos cuantificadores anidados actuando sobre la misma variable.

Claramente, la **f√≥rmula** presentada no est√° **bien formada** y hay una ambig√ºedad en la interpretaci√≥n de la f√≥rmula, para resolver dicha ambig√ºedad vamos a adoptar el siguiente criterio:

"Una ocurencia est√° ligada (si es que lo est√°) al cuantificador de nivel superior m√°s cercano en el √°rbol de formaci√≥n"

De forma que la ocurrencia anterior la tomaremos ligada al existencial. N√≥tese que en el √°rbol de formaci√≥n es el cuantificador referido a $z$ de orden superior m√°s cercano:

<center> <img src="images/T1Img6.png" title="√Årbol formaci√≥n (ejemplo)"></center><br>

Adem√°s de adoptar un criterio, podemos, mejor, realizar un renombramiento de las variables, manteniendo el sentido original de las f√≥rmulas, de forma que la f√≥rmula anterior podr√≠amos renombrarla mejor como:
$$\forall z_1\,\forall x_1\,\exists y_1\,\left( P\left(x_1, y_1\right)\rightarrow \left( P\left(x_1, z_1\right) \vee \exists z_2\,\left( P\left(y_1, z_2\right) \wedge P\left(x_1, y_1\right) \right) \right) \right)$$

No es el √∫nico caso en el que es necesario renombrar las variables, por ejemplo, tengamos la f√≥rmula:

$$\forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, \raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {$z$}}}\right) \vee \exists z\,\left( P\left(y, \boxed{z}\right) \wedge P\left(x, y\right) \right) \right) \right)$$

La primera ocurrencia de $z$ se√±alada es libre y la segunda es ligada, claramente el mismo s√≠mbolo de variable representa objetos distintos, lo que produce una cierta ambig√ºedad en la f√≥rmula. Sin embargo, podemos renombrar la f√≥rmula como:
$$\forall x_1\,\exists y_1\,\left( P\left(x_1, y_1\right)\rightarrow \left( P\left(x_1, z\right) \vee \exists z_1\,\left( P\left(y_1, z_1\right) \wedge P\left(x_1, y_1\right) \right) \right) \right)$$

De forma que desaparece toda posible ambig√ºedad.

N√≥tese que para renombrar se ha escogido el siguiente criterio : *Se renombrar√°n todas las ocurrencias ligadas de cada variable a√±adiendo el sub√≠ndice correspondiente seg√∫n el orden y cardinalidad de aparici√≥n del cuantificador (sobre dicha variable) al que est√° ligada dicha ocurrencia (tomando el orden seg√∫n el recorrido en profundidad del $AF$ de la f√≥rmula)*

$\longrightarrow$ <u>Clausura de las f√≥rmulas LPO.</u>

Los algoritmos de decisi√≥n que vamos a estudiar trabajan √∫nicamente sobre f√≥rmulas cerradas, por lo que hemos de *clausurar* todas aquellas f√≥rmulas que no sean cerradas, cuantificando las variables libres de la f√≥rmula (aplicando un renombramiento sobre aquellas variables que sean, simult√°neamente, libres y ligadas).

Se admiten dos tipos de clausura para las f√≥rmulas:

- <u>Clausura universal</u> se trata de cerrar la f√≥rmula a base de cuantificar universalmente (por la izquierda) las variables libres de las f√≥rmulas. Si $v_1, \ldots, v_n$ corresponden a las variables libres de una f√≥rmula $F$, la clausura universal de la f√≥rmula corresponde a la f√≥rmula $\forall v_1 \ldots \forall v_n \, F$

- <u>Clausura existencial</u> se trata de cerrar la f√≥rmula a base de cuantificar existencialmente (por la izquierda) las variables libres de las f√≥rmulas. Si $v_1, \ldots, v_n$ corresponden a las variables libres de una f√≥rmula $F$, la clausura universal de la f√≥rmula corresponde a la f√≥rmula $\exists v_1 \ldots \exists v_n \, F$

Veremos algunas cuestiones m√°s sobre este aspecto cuando veamos la *Sem√°ntica en LPO*.

$\longrightarrow$ <u>F√≥rmulas abiertas/cerradas, FBF, renombramiento y clausura de f√≥rmulas en Logicus</u>

La librer√≠a Logicus permite, en el m√≥dulo *SintaxSemanticsLPO* trabajar con los conceptos que hemos estado viendo.

$-$ *Variables libres y ligadas*

Recordemos que una variable es libre/ligada si existe alguna ocurrencia de dicha variable que sea libre/ligada. En la librer√≠a Logicus las funciones *varIsFreeInFLPO* y *varIsLinkedInFLPO* resuelven este aspecto:

    varIsFreeInFLPO : Variable -> FormulaLPO -> Bool
    varIsFreeInFLPO v f=
        case f of
            Pred _ terms -> List.member v (varsInListTerm terms)
            Equal t1 t2 -> List.member v (varsInListTerm [t1, t2])
            Neg p -> varIsFreeInFLPO v p
            Conj p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Disj p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Impl p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Equi p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Exists var p -> not(var == v) && varIsFreeInFLPO v p
            Forall var p -> not(var == v) && varIsFreeInFLPO v p
            Insat -> True

    varIsLinkedInFLPO : Variable -> FormulaLPO -> Bool
    varIsLinkedInFLPO v f=
        case f of
            Pred _ _ -> False
            Equal _ _ -> False
            Neg p -> varIsLinkedInFLPO v p
            Conj p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Disj p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Impl p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Equi p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Exists var p -> (var == v && List.member v (varsInFormula p)) || varIsLinkedInFLPO v p
            Forall var p -> (var == v && List.member v (varsInFormula p)) || varIsLinkedInFLPO v p
            Insat -> False

De forma que podemos preguntar, por ejemplo si las variables $x$, $y$, $z$ son libres y/o ligadas en $$F: \exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la f√≥rmula

```elm {l context="12"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f = fromStringToFLPO "EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{z} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO
```
2. Preguntamos si cada una de las variables son libres/ligadas:

```elm {l context="12"}
isxF = varIsFreeInFLPO (Var "x") f
isxL = varIsLinkedInFLPO (Var "x") f
```
^^^elm {m=("Es $x$ libre? " ++ (toString isxF) ++ "<br>Es $x$ ligada? " ++ (toString isxL) ) context="12"}^^^

```elm {l context="12"}
isyF = varIsFreeInFLPO (Var "y") f
isyL = varIsLinkedInFLPO (Var "y") f
```
^^^elm {m=("Es $y$ libre? " ++ (toString isyF) ++ "<br>Es $y$ ligada? " ++ (toString isyL) ) context="12"}^^^

```elm {l context="12"}
iszF = varIsFreeInFLPO (Var "z") f
iszL = varIsLinkedInFLPO (Var "z") f
```
^^^elm {m=("Es $z$ libre? " ++ (toString iszF) ++ "<br>Es $z$ ligada? " ++ (toString iszL) ) context="12"}^^^


$-$ *F√≥rmulas abiertas y cerradas*

Recordemos que una f√≥rmula es abierta si todas sus variables son exclusivamente abiertas, o equivalentemente si no contiene cuantificadores. Y una f√≥rmula es cerrada si todas sus variables son exclusivamente cerradas. En la librer√≠a Logicus las funciones *isOpenFLPO* y *isClosedFLPO* resuelven este aspecto:

    isOpenFLPO : FormulaLPO -> Bool
    isOpenFLPO f =
    case f of
        Pred _ _ -> True
        Equal _ _ -> True
        Neg p -> isOpenFLPO p
        Conj p q -> isOpenFLPO p && isOpenFLPO q
        Disj p q -> isOpenFLPO p && isOpenFLPO q
        Impl p q -> isOpenFLPO p && isOpenFLPO q
        Equi p q -> isOpenFLPO p && isOpenFLPO q
        Exists _ _ -> False
        Forall _ _ -> False
        Insat -> True

    isClosedFLPO : FormulaLPO -> Bool
    isClosedFLPO f = List.all (\v -> varIsLinkedInFLPO v f) (varsInFormula f)

De forma que podemos preguntar, por ejemplo, si las f√≥rmulas $F$, $G$ y $H$ son abiertas, cerradas o ninguna de las dos:

 $$ F: L(x, C√©sar) \vee O(C√©sar, y)$$ $$G: \forall x \, L(x, C√©sar) \vee \exists y \, O(C√©sar, y)$$ $$H: \forall x \, L(x, C√©sar) \vee O(C√©sar, y)$$

 1. Definimos las f√≥rmulas

 ```elm {l context="13"}

 import Modules.SintaxSemanticsLPO exposing (..)
 import Modules.IO_LPO exposing (..)
 import Bool.Extra exposing (toString)

 f : FormulaLPO
 f =  fromStringToFLPO "L[x;_C√©sar;] OR O[_C√©sar; y;]" |> extractReadFLPO

 g : FormulaLPO
 g =  fromStringToFLPO "FORALL{x} L[x;_C√©sar;] OR EXISTS{y} O[_C√©sar; y;]" |> extractReadFLPO

 h : FormulaLPO
 h =  fromStringToFLPO "FORALL{x} L[x;_C√©sar;] OR O[_C√©sar; y;]" |> extractReadFLPO

 ```

 2. Preguntamos si cada una de las f√≥rmulas son abiertas/cerradas:

 ```elm {l context="13"}
 isOF = isOpenFLPO f
 isCF = isClosedFLPO f
 ```
 ^^^elm {m=("Es $F$ abierta? " ++ (toString isOF) ++ "<br>Es $F$ cerrada? " ++ (toString isCF) ) context="13"}^^^

 ```elm {l context="13"}
 isOG = isOpenFLPO g
 isCG = isClosedFLPO g
 ```
 ^^^elm {m=("Es $G$ abierta? " ++ (toString isOG) ++ "<br>Es $G$ cerrada? " ++ (toString isCG) ) context="13"}^^^

 ```elm {l context="13"}
 isOH = isOpenFLPO h
 isCH = isClosedFLPO h
 ```
 ^^^elm {m=("Es $H$ abierta? " ++ (toString isOH) ++ "<br>Es $H$ cerrada? " ++ (toString isCH) ) context="13"}^^^

$-$ *F√≥rmulas bien formadas  y renombramiento de variables.*

Recordemos que consideramos una f√≥rmula bien formada a aquella que es sint√°cticamente correcta y que no contiene cuantificadores anidados sobre una misma variable. La funci√≥n *checkWFF* permite comprobar si una f√≥rmula est√° bien formada o no:

    checkWFF : FormulaLPO -> Bool
    checkWFF x = checkWFFAux x []

    checkWFFAux : FormulaLPO -> List Variable -> Bool
    checkWFFAux x ls =
        case x of
            Pred _ _ -> True
            Equal _ _-> True
            Neg p -> checkWFFAux p ls
            Conj p q -> checkWFFAux p ls && checkWFFAux q ls
            Disj p q -> checkWFFAux p ls && checkWFFAux q ls
            Impl p q -> checkWFFAux p ls && checkWFFAux q ls
            Equi p q -> checkWFFAux p ls && checkWFFAux q ls
            Exists v p -> not(List.member v ls) && checkWFFAux p ls && checkWFFAux p (ls ++ [v])
            Forall v p -> not(List.member v ls) && checkWFFAux p ls && checkWFFAux p (ls ++ [v])
            Insat -> True

Recordemos el criterio que establecimos en el renombramiento de variables: *Se renombrar√°n todas las ocurrencias ligadas de cada variable a√±adiendo el sub√≠ndice correspondiente seg√∫n el orden y cardinalidad de aparici√≥n del cuantificador (sobre dicha variable) al que est√° ligada dicha ocurrencia (tomando el orden seg√∫n el recorrido en profundidad del $AF$ de la f√≥rmula)*

En la librer√≠a, la funci√≥n *renameVars* que permite renombrar las variables de una f√≥rmula siguiendo este mismo criterio:

    renameVars : FormulaLPO -> FormulaLPO
    renameVars f = Tuple.first <| renameVarsAux f  Dict.empty

    renameVarsAux : FormulaLPO -> Dict String Int -> (FormulaLPO, Dict String Int)
    renameVarsAux f vars =
        let varsSub = Dict.map (\ k v ->  Var (k ++ "_" ++ String.fromInt v)) vars in
            case f of
                Pred n terms ->  (Pred n <| List.map (\ t -> applySubsToTerm varsSub t) terms, vars)
                Equal t1 t2 -> (Equal (applySubsToTerm varsSub t1) (applySubsToTerm varsSub t2), vars)
                Neg p ->  
                    let
                        (f1, d1) = renameVarsAux p vars
                    in
                        (Neg f1 , d1)
                Conj p q ->
                    let
                        (f1, d1) = renameVarsAux p vars
                    in
                        let
                            (f2,d2) = renameVarsAux q d1
                        in
                            (Conj f1 f2, d2)
                Disj p q ->
                    let
                        (f1, d1) = renameVarsAux p vars
                    in
                        let
                            (f2,d2) = renameVarsAux q d1
                        in
                            (Disj f1 f2, d2)
                Impl p q ->
                    let
                        (f1, d1) = renameVarsAux p vars
                    in
                        let
                            (f2,d2) = renameVarsAux q d1
                        in
                            (Impl f1 f2, d2)
                Equi p q ->
                    let
                        (f1, d1) = renameVarsAux p vars
                    in
                        let
                            (f2,d2) = renameVarsAux q d1
                        in
                            (Equi f1 f2, d2)
                Exists v p ->
                    let
                        vSymb = getVarSymb v
                    in
                        let
                            vNewIndex = (Maybe.withDefault 0 <| Dict.get vSymb vars) + 1
                        in
                            let
                                newVars = Dict.insert vSymb vNewIndex vars
                            in
                                let
                                    (f1, d1) = renameVarsAux p newVars
                                in
                                    (Exists (Var (vSymb ++ "_" ++ String.fromInt vNewIndex)) f1, d1)
                Forall v p ->
                    let
                        vSymb = getVarSymb v
                    in
                        let
                            vNewIndex = (Maybe.withDefault 0 <| Dict.get vSymb vars) + 1
                        in
                            let
                                newVars = Dict.insert vSymb vNewIndex vars
                            in
                                let
                                    (f1, d1) = renameVarsAux p newVars
                                in
                                    (Forall (Var (vSymb ++ "_" ++ String.fromInt vNewIndex)) f1, d1)
                Insat -> (Insat, vars)

*NOTA: La funci√≥n 'applySubsToTerm' la veremos cuando estudiemos las sustituciones (en el siguiente apartado)*.

De forma que podemos aplicar las funciones anteriores al siguiente ejemplo, tal que : $$F: \forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists y\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la f√≥rmula:

```elm {l context="14"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f =  fromStringToFLPO "FORALL{x} EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{y} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO

```

2. Ve√°mos si est√° bien formada:

```elm {l context="14"}
isWFF_F = checkWFF f
```

^^^elm {m=("Est√° $F$ bien formada? " ++ (toString isWFF_F) ) context="14"}^^^

3. Aplicamos el renombramiento de variables:

```elm {l context="14"}
f2 = renameVars f
```

^^^elm {m=((toLatexFLPO f2)) context="14"}^^^

4. Comprobemos si $F_2$ est√° bien formada:

```elm {l context="14"}
isWFF_F2 = checkWFF f2
```

^^^elm {m=("Est√° $F$ bien formada? " ++ (toString isWFF_F2) ) context="14"}^^^

$-$ *Clausura de las f√≥rmulas*

Como ya hemos comentado los m√©todos que vamos a estudiar se basan en el trato de f√≥rmulas cerradas, por lo que cuando las f√≥rmulas no lo son, es necesario clausurarlas universal o existencialmente. La librer√≠a Logicus implementa ambos m√©todos de clausura en las funciones *universalClausureFLPO* y *existencialClausureFLPO*.

    universalClausureFLPO : FormulaLPO -> FormulaLPO
    universalClausureFLPO f = renameVars <| universalClausureFLPOAux f (List.filter (\ v -> varIsFreeInFLPO v f) <| varsInFormula f)

    universalClausureFLPOAux : FormulaLPO -> List Variable -> FormulaLPO
    universalClausureFLPOAux f ls =
        case ls of
            [] -> f
            x::xs -> universalClausureFLPOAux (Forall x f) xs

    existencialClausureFLPO : FormulaLPO -> FormulaLPO
    existencialClausureFLPO f = renameVars <| existencialClausureFLPOAux f (List.filter (\ v -> varIsFreeInFLPO v f) <| varsInFormula f)

    existencialClausureFLPOAux : FormulaLPO -> List Variable -> FormulaLPO
    existencialClausureFLPOAux f ls =
        case ls of
            [] -> f
            x::xs -> existencialClausureFLPOAux (Exists x f) xs

De forma que, si tenemos la f√≥rmula: $$F: \exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la funci√≥n

```elm {l context="15"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f =  fromStringToFLPO "EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{z} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO

```

2. La clausura universal de la f√≥rmula corresponder√≠a a:

```elm {l context="15"}
f2 = universalClausureFLPO f
```

^^^elm {m=((toLatexFLPO f2)) context="15"}^^^

2. La clausura existencial de la f√≥rmula corresponder√≠a a:

```elm {l context="15"}
f3 = existencialClausureFLPO f
```

^^^elm {m=((toLatexFLPO f3)) context="15"}^^^

#### Sustituciones en LPO

> Una sustituci√≥n (finita) o simplemente **sustituci√≥n**, **$\theta$** corresponde a una funci√≥n que asigna a un conjunto finito de variables un conjunto finito de t√©rminos  $\theta(x_i)=t_i \, (i=1,\ldots, n)$. Se denomina *dominio* de la funci√≥n al conjunto de variables que no permanecen invariantes ante la sustituci√≥n, esto es, $dom(\theta) = \{x_i / \theta(x_i) \neq x_i\}$.
>
> Para denotar una sustituci√≥n, lo hacemos por $\theta=\{x_1/t_1, \ldots, x_n/t_n\}$ o tambi√©n $\theta=\{(x_1,t_1), \ldots, (x_n,t_n)\}$.

##### Aplicaci√≥n de sustituciones a t√©rminos.

La aplicaci√≥n de una sustituci√≥n a un t√©rmino consiste en intercambiar las variables que participan en dicho t√©rmino seg√∫n la correspondencia que establece la sustituci√≥n y se denota por $\theta(t)$ o tambi√©n $t\{x_1/t_1, \ldots, x_n/t_n\}$. Formalmente: $$\theta(t) = \left\lbrace \begin{array}{lll} \theta(x_i) & si \, t=x_i & [t \textit{ es una variable}]\\ f(\theta(t_1), \ldots, \theta(t_m)) & si \, t=f(t_1, \ldots, t_m) & [t \textit{ es una funci√≥n de aridad } m ]\\  \end{array}\right.$$

Por ejemplo, tengamos la sustituci√≥n $\theta = \{x/(x+y), z/\boldsymbol{0}, u/\boldsymbol{1}\}$ y el t√©rmino $t=(x+y)+z$, de esta forma tendr√≠amos $\theta(t)=((x+y) + y) + \boldsymbol{0}$.

N√≥tese el car√°cter simult√°neo de la susutituci√≥n, esto es, la sustituci√≥n de todos las variables se realiza simult√°neamente de forma que **no** se tiene  $\{x_i/x_j, x_j/t_j\} \equiv \{x_i/t_j, x_j/t_j\}$. Por ejemplo, tengamos el t√©rmino del ejemplo anterior y la sustituci√≥n $\theta_2 = \{x/(x+y), y/\boldsymbol{0}\}$, entonces: $$((x+y)+z)\{x/(x+y), y/\boldsymbol{0}\} \neq ((x+\boldsymbol{0})+\boldsymbol{0})+z$$ $$((x+y)+z)\{x/(x+y), y/\boldsymbol{0}\} = ((x+y)+\boldsymbol{0})+z$$

##### Aplicaci√≥n de sustituciones a f√≥rmulas.
La aplicaci√≥n de una sustituci√≥n a un t√©rmino consiste en intercambiar todas las ocurrencias **libres** de las variables del dominio de la sustituci√≥n en $F$ por los t√©rminos que les corresponden en la sustituci√≥n. Se denota por $\theta(F)$ o tambi√©n $F\{x_1/t_1, \ldots, x_n/t_n\}$ de forma que:

$$\theta(F) \equiv \left\lbrace \begin{array}{ll} P(\theta(t_1), \ldots, \theta(t_n)) & si \, F\equiv P(t_1, \ldots, t_n)\\ \neg \theta(G) & si \, F \equiv \neg G \\ \theta(G) \wedge \theta(H) & si \, F \equiv G \wedge H \\ \theta(G) \vee \theta(H) & si \, F \equiv G \vee H \\ \theta(G) \rightarrow \theta(H) & si \, F \equiv G \rightarrow H \\ \theta(G) \leftrightarrow \theta(H) & si \, F \equiv G \leftrightarrow H \\ \exists x \, G\{x_i/t_i : x_i \in dom(\theta) \wedge x_i \neq x\} & si \, F \equiv \exists x  \, G \\ \forall x \, G\{x_i/t_i : x_i \in dom(\theta) \wedge x_i \neq x\} & si \, F \equiv \forall x  \, G \\ \end{array}\right.$$

 $\longrightarrow$ <u>Sustituciones admisibles</u>

 No toda sustituci√≥n es admisible para una f√≥rmula, por ejemplo, t√©ngase la f√≥rmula $F \equiv \exists x \, \neg(x=y)$ y t√©ngase la sustituci√≥n $\theta = \{y/x\}$, entonces $\theta(F) = \exists x \neg (x=x)$. Claramente el sentido de la f√≥rmula ha cambiado, mientras que en la primera f√≥rmula se establece que debe haber, al menos, dos objetos distintos en la segunda se tiene que existe al menos un objeto que es distinto de s√≠ mismo (que es sencillamente falso.)

 De esta forma:

 > Una variable, $x_i \in dom(\theta)$, de una f√≥rmula, $F$, es sustituible por el t√©rmino correspondiente, $t_i$, si y s√≥lo si la aplicaci√≥n de la sustituci√≥n, $\theta(F)$ no produce nuevas ocurrencias ligadas.

 Formalmente, una variable $x_i$ de $F$ es sustituible por $t_i$ si se da alguna de las siguientes condiciones:

 1. $F$ es at√≥mica.
 2. $F  \equiv \neg G$ y $x_i$ es sustituible por $t_i$ en $G$
 3. $F  \equiv G \left( \wedge | \vee | \rightarrow | \leftrightarrow \right) H$ y $x_i$ es sustituible por $t_i$ en $G$ y en $H$.
 4. $F \equiv \exists x G$ tal que o bien $(x=x_i)$, o bien $(x \neq x_i) \wedge (x \textit{ no ocurre en } t_i) \wedge (x_i \textit{ es sustituible en G})$.
 5. $F \equiv \forall x G$ tal que o bien $(x=x_i)$, o bien $(x \neq x_i) \wedge (x \textit{ no ocurre en } t_i) \wedge (x_i \textit{ es sustituible en G})$.

 De ahora en adelante, cuando escribamos $F\{x/t\}$ supondremos que $x$ es sustituible por $t$ en $F$.

 [*NOTA:* Si dada una f√≥rmula $F(x_1, \ldots, x_n)$, el orden de las variables est√° claro podemos abreviar $F\{x_1/t_1, \ldots, x_n/t_n\}$ por $F(t_1, \ldots, t_n)$]

 $\longrightarrow$ <u>Sustituciones en Logicus</u>

Seg√∫n lo estudiado, las sustituciones establecen una correspondencia entre dos elementos, incluso notadas como un conjunto de pares variable-t√©rmino. Esto es directamente expresable en el *Elm* como *List Variable Term*, incluso si tomamos √∫nicamente las *Strings* de las variables podr√≠amos expresarlo como *List String Term* o mejor como *Dict String Term* (que no permite elementos repetidos en la clave (*String*)):

    type alias Substitution = Dict String Term

De forma que podemos definir una sustituci√≥n a trav√©s de la funci√≥n *Dict.fromList*. Por ejemplo, definamos la sustituci√≥n $\theta = \{x/(x+y), z/\boldsymbol{0}, u/z\}$

```elm {l context="16"}
import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Dict exposing (..)

theta : Substitution
theta =  Dict.fromList [("x", Func "+" [Var "x", Var "y"]), ("z", Func "0" []), ("u", Var "z")]

```
Aunque no resulta demasiado engorrosa esta definici√≥n de las sustituciones se ha provisto un parser en la funci√≥n *fromStringToSubstitutionLPO* para poder definir m√°s c√≥modamente las sustituciones siguiendo la notaci√≥n seg√∫n el patr√≥n:
<center><i>{[variable] / [t√©rmino], [variable] / [t√©rmino], ..., [variable] / [t√©rmino]}</i></center>

Tal que:

- Se nota como una secuencia escrita entre llaves y separada por comas.
- Los elementos de la secuencia corresponden a pares variable t√©rmino, separados por ' / ', de forma que la variable ha de seguir los criterios dados, anteriormente, para la sint√°xis de variables y los t√©rminos, an√°logamente, la sint√°xis dada para la definici√≥n de t√©rminos.

As√≠ la sustituci√≥n anterior se puede dar como:

```elm {l context="16"}

theta2 : Substitution
theta2 =  fromStringToSubstitutionLPO "{x/_+[x;y;], z/_0 , u/z}" |> extractReadSubstitutionLPO

```

^^^elm {m=(Debug.toString(theta2)) context="16"}^^^

*(NOTA: Recu√©rdese que las constantes se defini√≠an como funciones sin argumentos, esto seguidas de un espacio.)*

$-$ *Aplicaci√≥n de sustituciones a funciones*

La librer√≠a Logicus provee la funci√≥n *applySubsToFormula* que permite aplicar una sustituci√≥n a una f√≥rmula siguiendo los criterios estudiados anteriormente. Dada la definici√≥n recursiva de sustituci√≥n y t√©rmino la implementaci√≥n es directamente la aplicaci√≥n de esa definici√≥n, tanto para los t√©rminos como para las f√≥rmulas.

    applySubsToVar : Substitution -> Variable -> Term
    applySubsToVar s x = Maybe.withDefault x <| Dict.get (getVarSymb x) s

    applySubsToTerm : Substitution -> Term -> Term
    applySubsToTerm s t=
        case t of
            Var _ -> applySubsToVar s t
            Func sf ts -> Func sf (List.map (\term -> applySubsToTerm s term) ts)

    applySubsToFormula : Substitution -> FormulaLPO -> FormulaLPO
    applySubsToFormula s f =
        case f of
            Pred n ts ->  Pred n <| List.map (\t -> applySubsToTerm s t) ts
            Equal t1 t2 -> Equal (applySubsToTerm s t1)  (applySubsToTerm s t2)
            Neg p ->  Neg <| applySubsToFormula s p
            Conj p q -> Conj (applySubsToFormula s p) (applySubsToFormula s q)
            Disj p q -> Disj (applySubsToFormula s p) (applySubsySubsToFormula : SubstitToFormula s q)
            Impl p q -> Impl (applySubsToFormula s p) (applySubsToFormula s q)
            Equi p q -> Equi (applySubsToFormula s p) (applySubsToFormula s q)
            Exists v p ->
                let
                    s2 = Dict.filter (\ k _ -> k /=  getVarSymb v) s
                in
                    Exists v (applySubsToFormula s2 p)
            Forall v p ->  
                let
                    s2 = Dict.filter (\ k _ -> k /=  getVarSymb v) s
                in
                    Forall v (applySubsToFormula s2 p)
            Insat -> Insat

De forma que, por ejemplo, para aplicar la sustituci√≥n  $\theta = \{x/(x+y), y/\boldsymbol{0}, u/\boldsymbol{1}\}$ a la f√≥rmula $F \equiv Z(x) \wedge Z(y) \rightarrow \exists z \, ((x¬∑y)=z \wedge Z(z))$ (*el producto de n√∫meros enteros es interno*).

```elm {l context="17"}
import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Dict exposing (..)

f : FormulaLPO
f = fromStringToFLPO "Z[x;] AND Z[y;] IMPLIES EXISTS{z} ((_¬∑[x;y;]=z) AND Z[z;])" |> extractReadFLPO

theta : Substitution
theta =  fromStringToSubstitutionLPO "{x/_+[x;y;], y/_0 , z/_0}" |> extractReadSubstitutionLPO

f2 = applySubsToFormula theta f
```
^^^elm {m=(toLatexFLPO f2) context="17"}^^^

### Sem√°ntica de la L√≥gica de Primer Orden

Vista la forma en la que se escriben y se leen las f√≥rmulas en la L√≥gica de Primer, el objetivo de la sem√°ntica es dotar de significado a los t√©rminos y f√≥rmulas de un Lenguaje de Primer Orden. Para ello vamos a ver los elementos que conforman la sem√°ntica:

> Sea $L$ un lenguaje de primer orden. Una **$L$‚Äìestructura** (o $interpretaci√≥n$) corresponde a un par $\mathcal{M}= (M, I)$ donde $M$ es un conjunto no vac√≠o llamado **universo** (o dominio) de la $L$-estructura e $I$ es una aplicaci√≥n tal que:
>1. Aporta una interpretaci√≥n para cada constante, dicha interpretaci√≥n se denota por $c^{\mathcal{M}}$, de forma que $\forall c \in L: \, c^\mathcal{M} \in M$. Esto es, a cada constante le asigna uno y s√≥lo uno de los elementos del universo.
>2. Aporta una interpretaci√≥n para cada uno de los s√≠mbolos de funci√≥n en $L$, tal que si $f$ corresponde a un s√≠mbolo de funci√≥n $n$-aria ($n>0$): $f^{\mathcal{M}} : M^{n} \longrightarrow M$
>3. Aporta una interpretaci√≥n booleana para cada uno de los s√≠mbolos de predicado en $L$, tal que si $P$ corresponde a un s√≠mbolo de predicado $n$-ario: $f^{\mathcal{M}} : P^{n} \longrightarrow \{0,1\}$, O equivalente se puede dar una interpretaci√≥n de que conjuntos $n$-arios cumplen dicho predicado de forma que $P^{n} \subseteq M^{n} $.
>En caso de trabajar con un LPO con igualdad: $=^{\mathcal{M}}: \{(a,a): a \in M\} $.

(Para facilitar la lectura, si no hay ambig√ºedad escribiremos $M$ en vez de $\mathcal{M}$)

Vamos a exponer algunos ejemplos de $L$-estructuras.

Tomemos el lenguaje $LA = \{\underbrace{\boldsymbol{0}, \boldsymbol{1}}_{const.}, \overbrace{<^{\left(2\right)} , =^{\left(2\right)}}^{pred.}, \underbrace{¬∑^{\left(2\right)}, +^{\left(2\right)}}_{func.}\}$

Una $L$-estructura podr√≠a ser: $$ \mathcal{M_1} = \left\lbrace\begin{array}{l} M_1 = \mathbb{N} \\ \boldsymbol{0}^{M_1} = 0; \boldsymbol{1}^{M_1} = 1; \\ +^{M_1} : \mathbb{N^2} \longrightarrow \mathbb{N}, \, +^{M_1}(n_1, n_2) =  n_1 + n_2 \\ ¬∑^{M_1} : \mathbb{N^2} \longrightarrow \mathbb{N}, \, ¬∑^{M_1}(n_1, n_2) =  n_1 ¬∑ n_2 \\ <^{M_1} : \mathbb{N^2} \longrightarrow Bool, \, <^{M_1} = \{(i,j): (i,j) \in \mathbb{N^2} \wedge (i < j)\}  \\  =^{M_1} : \mathbb{N^2} \longrightarrow Bool, =^{M_1} = \{(i,i) : i \in \mathbb{N}\}  \\ \end{array}\right.$$

Pero otra podr√≠a corresponder a: $$ \mathcal{M_2} = \left\lbrace\begin{array}{l} M_2 = \mathbb{Q} \\ \boldsymbol{0}^{M_2} = \frac{1}{2}; \boldsymbol{1}^{M_2} = 2; \\ +^{M_2} : \mathbb{Q}^2 \longrightarrow \mathbb{Q}, \, +^{M_2}(n_1, n_2) =  | n_1 - n_2 | \\ ¬∑^{M_2} : \mathbb{Q}^2 \longrightarrow \mathbb{Q}, \, ¬∑^{M_2}(n_1, n_2) =  n_1 \\ <^{M_2} : \mathbb{Q}^2 \longrightarrow Bool, \, <^{M_2} = \{(i,j): (i,j) \in \mathbb{Q^2} \wedge (i ¬∑ j > 0)\}  \\  =^{M_2} : \mathbb{Q^2} \longrightarrow Bool, =^{M_2} = \{(i,i) : i \in \mathbb{N}\}  \\ \end{array}\right.$$

Recordemos que el predicado de igualdad es invariante en cualquier $L$-estructura y expresa la igualdad entre objetos.

$\longrightarrow$ <u>$L$-estructuras en logicus</u>

Como hemos se√±alado una $L$-estructura se compone de 2 elementos un universo y una interpretaci√≥n, de forma que:

    type alias L_estructure a = (Universe a , Interpretation a)

El universo correspond√≠a a un conjunto de objetos:

    type alias Universe a = List a

Las interpretaciones corresponden a la definici√≥n de aplicaciones de $U^n \longrightarrow U$ para los s√≠mbolos de funciones y $U^n \longrightarrow Bool$ para los s√≠mbolos de predicados. Luego:

    type alias Interpretation a =
        { i_const : Dict String a
         , i_funct : Dict String ((List a) -> a)
         , i_pred : Dict String ((List a) -> Bool)
        }

Esto nos permite definir toda $L$-estructura sobre universos finitos, por ejemplo, tomando el lenguaje de la aritm√©tica y la $L$-estructura (de forma que cada elemento del universo tiene asociada la constante correspondiente):

$$ \mathcal{M} = \left\lbrace\begin{array}{l} M = \mathbb{N_{10}} \\ +^{M} : \mathbb{(N_{10})^2} \longrightarrow \mathbb{N_{10}}, \, +^{M}(n_1, n_2) =  n_1 + n_2 \\ ¬∑^{M} : \mathbb{(N_{10})^2} \longrightarrow \mathbb{N_{10}}, \, ¬∑^{M}(n_1, n_2) =  n_1 ¬∑ n_2 \\ <^{M} : \mathbb{(N_{10})^2} \longrightarrow Bool, \, <^{M}(n_1, n_2) = n_1 < n_2  \\  =^{M} : \mathbb{(N_{10})^2} \longrightarrow Bool, =^{M}(n_1, n_2) = (n_1 = n_2)  \\ \end{array}\right.$$

Recordemos que el predicado de igualdad no necesita definici√≥n y que las constantes en logicus tambi√©n se definen como funciones, de forma que:

```elm {l context="18"}

import Modules.SintaxSemanticsLPO exposing (..)
import Modules.IO_LPO exposing (..)
import Dict exposing (..)

m : Universe Int
m = [0,1,2,3,4,5,6,7,8,9,10]

isuma : List Int -> Int
isuma ls = List.sum ls

iprod : List Int -> Int
iprod ls = List.product ls

imenor : List Int -> Bool
imenor ls=
  case ls of
    [x,y] -> x < y
    _ -> False

i : Interpretation Int
i = { i_const = Dict.fromList <| List.map (\x -> (String.fromInt x, x)) m
    , i_funct = Dict.fromList [("+", isuma), ("¬∑", iprod)]
    , i_pred = Dict.fromList [("<", imenor)]}

m_estr : L_estructure Int
m_estr = (m, i)
```
^^^elm {m=(Debug.toString m_estr) context="18"}^^^

#### Interpretaci√≥n de las f√≥rmulas en LPO.

Antes de explicar la interpretaci√≥n de las f√≥rmulas vamos ver c√≥mo se interpretar los t√©rminos que las conforman:

> Dada una $L$-estructura $\mathcal{M}$ a cada t√©rmino t√©rmino $t$ de $L$, **sin variables** , le corresponde un objeto o elemento de $M$, que viene dado por la interpretaci√≥n de la $L$-estructura ($t^{\mathcal{M}}$), de forma que: $$t^{\mathcal{M}} = \left\lbrace \begin{array}{ll} c^{\mathcal{M}} & \textrm{si } t \equiv c \, (\textrm{con } c=cte) \\ f^{\mathcal{M}}(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) & \textrm{si } t \equiv f(t_1, \ldots, t_n) \end{array}\right.$$

De forma que una vez interpretados los t√©rminos, podemos llevar a cabo la interpretaci√≥n de las f√≥rmulas, de forma que:

> Dada una $L$-estructura $\mathcal{M}$ decimos que una f√≥rmula **cerrada**, $F$, se satisface en $\mathcal{M}$ (y se denota por $\mathcal{M} \models F$) si se da alguno de los siguientes supuestos:
> 1. $F \equiv P(t_1, \ldots, t_n)$ y adem√°s $P^{\mathcal{M}}(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) = True$ o, equivalentemente, $(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) \in P^\mathcal{M}$
> 2. $F \equiv \neg F_1$ y adem√°s $\mathcal{M} \not \models F_1$
> 3. $F \equiv F_1 \vee F_2$ y se tiene que  $\mathcal{M} \models F_1$ o  $\mathcal{M} \models F_2$ (an√°logo para el resto de conectivas).
> 4. $F \equiv \exists x \, F_1$ y adem√°s hay alg√∫n elemento $e \in M$ (representado por el t√©rmino $e$) tal que $\mathcal{M} \models F_1\{x/e\}$.
> 5. $F \equiv \forall x \, F_1$ y adem√°s todo elemento $e \in M$ (representado por el t√©rmino $e$) verifica $\mathcal{M} \models F_1\{x/e\}$.

En caso de que $F$ no sea cerrada se tiene, por definici√≥n:

$$\left( \mathcal{M} \models F \right) \Leftrightarrow \left(\mathcal{M} \models \forall{x_1, \ldots, x_n} F(x_1, \ldots, x_n)\right)$$

$\longrightarrow$ <u>Interpretaci√≥n de t√©rminos y f√≥rmulas en Logicus</u>

Acudiendo a la definici√≥n expuesta:

    interpretsTerm : Term -> Interpretation a ->  Maybe a
    interpretsTerm t i =
        case t of
            Var _ -> Nothing
            Func s [] -> Dict.get s i.i_const
            Func s args ->         
                let f = Dict.get s i.i_funct in
                    case f of
                        Nothing -> Nothing
                        Just x ->
                            let ls = List.map (\t2 -> interpretsTerm t2 i) args in
                                if List.any isNothing ls then
                                    Nothing
                                else
                                    Just <| x (values ls)

(Recu√©rdese que s√≥lo se admiten interpretaciones sobre t√©rminos sin variables, luego, si en un t√©rmino aparecen variables no es posible realizar su interpretaci√≥n por lo que el objeto devuelto corresponde a un objeto vac√≠o.)

An√°logamente, seg√∫n la definici√≥n recursiva dada para la interpretaci√≥n de las f√≥rmulas:

    interpretsFLPO : FormulaLPO -> L_estructure a -> Maybe Bool
    interpretsFLPO f estr = interpretsFLPOAux (universalClausureFLPO f) estr

    interpretsFLPOAux : FormulaLPO -> L_estructure a -> Maybe Bool
    interpretsFLPOAux f (m,i) =
        case f of
            Pred sp terms ->
                let ip = Dict.get sp i.i_pred in
                    case ip of
                        Nothing -> Nothing
                        Just x ->
                            let ls = List.map (\t -> interpretsTerm t i) terms in
                                if List.any isNothing ls then
                                    Nothing
                                else
                                    Just <| x (values ls)
            Equal t1 t2->
                let it1 = interpretsTerm t1 i
                    it2 = interpretsTerm t2 i
                in
                    if isNothing it1 || isNothing it2 then
                        Nothing
                    else Just  (it1 == it2)

            Neg f1 -> andThen (\if1 -> Just (not if1)) (interpretsFLPOAux f1 (m,i))
            Conj f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x && y)
            Disj f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x || y)
            Impl f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (not x || y)
            Equi f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x == y)
            Exists v f1 ->
                let ls = combine <| List.map (\o -> interpretsFLPOAux (applySubsToFormula (Dict.singleton (getVarSymb v) (Func o [])) f1) (m,i)) (Dict.keys i.i_const)in
                    case ls of
                        Nothing -> Nothing
                        Just li -> Just <| List.any (\x -> x) li
            Forall v f1 ->
                let ls = combine <| List.map (\o -> interpretsFLPOAux (applySubsToFormula (Dict.singleton (getVarSymb v) (Func o [])) f1) (m,i)) (Dict.keys i.i_const)in
                    case ls of
                        Nothing -> Nothing
                        Just li -> Just <| List.all (\x -> x) li
            Insat -> Just False

(De forma que la funci√≥n devolver√° un objeto vac√≠o si existe alg√∫n s√≠mbolo en la f√≥rmula que no est√© recogido en la $L$-estructura, por tanto imposible de interpretar).

Ve√°mos algunos ejemplos, probando si se cumplen algunas propiedades sobre el ejemplo anterior:

1. El elemento neutro de la suma es el 0: $\forall x \in \mathbb{N}_{10}: \, (x+0)=x$

```elm {l context="18"}

f1 = fromStringToFLPO "_+[x;_0;] = _0 " |> extractReadFLPO

-- Ejecutamos interpretsFLPO f1 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f1 m_estr) context="18"}^^^

2. Todo n√∫mero m√∫ltiplo de 4 es tambi√©n m√∫ltiplo de 2: $\forall x (\exists y (4¬∑y)=x \rightarrow \exists y (2¬∑y)=x)$

```elm {l context="18"}

f2 = fromStringToFLPO "FORALL{x} (EXISTS{y} (_¬∑[_4;y;] =x) IMPLIES EXISTS{y} (_¬∑[_2;y;] = x))" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f2 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f2 m_estr) context="18"}^^^

Sin embargo, el rec√≠proco no es cierto:

```elm {l context="18"}

f3 = fromStringToFLPO "FORALL{x} (EXISTS{y} (_¬∑[_2;y;] =x) IMPLIES EXISTS{y} (_¬∑[_4;y;] = x))" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f3 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f3 m_estr) context="18"}^^^

3. Ve√°mos que la suma no es interna, esto es, $\neg \forall x \forall y \exists z (z = (x+y))$

```elm {l context="18"}

f4 = fromStringToFLPO "NOT FORALL{x} FORALL{y} EXISTS{z} (z=_+[x;y;])" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f4 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f4 m_estr) context="18"}^^^

4. Ve√°mos que no se tiene que para todo n√∫mero existe uno que es mayor, $\forall x \exists y (x < y)$
```elm {l context="18"}

f5 = fromStringToFLPO "FORALL{x} EXISTS{y} (<[x;y;])" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f5 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f5 m_estr) context="18"}^^^

####  Satisfactibilidad, Validez y Consecuencia L√≥gica en LPO.

Igual que ve√≠amos que una f√≥rmula en LP es satisfactible si exist√≠a al menos un modelo, en LPO se dice que una f√≥rmula es **satisfactible** si existe, al menos, un modelo para dicha f√≥rmula, esto es si existe una $L$-estructura en la que se satisface ($\mathcal{M} \models F$). De forma an√°loga un conjunto de f√≥rmulas $\Sigma$ es **consistente** si existe una $L$-estructura tal que toda f√≥rmula de $\Sigma$ se satisface en $\mathcal{M}$

Una f√≥rmula se dice **l√≥gicamente v√°lida** si para toda $L$-estructura ($\mathcal{M}$) se tiene $\mathcal{M} \models F$ (por ejemplo, $\forall{x} P(x) \vee \exists x \neg P(x)$)

Por √∫ltimo, de igual forma que ve√≠amos el concepto de consecuencia l√≥gica en LP, en LPO se tiene que una f√≥rmula $F$ es **consecuencia l√≥gica** de un conjunto de f√≥rmulas $\Sigma$ (y se denota por $\Sigma \models F$) si se tiene que para toda $L$-estructura $\mathcal{M}$, $\mathcal{M} \models \Sigma \Rightarrow \mathcal{M} \models F$

Al contrario que en LP, en el que exist√≠an algoritmos (aunque ineficientes) que permit√≠an determinar los problemas de consistencia y consecuencia l√≥gica, en LPO este mismo problema no es decidible, esto es no existen algoritmos que permitan determinar, de forma completa, la consistencia de un conjunto de f√≥rmulas (equivalente al problema de la consecuencia l√≥gica).

Durante los siguientes temas estudiaremos algoritmos que tratar√°n de resolver el problema, aunque no sean decisivos en todos los casos.
