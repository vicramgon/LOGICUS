---
elm:
  source-directories:
    - ../../elm-sources/src
  dependencies:
      elm/browser: latest
      elm/core: latest
      elm/file: latest
      elm/html: latest
      elm/parser: latest
      elm-community/graph: latest
      elm-community/list-extra: latest
      elm-community/maybe-extra: latest
      munksgaard/char-extra: latest
      gicentre/elm-vegalite: latest
      avh4/elm-fifo: latest
      elm/bytes: latest
      elm/json: latest
      elm/time: latest
      elm/url: latest
      elm/virtual-dom: latest
      elm-community/intdict: latest
      Chadtech/elm-bool-extra: latest
---

<!-- Cargamos algunas funciones js que necesitamos -->

<script src="../js/d3.min.js"></script>
<script src="../js/viz.js" type="javascript/worker"></script>
<script src="../js/d3-graphviz.js"></script>
<script type="text/javascript">

    function plotDot(graphId){
        d3.select('#svgContainer' + graphId)
        .graphviz()
        .renderDot(document.getElementById("inDOT" + graphId).value.replace(/\\n/g, "\n").replace(/\\"/gm, '"'));
    
        document.getElementById("outputGraph" + graphId).style.display = "inline-block";
        document.getElementById("inputGraph" + graphId).style.display = "none";
    };
    
    function generatePng(graphId){
        var svgElement = document.getElementById('svgContainer' + graphId).querySelector('svg');
        var svgString = new XMLSerializer().serializeToString(svgElement);
        var canvas = document.getElementById("canvas" + graphId);
        canvas.width = svgElement.getBBox().width*1.33;
        canvas.height = svgElement.getBBox().height*1.33;
        var ctx = canvas.getContext("2d");
        var DOMURL = self.URL || self.webkitURL || self;
        var img = new Image();
        var svg = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});
        var url = DOMURL.createObjectURL(svg);
        img.onload = function() {
            ctx.drawImage(img, 0, 0);
            var png = canvas.toDataURL("image/png");
    
            document.querySelector("#pngContainer" + graphId).innerHTML = '<a id="downloadPNG'+ graphId +'" href="'+png+'" download/> PNG Image </a>';
            imgdownload = document.getElementById("downloadPNG"+ graphId)
            imgdownload.click();
            DOMURL.revokeObjectURL(png);
        };
        img.src = url;
    };
</script>


# Tema 1: Sintaxis y Semántica en LP y LPO

## Descripción general del capítulo

Como hemos visto en el tema anterior (LINK) hay varias posibles aproximaciones a la Lógica como herramienta formal para representar y formalizar tanto el conocimiento como los métodos de obtención de nuevas verdades de forma deductiva. En este sentido, nosotros vamos a considerar a lo largo de nuestra aproximación un problema que aúna estos esfuerzos dentro de lo que podemos considerar *el problema central de la deducción*, y que se puede expresar como sigue:

> *Dado un conjunto de asertos (afirmaciones que conforman nuestro conocimiento en un determinado ámbito),y que denotaremos por $\mathcal{BC}$ (por *Base de conocimiento*), y una afirmación adicional, $\mathcal{A}$, el problema central que queremos abordar es el de decidir si $\mathcal{A}$ ha de ser necesariamente cierta supuesto que son ciertas todas las afirmaciones de $\mathcal{BC}$.*


Si queremos tener la seguridad de que el problema anterior lo abordamos adecuadamente, es necesario disponer de los siguientes elementos:

-   Un lenguaje que permita expresar de manera formal y precisa las afirmaciones, hechos e hipótesis. (las reglas que establecen la corrección de las expresiones que usemos es lo que denominaremos como **Sintaxis**).

-   Una definición clara de qué se considera *afirmación cierta*  (las reglas que establecen la veracidad de las expresiones que usemos es lo que denominaremos como **Semántica**).

-   Mecanismos efectivos (y, en la medida de lo posible, eficientes) que garanticen la *corrección* (y, cuando sea posible, la *completitud*) de las deducciones obtenidas (estos mecanismos los daremos por medio de los que denominaremos **Algoritmos de decisión**).

A lo largo de los siguientes capítulos abordaremos estos puntos para las dos lógicas más comunes que se usan: la **Lógica Proposicional** (*LP*, o *PL*, por sus siglas en inglés) y la **Lógica de Primer Orden** (*LPO*, o *FOL*, por sus siglas en inglés).

Nuestro objetivo central en este primer capítulo será presentar los dos primeros elementos para estás lógicas, aunque veremos que esta tarea, de forma natural, nos permitirá introducirnos superficialmente (aunque, de forma muy fundamental desde el punto de vista conceptual) en el tercero de los elementos, pero serán los siguientes capítulos los que estén dedicados casi en su totalidad en el desarrollo de los algoritmos de decisión y otras técnicas que faciliten el camino hacia las soluciones que proporcionaremos para el problema central anterior.

### LogicUS

Pero la novedad que ofrece este texto frente a otras aproximaciones a la Lógica Proposicional y De Primer Orden es que iremos entrelazando los conceptos con una implementación computacional de todos los conceptos y métodos que iremos viendo a lo largo del texto. Así, en este capítulo veremos, de forma detallada, los módulos implementados que reflejan tanto la sintaxis como la semántica de ambas lógicas: 

-   **Módulo SintaxSemanticsLP**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sintácticos y semánticos de la LP.

-   **Módulo SintaxSemanticsLPO**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sintácticos y semánticos de la LPO.

-   **Módulo IO\_LP**. Recoge las implementaciones de los métodos relacionados con la lectura y representación de las fórmulas LP.

-   **Módulo IO\_LPO**. Recoge las implementaciones de los métodos relacionados con la lectura y representación de las fórmulas LPO.

Complementariamente, en el *Anexo A. Parsers* se ofrece el desarrollo de varias herramientas que permiten usar una escritura más natural de las fórmulas, más cercana a la que se usa en la representación matemática estándar.


## Fundamentos de Lógica Proposicional

Vamos a abordar desde un punto de vista teórico-práctico, los elementos base que conforman la Lógica Proposicional, esto es la Síntaxis y la Semántica, mostrando unificadamente los desarrollos formales y las implementaciones llevadas a cabo para modelar cada uno de ellos en LogicUS.

### Características fundamentales

La Lógica Proposicional comienza a desarrollarse en la Grecia antigua y, aunque su formalización puede haber variado a lo largo de los siglos para acondicionarla a los nuevos tiempo, esencialmente seguimos usando el mismo esquema sintáctico y bajo los mismos parámetros. Es la lógica más simple que podemos considerar, con unos elementos más rígidos que otras aproximaciones y, por tanto, ofreciendo una menor capacidad expresiva. Esta es la razón por la que ha sufrido ampliaciones (LPO es realmente una ampliación de LP, pero hay otras) que han tenido como objetivo  aplicar la lógica a problemas más complejos. Pero también es cierto que, gracias a esta simplicidad, presenta características que la hacen especialmente adecuada a su implementación computacional ya que, como veremos más adelante, disponemos de herramientas completas para su mainpulación sintáctica y semántica. 

Informalmente, las características más importantes que definen a la Lógica Proposicional son:

-   Sus expresiones (denominadas f*órmulas proposicionales* o *proposiciones*) modelan afirmaciones que pueden considerarse *ciertas* o *falsas*. No hay posibles estados intermedios ni distintos, cada afirmación del lenguaje solo tiene esas dos opciones.

-   Las fórmulas proposicionales (en adelante fórmulas, si no existe ambigüedad) se construyen mediante un conjunto de expresiones  básicas (*fórmulas atómicas* o *átomos*) y un conjunto de operadores (*conectivas lógicas*). Las conectivas disponibles permiten modelar los siguientes tipos de afirmaciones:

    -   *Conjunción*: ‘... tal ... Y ... cual ...’

    -   *Disyunción*: ‘... tal ... O ... cual ...’

    -   *Implicación*: ‘SI tal ... ENTONCES ... cual ...’

    -   *Equivalencia*: ‘... tal ... SI Y SÓLO SI ... cual ...’

    -   *Negación*: ‘NO es cierto tal ...’

    Profundizaremos en este aspecto en la próxima sección, cuando presentemos la *Sintaxis Formal de la LP*.

-   El lenguaje sólo permite modelar este tipo de afirmaciones, por lo que muchas veces puede ser difícil (o imposible) representar algunos problemas en este tipo de Lógica, y es necesario recurrir a otras formalizaciones más expresivas (como el propio *LPO*, las conocidas como *Lógicas Modales*, la *Lógica Difusa*, etc.). Veremos limitaciones específicas más adelante, que nos servirán para justificar las ampliaciones que aporta LPO.

-   Aunque esta Lógica puede resultar de una aparente sencillez, veremos que hay ciertos restos que ya aparecen en ella (como el problema *SAT*) y que caen dentro de la categoría de problemas **NP**-completos, esto es, problemas complejos para los que no se conocen algoritmos eficientes (en tiempo polinomial) para resolverlos. Trataremos de nuevo este aspecto en la introducción a los algoritmos de decisión. De hecho, $SAT$ fue el primer problema que se demostró matemáticamente dentro de esa clase de complejidad. 


### Sintáxis de la lógica Proposicional

#### El alfabeto proposicional

El concepto ‘*alfabeto proposicional*’ referencia al conjunto de símbolos que forman parte de este lenguaje. En la Lógica Proposicional podemos distinguir las siguientes categorías:

-   **Variables proposicionales** o **átomos**. Ya hemos señalado previamente que todo problema está representado por relaciones entre un conjunto finito de afirmaciones básicas, en LP estas afirmaciones se representan por símbolos proposicionales de un conjunto infinito: $VP = \{p_0, p_1, \ldots, p, q, r\}$. 

    Aunque formalmente no existe ninguna restricción, en LogicUS vamos a adoptar el siguiente criterio en relación a la sintaxis de los símbolos proposicionales:

    > Los símbolos proposicionales deben comenzar por una letra minúscula, seguida (opcionalmente) de otros caractéres en minúscula o dígitos numéricos, exclusivamente.

-   **Conectivas Lógicas**. Modelan las relaciones entre las distintas afirmaciones básicas (átomos) y, según el número de operandos sobre los que actúan (aridad), podemos distinguir:

    -   De aridad 1 (o monoaria) : *Negación* ($\neg$).

    -   De aridad 2 (o binarias): *Conjunción* ($\wedge$), *Disyunción* ($\vee$), *Condicional* ($\rightarrow$), *Bicondicional* ($\leftrightarrow$).

-   **Símbolos Auxiliares**: ‘$($’ y ‘$)$’. Permiten expresar relaciones de prioridad entre conectivas lógicas y evitar la ambigiüedad en la interpretación de las fórmulas.

#### Fórmulas Proposicionales

En todos los lenguajes formales una **expresión** es una sucesión finita (y no vacía) de símbolos del lenguaje. Por tanto, en el lenguaje de LP, tanto "$a \rightarrow b )ca\vee$" como "$(a \rightarrow b ) \vee c$" son expresiones. Sin embargo, parece claro que la segunda de ellas muestra “una coherencia” o “equilibrio" que no parece tener la primera, por lo que no todas las expresiones tienen el mismo valor para nosotros. De esta forma, a las expresiones "bien formadas", aquellas que muestran una coherencia informativa que podemos utilizar, las denominaremos **fórmulas proposicionales**, pero hay que dar algún procedimiento efectivo que permita diferenciar formalmente las expresiones bien formadas de las que no, así que podemos definir:

> Formalmente, el conjunto de las fórmulas proposicionales, $PROP$, es el menor conjunto de expresiones que verifica:
> - $VP \subseteq PROP$
> - Es cerrado bajo las conectivas lógicas, es decir:
    - Si una fórmula $F \in PROP$, entonces $\neg F \in PROP$
    - Si las fórmulas $F, G \in PROP$, entonces $(F \wedge G), (F \vee G), (F \rightarrow G), (F \leftrightarrow G) \in PROP$

Aunque esta definición puede resultar un poco oscura, nos ofrece un camino constructivo de reconocer las expresiones bien formadas de las que no lo son (formalmente, decimos que ofrece una definición recursiva): partiendo de las fórmulas bien construidas más pequeñas posibles, los átomos, podemos construir nuevas fórmulas más grandes bien construidas aplicando conectivas sobre una o dos fórmulas bien construidas más pequeñas (serán una o dos dependiendo de la aridad de la conectiva utilizada).

##### Árboles de formación

Siguiendo los pasos de construcción, cada fórmula se puede asociar a un grafo de tipo árbol (esencialmente único, salvo diferencias de orden), que muestra el desarrollo de formación de la fórmula.

Por ejemplo a la fórmula: $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$ tiene asociada el **árbol de formación** siguiente:

<center> <img src="images/T1Img1.png" title="Árbol formación (ejemplo)"></center><br>

Las distintas fórmulas que aparecen en los nodos del árbol de formación de una fórmula $F$ se denominan **subfórmulas** de $F$.

##### Prioridad de conectivas y Reducción de paréntesis.

Para facilitar la escritura y lectura de las fórmulas podemos adoptar algunos criterios adicionales que permitirán simplificar su expresión reduciendo el número de paréntesis que se usan en su representación formal:

1.  Omitimos los paréntesis más exteriores de la fórmula. Por ejemplo, $F\vee G$ es una representación alternativa de $(F\vee G)$.
2.  Tomaremos como orden de precedencia de las conectivas (de mayor a menor precedencia): $\neg$, $\wedge$, $\vee$ , $\rightarrow$, $\leftrightarrow$. Para la conectiva $\leftrightarrow$ se recomienda mantener los paréntesis en todos los casos. Por ejemplo, $F\wedge G \rightarrow H$ es una representación alternativa de $((F\wedge G) \rightarrow H)$).
3.  Cuando una conectiva se usa repetidamente, se asocia por la derecha. Por ejemplo, $F_1 \wedge F2 \wedge F_3$ es una representación alternativa de $(F_1 \wedge (F2 \wedge F_3))$.

##### Principio de inducción sobre fórmulas

Gracias a la definición de $PROP$ (y su estructura recursiva), para probar que toda fórmula proposicional satisface una cierta propiedad ($\Psi$), podemos hacerlo aplicando el método de inducción sobre fórmulas.

De esta forma, si queremos probar que todas las fórmulas de $PROP$ verifican $\Psi$ basta:

1.  *Caso base*: Probar que todos los elementos de $VP$ verifican la propiedad $\Psi$.

2.  *Paso de inducción*:
-  Si $F \in PROP$ verifica la propiedad $\Psi$, entonces $\neg F$ verifica la propiedad $\Psi$.
   
-  Si $F, G \in PROP$, verifican la propiedad $\Psi$ entonces $(F \wedge G)$, $(F \vee G)$, $(F \rightarrow G)$, $(F \leftrightarrow G)$  verifican la propiedad $\Psi$.

##### Escritura de las fórmulas en LogicUS

Vamos a exponer cuál es la sintaxis de las fórmulas utilizando la librería Logicus, que nos permitirá definir fórmulas y posteriormente aplicar diversos algoritmos sobre ellas.

En la librería podemos definir las fórmulas de dos formas distintas, o bien acudiendo directamente a los constructores internos de las fórmulas (un proceso largo y engorroso), o bien utilizando un Parser (más similar a la escritura natural de las fórmulas).

###### Definición de fórmulas

Si recordamos la definición recursiva que se ha dado para las fórmulas, expusimos que las mismas pueden corresponder o bien a átomos (*caso base*), o bien a la aplicación de las conectivas, teniendo en cuenta la aridad de éstas, sobre fórmulas proposicionales (*caso recursivo*).

Siguiendo el método constructivo asociado al árbol de formacion, la implementación para las fórmulas que la librería proporciona ofrece dos constructores para, respectivamente, generar átomos o aplicar conectivas:

- Los símbolos proposicionales se definen como cadenas de caractéres (con la restricción de que deben usar minúsculas):

        type alias PSymb = String

- Las fórmulas proposicionales se definen según la estructura recursiva dada por:

        type FormulaLP = Atom PSymb                 -- caso base
                        | Neg FormulaLP             --⎫
                        | Conj FormulaLP FormulaLP  --⎪
                        | Disj FormulaLP FormulaLP  --⎬ casos recursivos
                        | Impl FormulaLP FormulaLP  --⎪
                        | Equi FormulaLP FormulaLP  --⎭
                        | Insat                     -- fórmula insatisfactible

Para poder hacer uso de LogicUS previamente se deben importar los módulos correspondientes a las funciones y tipos necesarios. Por ejemplo, para definir las siguientes fórmulas en LogicUS:

a. $(p \wedge q) \vee (p \wedge r) \quad$ 

b. $ (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q \quad$ 

c. $(p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p$

Debemos escribir:

```elm {l context="1"}
import Logicus.IO_LP exposing (toLatexFLP)
import Logicus.SintaxSemanticsLP exposing (FormulaLP(..))

a : FormulaLP
a = Disj (Conj (Atom "p") (Atom "q")) (Conj (Atom "p") (Atom "r"))
```
^^^elm {m=(">" ++ toLatexFLP "a" a) context="1"}^^^

```elm {l context="1"}
b : FormulaLP
b = Impl (Disj (Conj (Atom "p") (Atom "r")) (Conj (Neg (Atom "p")) (Atom "q"))) (Neg (Atom "q"))
```

^^^elm {m=(">" ++ toLatexFLP "b" b) context="1"}^^^

```elm{l context="1"}
c : FormulaLP
c = Conj (Conj (Equi (Atom "p") (Atom "q")) (Impl (Atom "p") (Neg (Atom "q")))) (Atom "p")
```

^^^elm {m=(">" ++ toLatexFLP "c" c) context="1"}^^^

Desde luego, escribir las fórmulas de esta forma puede convertirse en una tarea ardua y propensa a errores, ya que es necesario construir previamente el árbol de formación y reproducirlo en el lenguaje. Por eso, se ha desarrollado un parser que permite escribir las fórmulas de forma más cómoda. Para poder utilizarlo se han establecido una serie de requisitos sintácticos, análogos a los presentados anteriormente:

- Los símbolos proposicionales deben comenzar por un caracter en minúscula seguido, opcionalmente, de caracteres en minúscula, dígitos o el símbolo '_'.
- Para las conectivas se usarán los siguientes símbolos en mayúsculas, mantiéndose la prioridad de las conectivas definida anteriormente.

|           Conectiva Lógica           | Símbolo LogicUS |
| :----------------------------------: | :-------------: |
|             ¬ (Negación)             |       NOT       |
|            ∧ (Conjunción)            |       AND       |
|            ∨ (Disyunción)            |       OR        |
|           🡒 (Implicación)            |     IMPLIES     |
| 🡘 (Doble Implicación o Equivalencia) |      EQUIV      |

- Los paréntesis se utilizan tal y como se han definido formalmente y se pueden evitar los que vegan determinados por las leyes de precedencia. No son necesarios los paréntesis externos de las fórmulas.

- En caso de uso repetido de una misma conectiva, se realizará asociación por la derecha.

Así, para definir los ejemplos expuestos anteriormente podríamos escribir:

```elm {l context="2"}
import Logicus.SintaxSemanticsLP exposing (FormulaLP(..))
import Logicus.IO_LP exposing (toLatexFLP, fromStringToFLP, extractReadFLP)

a : FormulaLP
a = fromStringToFLP "(p AND q) OR (p AND t)" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "a" a) context="2"}^^^
```elm{l context="2"}
b : FormulaLP
b = fromStringToFLP "(p AND r) OR (NOT p AND q) IMPLIES NOT q" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "b" b) context="2"}^^^
```elm{l context="2"}
c : FormulaLP
c = fromStringToFLP "(p EQUIV q) AND (p IMPLIES NOT q) AND p" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "c" c) context="2"}^^^

La función `fromStringToFLP` recibe una cadena de entrada y devuelve una tupla de dos elementos: el primero de ellos corresponde a la representación interna de la fórmula leída, y el segundo a una cadena de texto. Si la cadena de entrada contiene algún error sintáctico y no es una fórmula bien formada, el Parser no será capaz de interpretarla correctamente, y la función una tupla de la forma `(Nothing,error)`, donde el segundo elemento es el mensaje de error obtenido, y el primer elemento es un objeto vacío (porque no se ha generado una fórmula de salida).

Nota: En lo que sigue, haremos uso del parser para definir todas las fórmulas de los ejemplos que usemos.

Una vez leída la fórmula correctamente podemos extraerla utilizando la función *extractReadFLP*. Si se utiliza esta función sobre una fórmula leída incorrectamente, entonces se obtendrá como fórmula la fórmula insatisfactible.

######  Árboles de formación en LogicUS

La librería también permite obtener el árbol de formación de una fórmula. La función `formtree` genera la representación del árbol de formación en formato texto DOT.

Por ejemplo, para la fórmula $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$:

```elm {l context="3"}
import Logicus.IO_LP exposing (toLatexFLP, fromStringToFLP, extractReadFLP, formTree)
import Logicus.SintaxSemanticsLP exposing (FormulaLP(..))
import Logicus.AuxForLitvis exposing (showGraphViz)

a : FormulaLP
a = fromStringToFLP "NOT ( NOT (p OR q) IMPLIES (NOT r AND s))" |> extractReadFLP

fta : String
fta = formTree a
```
De forma que se obtiene:

^^^elm {m=(showGraphViz "G1" fta) context="3"}^^^

#### Conjuntos de fórmulas

Definido $PROP$, los conjuntos de fórmulas no son más que subconjuntos de $PROP$, esto es, corresponden a agrupaciones de fórmulas proposicionales.


##### Conjuntos de fórmulas en LogicUS

Los conjuntos proposicionales se definen como listas de fórmulas proposicionales:


    type alias LPSet = List FormulaLP

Si, por ejemplo, queremos definir el conjunto:
$$ M = \left\lbrace (p \wedge q) \vee (p \wedge r), (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q, (p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p \right\rbrace$$

Basta escribir:

```elm{l context="4"}
import Logicus.IO_LP exposing (..)
import Logicus.SintaxSemanticsLP exposing (..)

a : FormulaLP
a = fromStringToFLP "(p AND q) OR (p AND r)" |> extractReadFLP

b : FormulaLP
b = fromStringToFLP "(p AND r) OR (NOT p AND q) IMPLIES NOT q" |> extractReadFLP

c: FormulaLP
c = fromStringToFLP "(p EQUIV q) AND (p IMPLIES NOT q) AND p" |> extractReadFLP

m : LPSet
m = [a,b,c]
```

Obteniendo:

^^^elm{m=(toLatexLPSet m) context="4"}^^^

### Semántica de la Lógica Proposicional

#### Interpretaciones, Modelos, Satisfactibilidad y Validez Lógica

Tras haber visto la sintaxis, pasamos a presentar formalmente la semántica de la Lógica Proposicional. Como ya comentamos, hemos de abordar la interpretación de certeza o veracidad de las fórmulas. Para ello, previamente, hemos de introducir los conceptos de *valor de verdad* y *función de verdad*.

> -  **Valor de verdad**. Los elementos del conjunto $\{0,1\}$ se denominan valores de verdad o valores booleanos. Representan si un hecho es cierto o no, de forma que el valor $1$ se asocia a *verdadero* y el valor $0$ a *falso*.
>  -   **Funciones de verdad**. Formalmente, una función de verdad es una función que toma valores de verdad y devuelve un valor de verdad, es decir, $f:\{0,1\}^n\mapsto \{0,1\}$, y nos servirán para definir la semántica dentro de las lógicas booleanas. Así, el significado (valor de verdad asociado) de cada una de las conectivas lógicas viene dado por una función de verdad, de forma que:
      $$\begin{array}{l l} H_{\neg}(i) = \left\lbrace \begin{array}{l l}
        1 & \textrm{, si } i = 0\\
        0 & \textrm{, si } i = 1\\
        \end{array} \right. & H_{\wedge}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{, si } i = j = 1\\
        0 & \textrm{, e.o.c}\\
        \end{array} \right.\\\\ H_{\vee}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{, si } i = j = 0\\
        1 & \textrm{, e.o.c}\\
        \end{array} \right. & H_{\rightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{, si } i = 1, j = 0\\
        1 & \textrm{, e.o.c}\\
        \end{array} \right.\\\\ H_{\leftrightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{, si } i = j\\
        0 & \textrm{, e.o.c}\\
        \end{array} \right.\end{array}$$

Fijados unos valores de verdad de las variables proposicionales (es decir, una indicación acerca de cuáles son verdad y cuáles no), lo que se denomina una *valoración* o *interpretación*, podemos extender este valor para evaluar si las fórmulas proposicionales son ciertas o no bajo ese contexto. Para ello, basta usar el valor de las variables que intervienen en la fómrula y las funciones de verdad de las conectivas que contiene. Además, es fácil probar que esta extensión es única. Si $v: VP \mapsto \{0,1\}$ es la valoración actual de las variables proposicionales, entonces basta tener en cuenta las siguienets extensiones parciales:

$$\begin{array}{c c} v((F \wedge G))= H_{\wedge}(v(F), v(G)) & v((F \vee G))= H_{\vee}(v(F), v(G))\\\\ v((F \rightarrow G))= H_{\rightarrow}(v(F), v(G)) & v((F \leftrightarrow G))= H_{\leftrightarrow}(v(F), v(G)) \end{array}$$

Haciendo uso del árbol de formación de una fórmula, $F$, que ocupa el nodo raíz del árbol, podemos ir elevando los valores de $v$ desde las hojas hasta la raíz por los métodos anteriores, obteniendo un valor final para $F$ que representa el valor de verdad de la fórmula.

Por ejemplo el cálculo de la valoración de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$ (solo indicamos la valoración de las variables que intervienen en $F$):

<center> <img src="images/T1Img3.png" title="Cálculo de la valoración con el AF."></center><br>

> Dada una fórmula $F \in PROP$, se dice que $v(F)$ es el valor de verdad de $F$ respecto de la valoración $v$.

Muchas veces el conjunto de cálculos que se realizan en el árbol de formación se expresan de forma equivalente a partir de una tabla en la que se anotan en las cabeceras de las columnas las diversas subfórmulas que aparecen en el árbol, y bajo ellas los valores de verdad que toman al ir aplicando las funciones de verdad de las conectivas. Para el ejemplo anterior:

| $p$  | $q$  | $r$  | $s$  | $\neg r$ | $p\vee q$ | $\neg(p\vee q)$ | $\neg r \vee s$ | $\neg(p\vee q) \vee \neg(r\vee s)$ | $\neg(\neg(p\vee q)\vee(\neg r\vee s))$ |
| :--: | :--: | :--: | :--: | :------: | :-------: | :-------------: | :-------------: | :--------------------------------: | :-------------------------------------: |
|  1   |  1   |  0   |  0   |    1     |     1     |        0        |        1        |                 1                  |                    0                    |

##### Tablas de Verdad

Una **tabla de verdad** es una estructura similar a la anterior (nosotros sólo reflejaremos el valor de las variables proposicionales y el valor de verdad de la fórmula completa), en la que cada fila presenta una posible valoración (es decir, el valor concreto de las variables proposicionales que intervienen en la fórmula) y el valor de verdad de la fórmula respecto a ella.

La tabla de verdad de la fórmula anterior sería:

| $p$  | $q$  | $r$  | $s$  | $\neg(\neg(p\vee q)\vee(\neg r\vee s))$ |
| :--: | :--: | :--: | :--: | :-------------------------------------: |
|  0   |  0   |  0   |  0   |                    0                    |
|  0   |  0   |  0   |  1   |                    0                    |
|  0   |  0   |  1   |  0   |                    0                    |
|  0   |  0   |  1   |  1   |                    0                    |
|  0   |  1   |  0   |  0   |                    0                    |
|  0   |  1   |  0   |  1   |                    0                    |
|  0   |  1   |  1   |  0   |                    1                    |
|  0   |  1   |  1   |  1   |                    0                    |
|  1   |  0   |  0   |  0   |                    0                    |
|  1   |  0   |  0   |  1   |                    0                    |
|  1   |  0   |  1   |  0   |                    1                    |
|  1   |  0   |  1   |  1   |                    0                    |
|  1   |  1   |  0   |  0   |                    0                    |
|  1   |  1   |  0   |  1   |                    0                    |
|  1   |  1   |  1   |  0   |                    1                    |
|  1   |  1   |  1   |  1   |                    0                    |


##### Modelos, Satisfactibilidad y Validez Lógica

Las valoraciones determinan de alguna forma el *contexto del mundo*, es decir, qué afirmaciones atómicas son ciertas o no en una determinada configuración, y hemos visto que eso determina el valor de verdad de cualquier afirmación que se pueda hacer, sea atómica o no. Fijada una fórmula, habrá valoraciones en las que puede ser verdad, y otras valoraciones en las que posiblemente no lo sea. En este sentido, podemos dar las siguientes definiciones:

> -  **Modelo.** Se dice que una fórmula $F$ es **válida** en una valoración $v$ o, equivalentemente, que $v$ es **modelo** de $F$, si $v(F)=1$ y se denota por $v \models F$. En caso contrario, se dice que $v$ es **contramodelo** de $F$ y se denota por $v \not \models F$.
> - **Satisfactibilidad.** Una fórmula $F$ se dice **satisfactible** (o **consistente**) si existe una valoración $v$ que es modelo de $F$ (es decir, hay un mundo en el que la fórmula es verdadera). En caso contrario se dice que $F$ es **insatisfactible** (o **inconsistente**), y se denota por $\perp$.
> - **Validez lógica o Tautología**. Una fórmula $F$ se dice **tautología** (o [lógicamente] válida) si toda valoración es modelo de $F$, es decir, es cierta en cualquier mundo posible, y se denota $\models F$.

###### Relación entre Validez y Satisfactibilidad

> *LEMA*: Para cada $F \in PROP$ se verifica:
>
> -  Si $F$ es tautología, entonces $F$ es satisfactible.
> -  $F$ es tautología si y sólo si $\neg F$ es insatisfactible.

##### Semántica de Fórmulas LP en LogicUS

La librería dispone de funciones que modelan todos los conceptos semánticos que hemos visto hasta ahora.

###### Valores, Funciones de Verdad e Interpretaciones

Como hemos estudiado, los **valores de verdad** corresponden a 1 (*verdadero*) y 0 (*falso*). Elm ya provee esos valores booleanos en el tipo *Bool*, por lo que no es necesario realizar ninguna definición alternativa para este concepto.

Las definición de las funciones de verdad asociadas a las conectivas corresponden directamente a la aplicación de dichas funciones en la evaluación de las fórmulas. Antes de ver la evaluación resulta necesario ver la definición que se ha dado para las interpretaciones. Para ello, se ha elegido una representación "dispersa" que indica por medio de una lista los símbolos proposicionales de las variables proposicionales que son verdaderas. Las variables proposicionales asociadas a símbolos que no aparecen en la lista serán considerados como falsas.

    type alias Interpretation = List PSymb

Con esta definición resulta sencillo llevar a cabo la evaluación de las fórmulas siguiendo exactamente los dos pasos anotados:

- **Evaluación de variables**. Una variable será verdadera si pertenece a la lista de la interpretación, y será falsa en caso contrario.

- **Evaluación de conectivas**.

De forma que:

    valuation : FormulaLP -> Interpretation -> Bool
    valuation pr i =
        case pr of
            Atom p -> List.member p i
            Neg p -> not (valuation p i)
            Conj p q -> valuation p i &&  valuation q i
            Disj p q ->   valuation p i ||  valuation q i
            Impl p q ->   not (valuation p i) ||  valuation q i
            Equi p q ->   valuation (Impl p q) i &&  valuation (Impl q p) i
            Insat -> Basics.False

NOTA: nótese que la fórmula insatisfactible es falsa respecto de cualquier valoración.

Podemos usar esta función para calcular la valoración de una fórmula respecto de una valoración. Por ejemplo, calculemos la valoración de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$ basta hacer:

```elm{l context="5"}
import Logicus.IO_LP exposing (..)
import Logicus.SintaxSemanticsLP exposing (..)

f : FormulaLP
f = fromStringToFLP "NOT (NOT (p OR q) OR (NOT r OR s))" |> extractReadFLP

i : Interpretation
i = ["p", "q"]
```

^^^elm{r=(valuation f i) context="5"}^^^

###### Tabla de Verdad, Modelos, Satisfactibilidad y Validez

Como se ha expuesto anteriormente, una tabla de verdad recoge las valoraciones de una fórmula respecto a todas las posibles interpretaciones de sus símbolos proposicionales. En nuestro sistema, todas las posibles interpretaciones  que afectan a una fórmula proposicional se corresponde con todos los posibles subconjuntos del conjunto formado por los símbolos proposicionales que participan en la fórmula. De esta forma:

    symbInProp : FormulaLP -> Set.Set PSymb
    symbInProp f=
        case f of
            Atom p -> Set.singleton p
            Neg p -> symbInProp p
            Conj p q -> Set.union (symbInProp p ) (symbInProp q)
            Disj p q -> Set.union (symbInProp p ) (symbInProp q)
            Impl p q -> Set.union (symbInProp p ) (symbInProp q)
            Equi p q -> Set.union (symbInProp p ) (symbInProp q)
            Insat -> Set.empty
    
    allInterpretations : FormulaLP -> List Interpretation
    allInterpretations x =  Aux.powerset <| List.sort <| Set.toList <| symbInProp x

Y la tabla de verdad se corresponde con el conjunto de pares `(Interpretación, Valoración)`, aplicadas sobre todas las posibles interpretaciones:

    truthTable : FormulaLP -> List (Interpretation, Bool)
    truthTable x = List.map (\xs ->  (xs,valuation x xs)) <| allInterpretations x

Para el ejemplo anterior:

```elm{l context="6"}
import Logicus.IO_LP exposing (..)
import Logicus.SintaxSemanticsLP exposing (..)
import Logicus.AuxForLitvis exposing (showTable)
import Logicus.AuxiliarFunctions exposing (uncurry)
import Bool.Extra exposing (toString)

f : FormulaLP
f = fromStringToFLP "NOT (NOT (p OR q) OR (NOT r OR s))" |> extractReadFLP

-- Ejecutamos: truthTable f |> truthTableToMDFormat (symbInProp f) |> uncurry (showTable)
```

^^^elm{m=(truthTable f |> truthTableToMDFormat (symbInProp f) |> uncurry (showTable)) context="6"}^^^

Una vez calculadas todas las posibles interpretaciones resulta sencillo calcular los modelos y contramodelos de una fórmula proposicional, sin más que filtrar aquellos que sean evaluados como verdaderos o falsos, respectivamente. Es decir:

    models : FormulaLP -> List Interpretation
    models x = List.filter (\y -> valuation x y) (allInterpretations x)
    
    countermodels : FormulaLP -> List Interpretation
    countermodels x = List.filter (\y -> not(valuation x y)) (allInterpretations x)

Así pues, para la fórmula anterior, el conjunto de modelos y contramodelos correspondería a:

```elm{l context="6"}
modelos_f : List Interpretation
modelos_f =  models f
```

^^^elm{m=(interpretations2MDFormat modelos_f) context="6"}^^^

```elm{l context="6"}
contramodelos_f : List Interpretation
contramodelos_f = countermodels f
```

^^^elm{m=(interpretations2MDFormat contramodelos_f) context="6"}^^^

De forma análoga, resulta directo decidir la satisfactibilidad y validez de las fórmulas proposicionales sin más que comprobar si todas las interpretaciones hacen a la fórmula verdadera (*tautología*), si alguna de ellas la hace verdadera (*fórmula satisfactible*), o si no la hace ninguna de ellas (*fórmula insatisfactible*):


    satisfactibility : FormulaLP -> Bool
    satisfactibility x = List.any (\xs-> valuation x xs) (allInterpretations x)
    
    validity : FormulaLP -> Bool
    validity x = List.all (\xs-> valuation x xs) (allInterpretations x)
    
    insatisfactibility : FormulaLP -> Bool
    insatisfactibility x = List.all (\xs-> not(valuation x xs)) (allInterpretations x)

En el caso dela fórmula anterior, sabemos que es satisfactible ya que su conjunto de modelos no es vacío, y no es tautología ya que el de contramodelos tampoco lo es. Utilizando las funciones provistas por la librería:

```elm{l context="6"}

isSatisfactible_f : Bool
isSatisfactible_f = satisfactibility f
```
^^^elm{m=(toString isSatisfactible_f) context="6"}^^^

```elm{l context="6"}

isTaut_f : Bool
isTaut_f = validity f
```
^^^elm{m=(toString isTaut_f) context="6"}^^^

```elm{l context="6"}

isInsatisfactible_f : Bool
isInsatisfactible_f = insatisfactibility f
```

^^^elm{m=(toString isInsatisfactible_f) context="6"}^^^

#### Conjuntos de Fórmulas. Modelos y Consistencia

Podemos extender las definiciones anteriores a conjuntos de fórmulas:

>- **Modelo.** Se dice que una valoración $v$ es **modelo** de un conjunto de fórmulas $U$ si para toda fórmula $F \in U$ se tiene que $v(F)=1$, y se denota por $v \models U$. En caso contrario, se dice **contramodelo**.
> -   **Consistencia** Un conjunto de fórmulas $U$ se dice **consistente** si existe una valoración $v$ que es modelo de $U$. En caso contrario, se dice que $U$ es **inconsistente**.


##### Consecuencia Lógica

>Una fórmula $F$ es **consecuencia lógica** (o se sigue lógicamente) de un conjunto de fórmulas $U$, y se denota por $U \models F$, si todo modelo de $U$ es también modelo de $F$.

Es este concepto el que permitirá formalizar el problema básico inicial en el marco de la lógica proposicional, que planteamos como objetivo de la LP.

##### Relación entre consecuencia lógica, consistencia y validez

> *PROPOSICIÓN*: Sea $\{F_1, F_2, \ldots, F_n \} \subseteq PROP$ y $F \in PROP$ son equivalentes:
>
> - $\{F_1, F_2, \ldots, F_n \} \models F$
> - $(F_1 \wedge F_2 \wedge \ldots \wedge F_n) \rightarrow F \in TAUT$
> - $\{F_1 , F_2 , \ldots , F_n , \neg F\}$  es inconsistente.

##### Semántica de Conjuntos LP en LogicUS

Teniendo en cuenta que el lenguaje en el que se soporta LogicUS ademite el tipo de dato de conjunto, podemos extender también en la implementación el trabajo con conjuntos de fórmulas:

    setSymbols : List FormulaLP -> Set.Set PSymb
    setSymbols xs = List.foldr (\x acc -> Set.union acc (symbInProp x)) Set.empty xs
    
    allSetInterpretations : List FormulaLP -> List Interpretation
    allSetInterpretations xs = Aux.powerset <| Set.toList <| setSymbols xs

De esta forma, el cálculo de modelos, contramodelos, consistencia e inconsistencia se reduce a aplicar las definiciones sobre el conjunto de fórmulas:

    isSetModel : List FormulaLP -> Interpretation -> Bool
    isSetModel xs i =  List.all (\x -> valuation x i) xs
    
    allSetModels : List FormulaLP -> List Interpretation
    allSetModels xs = List.filter (isSetModel xs) (allSetInterpretations xs)
    
    allSetCounterModels : List FormulaLP -> List Interpretation
    allSetCounterModels xs = List.filter (\x -> not(isSetModel xs x)) <| allSetInterpretations xs
    
    isConsistent : List FormulaLP -> Bool
    isConsistent xs = List.any (\x -> isSetModel xs x) <| allSetInterpretations xs
    
    isInconsistent: List FormulaLP -> Bool
    isInconsistent xs = not(isConsistent xs)

###### Consecuencia lógica

Dada la definición de conseciencia lógica, y teniendo en cuenta la relación entre consecuencia lógica, consistencia y validez (último caso), LogicUS tiene varias vías para desarrollar el concepto de Consecuencia Lógica. Por ejemplo, a partir de la definición formal, o haciendo uso del tercer punto de la proposición anterior. Hemos optado por esta última vía, que tiene más aplicaciones directas a lo largo de desarrollos futuros.

    isConsecuence : List FormulaLP -> FormulaLP -> Bool
    -- isConsecuence xs x = List.all (\y -> valuation x y) <| allSetModels xs
    isConsecuence xs x = isInconsistent (xs ++ [Neg x])

Por ejemplo, dado el conjunto de fórmulas $U=\{p \rightarrow q,q \rightarrow p \wedge r\}$ y la fórmula $ F = p \rightarrow (p \rightarrow q) \rightarrow r$, veámos si se cumple $U \models F$:

```elm{l context="7"}
import Logicus.IO_LP exposing (..)
import Logicus.SintaxSemanticsLP exposing (..)
import Bool.Extra exposing (toString)

u1 : FormulaLP
u1 = fromStringToFLP "p IMPLIES q" |> extractReadFLP

u2 : FormulaLP
u2 =  fromStringToFLP "q IMPLIES p AND r" |> extractReadFLP

uSet : LPSet
uSet = [u1, u2]

f : FormulaLP
f = fromStringToFLP "p IMPLIES (p IMPLIES q) IMPLIES r" |> extractReadFLP

-- Ejecutamos toString <| isConsecuence uSet  f
```

^^^elm{m=(toString <| isConsecuence uSet  f) context="7"}^^^

De hecho, acudiendo a la definición podemos ver que, en efecto, todo modelo del conjunto $U$ es también modelo de la fórmula $F$.

```elm{l context="7"}
modelos_U : List Interpretation
modelos_U = allSetModels uSet

modelos_F : List Interpretation
modelos_F = models f

{-Ejecutamos:
    interpretations2MDFormat modelos_U
    interpretations2MDFormat modelos_F
  -}
```
Los modelos de $U$ son:

^^^elm{m=(interpretations2MDFormat modelos_U) context="7"}^^^

Y los modelos de $F$ son:

^^^elm{m=(interpretations2MDFormat modelos_F) context="7"}^^^

Donde podemos comprobar que, en efecto, todo modelo de $U$ es también modelo de $F$, luego $U\models F$.

### Algoritmos de decisión en LP

Como hemos señalado, a continuación vamos a presentar de forma muy superficial algo sobre algoritmos de decisión en LP, e iremos desarrollando algunos de los algoritmos más importantes a lo largo de los distintos capítulos que componen este curso.

> Dado un conjunto de fórmulas $U$, un **algoritmo de decisión** para $U$ es aquel que, dada una fórmula $A \in PROP$, devuelve `SI` cuando $A \in U$ y `NO` cuando $A \not\in U$.

Esto da pie a la definición de algunos problemas especialmente interesantes:

> - $SAT = \{A \in PROP: \, A \textit{ es satisfactible}\}$.
> - $TAUT = \{A \in PROP: \, A \textit{ es tautología}\}$.
> - Fijado $U \subseteq PROP$, la *Teoría de $U$* corresponde a: $\mathcal{T}(U) = \{A \in PROP: \, U \models A\}$.

Precisamente, un algoritmo de decisión para $\mathcal{T}(U)$ proporciona una respuesta al Problema Básico que planteamos al comienzo del capítulo. Por tanto, podemos reducir dicho problema a uno nuevo:
> Obtener un algoritmo que, dado un conjunto finito de fórmulas proposicionales, $U$, y una fórmula, $F$, decida si $U \models F$.

Y este, a su vez, se reduce a comprobar la satisfactibilidad de una cierta fórmula (o bien la validez de otra), que  se corresponde con el problema conocido como *Problema $SAT$*.

De hecho, ya hemos visto un algoritmo, por medio de las Tablas de Verdad, que resuelve, de forma simple, el problema, pero la complejidad de dicho algoritmo es exponencial en el número de símbolos proposicionales, lo que lo hace inabordable para fórmulas de cierta complejidad (una fórmula que use 1000 variables proposicionales, relativamente pequeña en problemas que aparecen en el mundo real, requeriría de la construcción de una tabla con $2^{1000}$ filas, completamente inabordable por medios directos.

A lo largo de los siguientes capítulos analizaremos otros algoritmos de decisión para el problema $SAT$, algunos de los cuales parecerán más eficientes que otros, pero hemos de recordar que no se ha encontrado ninguno capaz de resolver el problema eficientemente (complejidad polinomial), y, de hecho, se duda (fuertemente) de la existencia de un tal algoritmo, porque como dijimos el problema $SAT$ es **NP**-completo, y se piensa que las clases **P** (*grosso modo*, los problemas que se pueden resolver en tiempo polinomial) y **NP** son distintas.

## Conceptos Básicos de Lógica de Primer Orden

### Limitaciones de la Lógica Proposicional

Aunque la lógica proposicional posee un semántica sencilla y existen algoritmos de decisión (poco eficientes) para sus problemas básicos, como $SAT$ o la consecuencia lógica, la expresividad de LP es bastante limitada, esto hace que muchos problemas no sean modelables en LP, bien porque requieren un gran número de fórmulas o fórmulas de gran tamaño, o
bien porque no puedan ni siquiera expresarse en este lenguaje. El siguiente ejemplo presenta un razonamiento que es válido, sin embargo no es expresable en LP:

1. Todo hombre es mortal.
2. Sócrates es hombre.
3. Por tanto, Sócrates es mortal.

¿Cómo expresar el concepto de ser hombre?¿Como expresar quién es Sócrates?, pero aún más ¿Cómo expresar que todos es mortal?. Es aquí precisamente donde comienza el ámbito de la Lógica de PrimerOrden.

### Caracterización de la Lógica de Primer Orden

La Lógica de Primer Orden (LPO) extiende la Lógica Proposicional, ganando capacidad expresiva, que permite abordar cuestiones como:

- Realizar cuantificación sobre los objetos de un dominio, esto es, expresar en qué medida se tiene una propiedad sobre un conjunto de objetos.

- Representar propiedades de los objetos particulares del dominio por medio de predicados y funciones.

- Trabajar con subconjuntos de objetos que pueden venir caracterizados por propiedades que se describen por medio de predicados y funciones.

### Fundamentos de la Lógica de Primer Orden

De forma análoga a como se ha visto para la lógica proposicional vamos a estudiar los elementos que definen la Lógica de Primer Orden (Sintáxis y Semántica) dejando para capítulos futuros el desarrollo de los Algoritmos de Decisión.

### Sintáxis de la Lógica de Primer Orden

Formalmente,

> La **Lógica de Primer Orden** o **Lógica de Predicados** es un sistema formal diseñado para estudiar los métodos inferenciales en los leguajes de primer orden.

Un **lenguaje de primer orden** corresponde a un lenguaje formal que consta de:

- <u>Símbolos lógicos</u> (comunes a todos los lenguajes): En los que se engloban:

    -   Un conjunto de *Variables:* $V = \{x, x_0, x_1, \ldots, y, y_0, \ldots \}$

    -   *Conectivas lógicas :* $\neg$ (negación), $\wedge$ (conjunción), $\vee$ (disyunción), $\rightarrow$ (implicación), $\leftrightarrow$ (equivalencia).

    -   *Cuantificadores:* $\exists$ (existencial), $\forall$ (universal).

    -   *Símbolos auxiliares:* $`('$ y $`)'$

-   <u>Símbolos no lógicos</u> (propios de cada lenguaje): En los que se engloban:

    -   Un conjunto de *Constantes:* $L_{C}= \{a, b, \ldots, a_{0}, a_{1}, \ldots \}$

    -   Un conjunto de *símbolos de función:* $L_{F} = \{f_{0}, f_{1}, \ldots\}$, cada uno con su aridad correspondiente.

    -   Un conjunto de **símbolos de predicado:** $L_P=\{P_{0}, P_{1}, \ldots, Q, Q_0, \ldots\}$, cada uno con su aridad correspondiente.

        Dos notas:

        -   Los símpolos de predicado de aridad 0 actúan como símbolos proposicionales.

        -   El símbolo de igualdad (‘$=$’) no es un predicado común a todos los lenguajes de primer orden, pero si es corriente su aparición. La familia de lenguajes que incluyen este predicado es denominada *Lenguajes de Primer Orden con Igualdad*.

Este aparato permite la construcción de distintas expresiones, que componen las fórmulas de LPO. Vamos a exponer una diferenciación de dichas expresiones, distinguiendo *términos* y *fórmulas*.

#### Términos en LPO

Los términos se identifican con posibles objetos del mundo. Englobando los siguientes elementos:

- <u>Constantes</u> para hablar de objetos específicos.
- <u>Variables</u> para hablar de objetos genéricos.
- <u>Funciones</u> aplicadas a otros términos más pequeños, según su aridad.

Para ejemplificar los conceptos expuestos a lo largo del tema vamos a modelar el mundo romano:
(los superíndices indican la aridad)

$$LR = \{\underbrace{\boldsymbol{César}, \boldsymbol{Marco}}_{constantes}, \underbrace{P^{1}, L^{2}, O^{2}, R^{1}, IA^{2}}_{\textit{símbolos de predicado}}, \underbrace{f^{1}}_{\textit{símbolo de función}} \}$$

tal que, donde, $César$ y $Marco$ son constantes, $P$ y $R$ son predicados unarios que denotan *ser pompeyano* y *ser romano*, respectivamente; $L$, $O$, $IA$ son predicados binarios que denotan *ser leal a*, *odiar a* , *intentar asesinar a*, respectivamente; y $f$ una función unaria que represente el concepto de *padre de*.

De forma que son términos de $LR$:

- *Constantes*: *Marco*, *César*.
- *Variables*: $x$, $y$, $x_1$, ...
- *Funciones*: f(César), f(x), f(f(x)), ...

#### Fórmulas en LPO

Las fórmulas se identifican con afirmaciones sobre los objetos del mundo, permitiendo hablar de la veracidad o falsedad de las afirmaciones. Están formadas a partir de predicados sobre términos, y construcciones lógicas de estos predicados (conjunciones, implicaciones, cuantificaciones, etc.). Veámos esto formalmente.

Las fórmulas pueden corresponder a:

- <u>Átomos o Fórmulas atómicas</u>. Corresponden a las expresiones $p(t_1, t_2, \ldots, t_n)$, tal que $p$ es un símbolo de predicado de aridad $n$ y $t_i$ son términos.

- <u>Fórmulas no atómicas</u>. Corresponden a expresiones formadas a partir de fórmulas atómicas, mediante el empleo de conectivas y/o cuantificadores.

De esta forma, son fórmulas de $L$:

- Toda fórmula atómica.

- Si F y G son fórmulas de de $L$ entonces $\neg F$, $F \wedge G$, $F \vee G$, $F \rightarrow G$, $F \leftrightarrow G$, también son fórmulas de $L$.

- Si x es una variable y F es una fórmula de $L$, entonces $\exists x \, F$ y $\forall x \, F$ son también fórmulas de $L$.

Volviendo al mundo romano, algunas posibles fórmulas del lenguaje $LR$:

- *Átomos*: $P(\boldsymbol{César})$, $L(\boldsymbol{César}, \boldsymbol{Marco})$, $IA(\boldsymbol{Marco}, f(x))$.
- *Fórmulas compuestas*: $\forall x \exists y \, L(x,y)$, $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{César}) \vee O(x, \boldsymbol{César}) \right)$

$\longrightarrow$ <u>Reglas de simplificación de la notación</u>

Para facilitar la lectura y escritura de las fórmulas vamos a tomar varios criterios de notación:

- Se omitirán los paréntesis externos.
- Las prioridades de las conectivas siguen el mismo orden que el expuesto en LP: $\neg, \wedge, \vee, \rightarrow, \leftrightarrow$ (para la última se recomienda mantener los paréntesis).
- Los cuantificadores tienen prioridad sobre las conectivas.

##### Árboles de formación.

Al iguan que en las fórmulas de LP, la definición de las fórmulas en LPO presenta una estructura recursiva:

- *Caso base*. Fórmulas atómicas.
- *Casos recursivos* Aplicación de las conectivas y cuantificadores sobre fórmulas de LPO.

Y de forma análoga a la presentada en LP, se puede plasmar dicha estructura recursiva en un grafo tipo árbol (esencialmente único), de forma que el nodo raíz corresponde a la fórmula completa y las hojas corresponden a las fórmulas atómicas que participan en la fórmula. Al igual que en LP, toda fórmula que aparezca en algún nodo (ya sea un nodo interno o una hoja) diremos que es **subfórmula** de la fórmula original.

Para la fórmula $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{César}) \vee O(x, \boldsymbol{César}) \right)$, se tendría el AF asociado:

<center> <img src="images/T1Img4.png" title="Árbol de formación en LPO (ejemplo)."></center><br>


##### Sintaxis de Fórmulas LPO en Logicus

Al igual que hicimos con la lógica LP, vamos a exponer cuál es la sintaxis de las fórmulas utilizando la librería Logicus, que nos permitirá definir fórmulas y aplicar diversos algoritmos sobre las mismas.

Bajo la librería podemos definir las fórmulas de dos formas distintas, o bien acudiendo directamente a los constructores de las fórmulas (largo y engorroso), o bien utilizando el Parser (de forma análoga a la escritura natural de las fórmulas).

$\longrightarrow$ <u>Definición de fórmulas a partir de constructores (Módulo *SintaxSemanticsLPO*)</u>

Antes de introducirnos en el estudio de la sintaxis de fórmulas vamos a presentar la sintaxis y definición de términos. Recordemos que la estuctura de los términos corresponde a una definición recursiva con <u>variables</u> y <u>constantes</u> como *casos base* y <u>funciones</u>.

Aunque la definición en la librería sigue esta idea, se ha decidido modelar las <u>constantes</u> como funciones independientes de variables, de forma que en la librería se tiene que un término es o bien una variable o bien una función.

    type Term = Var String
              | Func String (List Term)

De forma que las constantes corresponderían a objetos con la estructura *Func String [ ]*.

De forma que podemos definir términos de forma sencilla mediante el uso de estos constructores. Volviendo al ejemplo presentado anteriormente, (*Constantes*: *Marco*, *César*; *Variables*: $x$, $y$, $x_1$, ...; *Funciones*: f(César), f(x), f(f(x))):

```elm{l context="8"}

import Logicus.SintaxSemanticsLPO exposing (..)

cesar = Func "cesar" []

marco = Func "marco" []

x = Var "x"

x_1 = Var "x_1"

f_cesar = Func "f" [cesar]

f_f_cesar = Func "f" [Func "f" [cesar]]
```

Ahora que ya podemos definir términos en LPO podemos pasar a ver la definición de fórmulas. Si recordamos, las fórmulas están definidas con una estructura recursiva, de forma que las fórmulas corresponden o bien a átomos (*caso base*), o bien a la aplicación de las conectivas y/o cuantificadores sobre otras fórmulas (*caso recursivo*).

Bien, pues la implementación dada en la librería para las fórmulas sigue fielmente dicha definición. De forma que: (definiendo el tipo *Variable* como alias de *Term*)

    type alias Variable = Term
    
    type FormulaLPO = Pred String (List Term)
                    | Equal Term Term
                    | Neg FormulaLPO
                    | Conj FormulaLPO FormulaLPO
                    | Disj FormulaLPO FormulaLPO
                    | Impl FormulaLPO FormulaLPO
                    | Equi FormulaLPO FormulaLPO
                    | Exists Variable FormulaLPO
                    | Forall Variable FormulaLPO
                    | Insat

De forma que esto nos permite expresar sintácticamente todas las fórmulas en LPO. Para los ejemplos expuestos:

```elm{l context="9"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)


f1 : FormulaLPO
f1 = Pred "P" [Func "cesar" []]

```

^^^elm{m=(toLatexFLPO f1) context="9"}^^^

```elm{l context="9"}

f2 : FormulaLPO
f2 = Pred "L" [Func "cesar" [], Func "marco" []]

```

^^^elm{m=(toLatexFLPO f2) context="9"}^^^


```elm{l context="9"}

f3 : FormulaLPO
f3 = Pred "IA" [Func "cesar" [], Func "f"  [Var "x"]]

```

^^^elm{m=(toLatexFLPO f3) context="9"}^^^

```elm{l context="9"}

f4 : FormulaLPO
f4 = Forall (Var "x") (Exists (Var "y") (Pred "L" [Var "x", Var "y"]))

```

^^^elm{m=(toLatexFLPO f4) context="9"}^^^

```elm{l context="9"}

f5 : FormulaLPO
f5 = Forall (Var "x") (Impl (Pred "R" [Var "x"]) (Disj (Pred "L" [Var "x",Func "cesar" []]) (Pred "O" [Var "x",Func "cesar" []])))

```

^^^elm{m=(toLatexFLPO f5) context="9"}^^^

$\longrightarrow$ <u>Definición de fórmulas LPO con Parser (Módulo *IO_LPO*)</u>

Aunque ya podemos definir todas las fórmulas en LPO, su escritura resulta una tarea muy pesada, para aliviar esa carga se ha desarrollado un Parser que permite la lectura de fórmulas a partir de una cadena de texto en el que las fórmulas se escriben de forma análoga a como se dan en el lenguaje formal de la lógica. Se establecen algunas reglas sintácticas en su uso:

- Las <u>variables</u> se escriben con una letra en minúscula seguidas de caracteres alphanuméricos o el símbolo '_'. Algunos ejemplos: *'x'* , *'x_1'*, *'x1'*, ...

- Las *funciones* se definen siguiendo la notación prefija, según el patrón:

    <center><i> [Símbolo de función] [parámetros]</i></center>

    Tal que: 

    - El *símbolo de función* debe comenzar por el carácter '_', seguido de una serie de caracteres, entre estos se admiten caracteres alfanuméricos y también símbolos, excepto '[', ']', '(', ')', '{', '}', ',', ';'.

    - En los *parámetros* se pueden dar 2 casos, o bien la función corresponde a una <u>constante</u> y por tanto no tiene parámetros, con lo cual bastaría escribir el símbolo de función (ejemplos: *'_a'*, *'_PEDRO'*, *'_1'*) o bien es una <u>función</u> (dependiente de, al menos, un término), en tal caso los argumentos se dan en una lista acotada por corchetes ('[', ']') y tras cada argumento ha de ir un ';' (ejemplos: *'_f[x;]'*, *'_g[x;y;]'*, *'_+[x;\_1;\_·[y;\_2;]]'*).

- Los <u>predicados</u> se definen utilizando la notación prefija según el patrón:

    <center><i> [símbolo de predicado] [parámetros]</i></center>

    Tal que:

    - El *símbolo de predicado* debe comenzar por un carácter en mayúscula o un símbolo (exceptuando '_',  '!', '(', ')', '[', ']', '}', '}' (también se admiten dígitos numéricos pero no se recomienda), seguido de una serie de caracteres, entre estos se admiten caracteres alfanuméricos y también símbolos (exceptuando '(', ')', '[', ']', '}', '}'). Son palabras reservadas (y por tanto no se pueden usar como predicados) *"NOT", "AND", "OR", "IMPLIES", "EQUIV", "EXISTS", "FORALL", "INSAT"*.

    - En los *parámetros* se pueden dar 2 casos, o bien la función es un <u>predicado proposicional</u> (no tiene parámetros), con lo cual bastaría escribir el símbolo de predicado (ejemplos: *'P'*, *'Q\_1'*) o bien es un <u>predicado n-ario</u> (dependiente de, al menos, un parámetro), en tal caso los argumentos se dan en una lista acotada por corchetes ('[', ']') y tras cada argumento ha de ir un ';' (ejemplos:'P[x;]', '>=[x;y;]', 'MAX[x;\_1;\_·[y;\_2;]]').

    Hay una excepción, *predicado de igualdad* (binaria) se utilizará de forma infija separando los términos con el símbolo '=' (ejemplos: 'x=y' , 'x\_4=\_3', '\_f[x;]=\_f[y;]') (El predicado de igualdad es de uso exclusivamente binario).

    <center><i> [término] = [término]</i></center><br><br>

- Los <u>cuantificadores</u> se expresan de forma análoga al lenguaje formal de LPO según el patrón:

    <center><i> [símbolo de cuantificador] [variable] [fórmula]</i></center><br><br>

    Tal que: 

    - Los *símbolos de cuantificadores* corresponden a:

      |      Cuantificador      | Símbolo LogicUS |
  | :---------------------: | :-------------: |
    | $\exists$ (Existencial) |     EXISTS      |
  |  $\forall$ (Universal)  |     FORALL      |
    
    - La *variable* debe ir entre llaves ('{', '}'), respetando las reglas establecidas para la definición de variables.
    
    - La *fórmula* escrita respetando los criterios dados para la escritura de las fórmulas.


 - Las conectivas se usarán de forma infija (salvo para la *negación*),  utilizando los siguientes símbolos, mantiéndose la prioridad de las conectivas definida (en el orden de prioridad descendente expuesto en la tabla).

   |           Conectiva Lógica           | Símbolo LogicUS |
   | :----------------------------------: | :-------------: |
   |             ¬ (Negación)             |       NOT       |
   |            ∧ (Conjunción)            |       AND       |
   |            ∨ (Disyunción)            |       OR        |
   |           🡒 (Implicación)            |     IMPLIES     |
   | 🡘 (Doble Implicación o Equivalencia) |      EQUIV      |

- Los paréntesis se utilizan de igual forma en que se han definido en el lenguaje formal de la lógica proposicional, con los símbolos '(' y ')'. No son necesarios los paréntesis externos de las fórmulas.

- En caso de uso repetido de una misma conectiva y/o cuantificador, se realizará asociación por la derecha.

Al igual que ocurría en el Parser de LP una vez leída la fórmula con la función *fromStringToFLPO* es necesario extraerla utilizando la función *extractReadFLPO*.

Vamos a mostrar algunos ejemplos de definición de las fórmulas utilizando el Parser de LPO.

- Ejemplo 1: $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{César}) \vee O(x, \boldsymbol{César}) \right)$

```elm{l context="10"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)

f1 : FormulaLPO
f1 = fromStringToFLPO "FORALL{x}(R[x;] IMPLIES (L[x;_cesar;] OR O[x; _cesar;]))" |> extractReadFLPO

-- Ejecutamos (toLatexFLPO f1) para mostrar la fórmula
```

Que corresponde a:

^^^elm{m=(toLatexFLPO f1) context="10"}^^^

- Ejemplo 2 (tomando el lenguaje matemático), definamos la propiedad biyectiva. Para expresarla consideremos el siguiente lenguaje: $L= \{O, I, f\}$, tal que:

    - $O$ es un predicado de aridad 1 que expresa si el objeto pertenece al conjunto origen.

    - $I$ es un predicado de aridad 1 que expresa si el objeto pertenece al conjunto imagen.

    - $f$ es una función que dado un elemento del conjunto origen obtiene el correspondiente elemento del conjunto imagen y dado un elemento del conjunto imagen obtiene el correspondiente del conjunto origen.

    La propiedad biyectiva se formula como:

    <center><i> Una relación es biyectiva si para todo elemento del conjunto origen existe un único elemento del conjunto imagen con el que está relacionado y todo elemento del conjunto imagen está relacionado con algún elemento del origen</i></center><br>

    Esto es: $$ \forall x,y \in O \, (x \neq y \rightarrow f(x) \neq f(y)) \wedge \forall x \in I \, \exists y \in O \, (f(x)=y)$$<br>

    ```elm{l context="10"}

    biyectiva : FormulaLPO
    biyectiva = fromStringToFLPO
                    "FORALL{x} FORALL{y} (O[x;] AND O[y;] AND NOT (x=y) IMPLIES NOT (_f[x;]=_f[y;])) AND FORALL{x}(I[x;] IMPLIES EXISTS{y}(O[y;] AND _f[y;]=x))"
                |> extractReadFLPO

    -- Ejecutamos (toLatexFLPO biyectiva) para mostrar la fórmula
    ```

    ^^^elm{m=(toLatexFLPO biyectiva) context="10"}^^^

    $\longrightarrow$ <u>Árboles de formación LPO en Logicus</u>

    La librería también permite la representación de los árboles de formación LPO. La función *formtree* (del módulo *IO_LPO*) muestra la representación del árbol de formación en formato texto DOT, de forma análoga a como lo hacía en el caso de LP

    Por ejemplo para la fórmula $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{César}) \vee O(x, \boldsymbol{César}) \right)$:

    ```elm {l context="11"}
    import Logicus.IO_LPO exposing (..)
    import Logicus.SintaxSemanticsLPO exposing (..)
    import Logicus.AuxForLitvis exposing (showGraphViz)

    f : FormulaLPO
    f = fromStringToFLPO "FORALL{x}(R[x;] IMPLIES (L[x;_cesar;] OR O[x; _cesar;]))" |> extractReadFLPO

    ft_f : String
    ft_f = formTree f
    ```
    De forma que se obtiene:

    ^^^elm {m=(showGraphViz "G2" ft_f) context="11"}^^^

##### Alcance de los cuantificadores, FBF, clausura de fórmulas y renombramiento de variables

Hemos estudiado la sintáxis formal de las fórmulas, pero aún faltan algunos detalles por completar para establecer qué fórmulas están bien formadas y cuáles no. Un tema importante es el tratamiento de la cuantificación, esto es, a qué aparciones u ocurrencias (denominadas estancias) de una variable afecta un cuantificador.

> Una ocurrencia de una variable está afectada por un cuantificador (se dice que es una **estancia u ocurrencia ligada**) si hay un cuantificador sobre dicha variable actuándo sobre la (sub)fórmula que la contiene. En otro caso diremos que se trata de una **estancia u ocurrencia libre**

Para comprenderlo mejor vamos a explicar un ejemplo:

$$ \underbrace{\forall x}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {1}}}} \, \boxed{( P(\underbrace{x}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{x ligada}\end{array}}, \underbrace{y}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{y libre}\end{array}}) \rightarrow  \underbrace{\exists y}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {2}}}} \, \boxed{R(\underbrace{y}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{y ligada}\end{array}}, \underbrace{x}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{x ligada}\end{array}})}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {2}}}} )}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {1}}}}$$

En la fórmula podemos apreciar que el cuantificador, $\forall x$, afecta a toda la fórmula siguiente, por tanto todas las ocurrencias de $x$ que aparezcan en la fórmula serán ocurrencias ligadas. Sin embargo, $P(x,y)$ no está afectado por ningún otro cuantificador, por tanto, la ocurrencia de $y$ en $P(x,y)$ es libre. Por otra parte, $R(x,y)$ sí está afectado por el cuantificador $\exists y$,  por tanto tanto la ocurrencia de $x$ como la de $y$ en $R(y, x)$ son ligadas.

De forma similar se definen las variables *libres* y *ligadas* como:

> Una variable $x$ se dice **varible libre** en una fórmula $F$ si existe alguna ocurrencia libre de $x$ en $F$. <br>
Una variable $x$ se dice **varible ligada** en una fórmula $F$ si existe alguna ocurrencia ligada de $x$ en $F$.

De forma que en una fórmula una variable puede ser al mismo tiempo *variable libre* y *variable ligada*.

Por ejemplo, en la fórmula anterior $x$ es una variable *exclusivamente cerrada* (todas sus ocurrencias son ligadas), sin embargo $y$ es una variable *libre* y *ligada* (hay una ocurrencia libre y otra ligada).

En base a los conceptos anteriores se definen los conceptos:

> Se dice que un **término** es **cerrado** si no contiene ninguna variable.

Por ejemplo: $César$, $f(Marco)$, $f(f(César))$; son términos cerrados en el lenguaje $LR$.

> Se dice que una **fórmula** es **cerrada** si no contiene variables libres, o equivalentemente si todas las estancias de todas las variables son ligadas.

Por ejemplo las fórmulas $\forall x (L(x, César) \vee O(César, x))$, $\forall x L(x, César) \rightarrow \neg \exists y O(César, y)$ son una *fórmulas cerradas*, mientras que las fórmulas $\forall x L(x, César) \vee O(César, x)$ , $\forall x L(x, César) \rightarrow \neg \exists y IA(y, x)$ no lo son.

> Se dice que una **fórmula** es **abierta** si no contiene cuantificadores, esto es todas las variables son, exclusivamente, *variables libres*.

Por ejemplo son fórmulas abiertas $P(x)$, $R(César)$, $P(x) \leftrightarrow \neg IA(f(x), Marco)$.

Incidiremos más en este aspecto cuando veámos la semántica en LPO.

$\longrightarrow$ <u>Fórmulas bien formadas y renombramiento de variables</u>

Aunque las fórmulas estén bien escritas sintácticamente, incluso aunque sean cerradas, es posible que su interpretación sea ambigua, esta ambigüedad suele venir dada por un mal uso de los cuantificadores y las variables, por ejemplo tengamos la fórmula:

$$\forall z\,\forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, \boxed{z}\right) \wedge P\left(x, y\right) \right) \right) \right)$$

La ocurrencia de $z$ señalada, es claramente ligada, pero ¿a qué cuantificador?

> Diremos que una **fórmula** está **bien formada** (*FBF* o *WFF*) si es correcta sintácticamente y no contiene dos cuantificadores anidados actuando sobre la misma variable.

Claramente, la **fórmula** presentada no está **bien formada** y hay una ambigüedad en la interpretación de la fórmula, para resolver dicha ambigüedad vamos a adoptar el siguiente criterio:

"Una ocurencia está ligada (si es que lo está) al cuantificador de nivel superior más cercano en el árbol de formación"

De forma que la ocurrencia anterior la tomaremos ligada al existencial. Nótese que en el árbol de formación es el cuantificador referido a $z$ de orden superior más cercano:

<center> <img src="images/T1Img6.png" title="Árbol formación (ejemplo)"></center><br>

Además de adoptar un criterio, podemos, mejor, realizar un renombramiento de las variables, manteniendo el sentido original de las fórmulas, de forma que la fórmula anterior podríamos renombrarla mejor como:
$$\forall z_1\,\forall x_1\,\exists y_1\,\left( P\left(x_1, y_1\right)\rightarrow \left( P\left(x_1, z_1\right) \vee \exists z_2\,\left( P\left(y_1, z_2\right) \wedge P\left(x_1, y_1\right) \right) \right) \right)$$

No es el único caso en el que es necesario renombrar las variables, por ejemplo, tengamos la fórmula:

$$\forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, \raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {$z$}}}\right) \vee \exists z\,\left( P\left(y, \boxed{z}\right) \wedge P\left(x, y\right) \right) \right) \right)$$

La primera ocurrencia de $z$ señalada es libre y la segunda es ligada, claramente el mismo símbolo de variable representa objetos distintos, lo que produce una cierta ambigüedad en la fórmula. Sin embargo, podemos renombrar la fórmula como:
$$\forall x_1\,\exists y_1\,\left( P\left(x_1, y_1\right)\rightarrow \left( P\left(x_1, z\right) \vee \exists z_1\,\left( P\left(y_1, z_1\right) \wedge P\left(x_1, y_1\right) \right) \right) \right)$$

De forma que desaparece toda posible ambigüedad.

Nótese que para renombrar se ha escogido el siguiente criterio : *Se renombrarán todas las ocurrencias ligadas de cada variable añadiendo el subíndice correspondiente según el orden y cardinalidad de aparición del cuantificador (sobre dicha variable) al que está ligada dicha ocurrencia (tomando el orden según el recorrido en profundidad del $AF$ de la fórmula)*

$\longrightarrow$ <u>Clausura de las fórmulas LPO.</u>

Los algoritmos de decisión que vamos a estudiar trabajan únicamente sobre fórmulas cerradas, por lo que hemos de *clausurar* todas aquellas fórmulas que no sean cerradas, cuantificando las variables libres de la fórmula (aplicando un renombramiento sobre aquellas variables que sean, simultáneamente, libres y ligadas).

Se admiten dos tipos de clausura para las fórmulas:

- <u>Clausura universal</u> se trata de cerrar la fórmula a base de cuantificar universalmente (por la izquierda) las variables libres de las fórmulas. Si $v_1, \ldots, v_n$ corresponden a las variables libres de una fórmula $F$, la clausura universal de la fórmula corresponde a la fórmula $\forall v_1 \ldots \forall v_n \, F$

- <u>Clausura existencial</u> se trata de cerrar la fórmula a base de cuantificar existencialmente (por la izquierda) las variables libres de las fórmulas. Si $v_1, \ldots, v_n$ corresponden a las variables libres de una fórmula $F$, la clausura universal de la fórmula corresponde a la fórmula $\exists v_1 \ldots \exists v_n \, F$

Veremos algunas cuestiones más sobre este aspecto cuando veamos la *Semántica en LPO*.

$\longrightarrow$ <u>Fórmulas abiertas/cerradas, FBF, renombramiento y clausura de fórmulas en Logicus</u>

La librería Logicus permite, en el módulo *SintaxSemanticsLPO* trabajar con los conceptos que hemos estado viendo.

$-$ *Variables libres y ligadas*

Recordemos que una variable es libre/ligada si existe alguna ocurrencia de dicha variable que sea libre/ligada. En la librería Logicus las funciones *varIsFreeInFLPO* y *varIsLinkedInFLPO* resuelven este aspecto:

    varIsFreeInFLPO : Variable -> FormulaLPO -> Bool
    varIsFreeInFLPO v f=
        case f of
            Pred _ terms -> List.member v (varsInListTerm terms)
            Equal t1 t2 -> List.member v (varsInListTerm [t1, t2])
            Neg p -> varIsFreeInFLPO v p
            Conj p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Disj p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Impl p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Equi p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Exists var p -> not(var == v) && varIsFreeInFLPO v p
            Forall var p -> not(var == v) && varIsFreeInFLPO v p
            Insat -> True
    
    varIsLinkedInFLPO : Variable -> FormulaLPO -> Bool
    varIsLinkedInFLPO v f=
        case f of
            Pred _ _ -> False
            Equal _ _ -> False
            Neg p -> varIsLinkedInFLPO v p
            Conj p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Disj p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Impl p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Equi p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Exists var p -> (var == v && List.member v (varsInFormula p)) || varIsLinkedInFLPO v p
            Forall var p -> (var == v && List.member v (varsInFormula p)) || varIsLinkedInFLPO v p
            Insat -> False

De forma que podemos preguntar, por ejemplo si las variables $x$, $y$, $z$ son libres y/o ligadas en $$F: \exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la fórmula

```elm {l context="12"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f = fromStringToFLPO "EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{z} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO
```
2. Preguntamos si cada una de las variables son libres/ligadas:

```elm {l context="12"}
isxF = varIsFreeInFLPO (Var "x") f
isxL = varIsLinkedInFLPO (Var "x") f
```
^^^elm {m=("Es $x$ libre? " ++ (toString isxF) ++ "Es $x$ ligada? " ++ (toString isxL) ) context="12"}^^^

```elm {l context="12"}
isyF = varIsFreeInFLPO (Var "y") f
isyL = varIsLinkedInFLPO (Var "y") f
```
^^^elm {m=("Es $y$ libre? " ++ (toString isyF) ++ "Es $y$ ligada? " ++ (toString isyL) ) context="12"}^^^

```elm {l context="12"}
iszF = varIsFreeInFLPO (Var "z") f
iszL = varIsLinkedInFLPO (Var "z") f
```
^^^elm {m=("Es $z$ libre? " ++ (toString iszF) ++ "Es $z$ ligada? " ++ (toString iszL) ) context="12"}^^^


$-$ *Fórmulas abiertas y cerradas*

Recordemos que una fórmula es abierta si todas sus variables son exclusivamente abiertas, o equivalentemente si no contiene cuantificadores. Y una fórmula es cerrada si todas sus variables son exclusivamente cerradas. En la librería Logicus las funciones *isOpenFLPO* y *isClosedFLPO* resuelven este aspecto:

    isOpenFLPO : FormulaLPO -> Bool
    isOpenFLPO f =
    case f of
        Pred _ _ -> True
        Equal _ _ -> True
        Neg p -> isOpenFLPO p
        Conj p q -> isOpenFLPO p && isOpenFLPO q
        Disj p q -> isOpenFLPO p && isOpenFLPO q
        Impl p q -> isOpenFLPO p && isOpenFLPO q
        Equi p q -> isOpenFLPO p && isOpenFLPO q
        Exists _ _ -> False
        Forall _ _ -> False
        Insat -> True
    
    isClosedFLPO : FormulaLPO -> Bool
    isClosedFLPO f = List.all (\v -> varIsLinkedInFLPO v f) (varsInFormula f)

De forma que podemos preguntar, por ejemplo, si las fórmulas $F$, $G$ y $H$ son abiertas, cerradas o ninguna de las dos:

 $$ F: L(x, César) \vee O(César, y)$$ $$G: \forall x \, L(x, César) \vee \exists y \, O(César, y)$$ $$H: \forall x \, L(x, César) \vee O(César, y)$$

 1. Definimos las fórmulas

 ```elm {l context="13"}

 import Logicus.SintaxSemanticsLPO exposing (..)
 import Logicus.IO_LPO exposing (..)
 import Bool.Extra exposing (toString)

 f : FormulaLPO
 f =  fromStringToFLPO "L[x;_César;] OR O[_César; y;]" |> extractReadFLPO

 g : FormulaLPO
 g =  fromStringToFLPO "FORALL{x} L[x;_César;] OR EXISTS{y} O[_César; y;]" |> extractReadFLPO

 h : FormulaLPO
 h =  fromStringToFLPO "FORALL{x} L[x;_César;] OR O[_César; y;]" |> extractReadFLPO

 ```

 2. Preguntamos si cada una de las fórmulas son abiertas/cerradas:

 ```elm {l context="13"}
 isOF = isOpenFLPO f
 isCF = isClosedFLPO f
 ```
 ^^^elm {m=("Es $F$ abierta? " ++ (toString isOF) ++ "Es $F$ cerrada? " ++ (toString isCF) ) context="13"}^^^

 ```elm {l context="13"}
 isOG = isOpenFLPO g
 isCG = isClosedFLPO g
 ```
 ^^^elm {m=("Es $G$ abierta? " ++ (toString isOG) ++ "Es $G$ cerrada? " ++ (toString isCG) ) context="13"}^^^

 ```elm {l context="13"}
 isOH = isOpenFLPO h
 isCH = isClosedFLPO h
 ```
 ^^^elm {m=("Es $H$ abierta? " ++ (toString isOH) ++ "Es $H$ cerrada? " ++ (toString isCH) ) context="13"}^^^

$-$ *Fórmulas bien formadas  y renombramiento de variables.*

Recordemos que consideramos una fórmula bien formada a aquella que es sintácticamente correcta y que no contiene cuantificadores anidados sobre una misma variable. La función *checkWFF* permite comprobar si una fórmula está bien formada o no:

    checkWFF : FormulaLPO -> Bool
    checkWFF x = checkWFFAux x []
    
    checkWFFAux : FormulaLPO -> List Variable -> Bool
    checkWFFAux x ls =
        case x of
            Pred _ _ -> True
            Equal _ _-> True
            Neg p -> checkWFFAux p ls
            Conj p q -> checkWFFAux p ls && checkWFFAux q ls
            Disj p q -> checkWFFAux p ls && checkWFFAux q ls
            Impl p q -> checkWFFAux p ls && checkWFFAux q ls
            Equi p q -> checkWFFAux p ls && checkWFFAux q ls
            Exists v p -> not(List.member v ls) && checkWFFAux p ls && checkWFFAux p (ls ++ [v])
            Forall v p -> not(List.member v ls) && checkWFFAux p ls && checkWFFAux p (ls ++ [v])
            Insat -> True

Recordemos el criterio que establecimos en el renombramiento de variables: *Se renombrarán todas las ocurrencias ligadas de cada variable añadiendo el subíndice correspondiente según el orden y cardinalidad de aparición del cuantificador (sobre dicha variable) al que está ligada dicha ocurrencia (tomando el orden según el recorrido en profundidad del $AF$ de la fórmula)*

En la librería, la función *renameVars* que permite renombrar las variables de una fórmula siguiendo este mismo criterio:

    renameVars : FormulaLPO -> FormulaLPO
    renameVars f = Tuple.first <| renameVarsAux Dict.empty Dict.empty f
    
    renameVarsAux : Dict String Int -> Dict String Int -> FormulaLPO -> (FormulaLPO, Dict String Int)
    renameVarsAux act mem  f =
    case f of
        Pred n terms ->
            let
                s = Dict.map (\ k v -> Var (k ++ "_" ++ String.fromInt v)) act
            in
                (Pred n <| List.map (\ t -> applySubsToTerm s t) terms, mem)
    
        Equal t1 t2 ->
            let
                s = Dict.map (\ k v -> Var (k ++ "_" ++ String.fromInt v)) act
            in
                (Equal (applySubsToTerm s t1) (applySubsToTerm s t2), mem)
    
        Neg g ->
            let
                (ng, nmem) = renameVarsAux act mem g
            in
                (Neg ng, nmem)
    
        Conj g h ->
            let
                (ng, nmem) = renameVarsAux act mem g
            in
                let
                    (nh, nmem2) = renameVarsAux act nmem h
                in
                    (Conj ng nh, nmem2)
    
        Disj g h ->
            let
                (ng, nmem) = renameVarsAux act mem g
            in
                let
                    (nh, nmem2) = renameVarsAux act nmem h
                in
                    (Disj ng nh, nmem2)
        Impl g h ->
            let
                (ng, nmem) = renameVarsAux act mem g
            in
                let
                    (nh, nmem2) = renameVarsAux act nmem h
                in
                    (Impl ng nh, nmem2)
        Equi g h ->
            let
                (ng, nmem) = renameVarsAux act mem g
            in
                let
                    (nh, nmem2) = renameVarsAux act nmem h
                in
                    (Equi ng nh, nmem2)
        Forall (Var x) g ->
            let
                xind = (Maybe.withDefault 0 <| Dict.get x mem) + 1
            in
                let
                    nact = Dict.insert x xind act
                    nmem = Dict.insert x xind mem
                in
                    let
                        (ng, nmem2) = renameVarsAux nact nmem g
                    in
                        (Forall (Var (x ++ "_" ++  String.fromInt xind)) ng, nmem2)
    
        Exists (Var x) g ->
            let
                xind = (Maybe.withDefault 0 <| Dict.get x mem) + 1
            in
                let
                    nact = Dict.insert x xind act
                    nmem = Dict.insert x xind mem
                in
                    let
                        (ng, nmem2) = renameVarsAux nact nmem g
                    in
                        (Exists (Var (x ++ "_" ++  String.fromInt xind)) ng, nmem2)
    
        _ -> (Insat, mem)


*NOTA: La función 'applySubsToTerm' la veremos cuando estudiemos las sustituciones (en el siguiente apartado)*.

De forma que podemos aplicar las funciones anteriores al siguiente ejemplo, tal que : $$F: \forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists y\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la fórmula:

```elm {l context="14"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f =  fromStringToFLPO "FORALL{x} EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{y} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO

```

2. Veámos si está bien formada:

```elm {l context="14"}
isWFF_F = checkWFF f
```

^^^elm {m=("Está $F$ bien formada? " ++ (toString isWFF_F) ) context="14"}^^^

3. Aplicamos el renombramiento de variables:

```elm {l context="14"}
f2 = renameVars f
```

^^^elm {m=((toLatexFLPO f2)) context="14"}^^^

4. Comprobemos si $F_2$ está bien formada:

```elm {l context="14"}
isWFF_F2 = checkWFF f2
```

^^^elm {m=("Está $F$ bien formada? " ++ (toString isWFF_F2) ) context="14"}^^^

$-$ *Clausura de las fórmulas*

Como ya hemos comentado los métodos que vamos a estudiar se basan en el trato de fórmulas cerradas, por lo que cuando las fórmulas no lo son, es necesario clausurarlas universal o existencialmente. La librería Logicus implementa ambos métodos de clausura en las funciones *universalClausureFLPO* y *existencialClausureFLPO*.

    universalClausureFLPO : FormulaLPO -> FormulaLPO
    universalClausureFLPO f = renameVars <| universalClausureFLPOAux f (List.filter (\ v -> varIsFreeInFLPO v f) <| varsInFormula f)
    
    universalClausureFLPOAux : FormulaLPO -> List Variable -> FormulaLPO
    universalClausureFLPOAux f ls =
        case ls of
            [] -> f
            x::xs -> universalClausureFLPOAux (Forall x f) xs
    
    existencialClausureFLPO : FormulaLPO -> FormulaLPO
    existencialClausureFLPO f = renameVars <| existencialClausureFLPOAux f (List.filter (\ v -> varIsFreeInFLPO v f) <| varsInFormula f)
    
    existencialClausureFLPOAux : FormulaLPO -> List Variable -> FormulaLPO
    existencialClausureFLPOAux f ls =
        case ls of
            [] -> f
            x::xs -> existencialClausureFLPOAux (Exists x f) xs

De forma que, si tenemos la fórmula: $$F: \exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la función

```elm {l context="15"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f =  fromStringToFLPO "EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{z} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO

```

2. La clausura universal de la fórmula correspondería a:

```elm {l context="15"}
f2 = universalClausureFLPO f
```

^^^elm {m=((toLatexFLPO f2)) context="15"}^^^

2. La clausura existencial de la fórmula correspondería a:

```elm {l context="15"}
f3 = existencialClausureFLPO f
```

^^^elm {m=((toLatexFLPO f3)) context="15"}^^^

#### Sustituciones en LPO

> Una sustitución (finita) o simplemente **sustitución**, **$\theta$** corresponde a una función que asigna a un conjunto finito de variables un conjunto finito de términos  $\theta(x_i)=t_i \, (i=1,\ldots, n)$. Se denomina *dominio* de la función al conjunto de variables que no permanecen invariantes ante la sustitución, esto es, $dom(\theta) = \{x_i / \theta(x_i) \neq x_i\}$.
>
> Para denotar una sustitución, lo hacemos por $\theta=\{x_1/t_1, \ldots, x_n/t_n\}$ o también $\theta=\{(x_1,t_1), \ldots, (x_n,t_n)\}$.

##### Aplicación de sustituciones a términos.

La aplicación de una sustitución a un término consiste en intercambiar las variables que participan en dicho término según la correspondencia que establece la sustitución y se denota por $\theta(t)$ o también $t\{x_1/t_1, \ldots, x_n/t_n\}$. Formalmente: $$\theta(t) = \left\lbrace \begin{array}{lll} \theta(x_i) & si \, t=x_i & [t \textit{ es una variable}]\\ f(\theta(t_1), \ldots, \theta(t_m)) & si \, t=f(t_1, \ldots, t_m) & [t \textit{ es una función de aridad } m ]\\  \end{array}\right.$$

Por ejemplo, tengamos la sustitución $\theta = \{x/(x+y), z/\boldsymbol{0}, u/\boldsymbol{1}\}$ y el término $t=(x+y)+z$, de esta forma tendríamos $\theta(t)=((x+y) + y) + \boldsymbol{0}$.

Nótese el carácter simultáneo de la susutitución, esto es, la sustitución de todos las variables se realiza simultáneamente de forma que **no** se tiene  $\{x_i/x_j, x_j/t_j\} \equiv \{x_i/t_j, x_j/t_j\}$. Por ejemplo, tengamos el término del ejemplo anterior y la sustitución $\theta_2 = \{x/(x+y), y/\boldsymbol{0}\}$, entonces: $$((x+y)+z)\{x/(x+y), y/\boldsymbol{0}\} \neq ((x+\boldsymbol{0})+\boldsymbol{0})+z$$ $$((x+y)+z)\{x/(x+y), y/\boldsymbol{0}\} = ((x+y)+\boldsymbol{0})+z$$

##### Aplicación de sustituciones a fórmulas.
La aplicación de una sustitución a un término consiste en intercambiar todas las ocurrencias **libres** de las variables del dominio de la sustitución en $F$ por los términos que les corresponden en la sustitución. Se denota por $\theta(F)$ o también $F\{x_1/t_1, \ldots, x_n/t_n\}$ de forma que:

$$\theta(F) \equiv \left\lbrace \begin{array}{ll} P(\theta(t_1), \ldots, \theta(t_n)) & si \, F\equiv P(t_1, \ldots, t_n)\\ \neg \theta(G) & si \, F \equiv \neg G \\ \theta(G) \wedge \theta(H) & si \, F \equiv G \wedge H \\ \theta(G) \vee \theta(H) & si \, F \equiv G \vee H \\ \theta(G) \rightarrow \theta(H) & si \, F \equiv G \rightarrow H \\ \theta(G) \leftrightarrow \theta(H) & si \, F \equiv G \leftrightarrow H \\ \exists x \, G\{x_i/t_i : x_i \in dom(\theta) \wedge x_i \neq x\} & si \, F \equiv \exists x  \, G \\ \forall x \, G\{x_i/t_i : x_i \in dom(\theta) \wedge x_i \neq x\} & si \, F \equiv \forall x  \, G \\ \end{array}\right.$$

 $\longrightarrow$ <u>Sustituciones admisibles</u>

 No toda sustitución es admisible para una fórmula, por ejemplo, téngase la fórmula $F \equiv \exists x \, \neg(x=y)$ y téngase la sustitución $\theta = \{y/x\}$, entonces $\theta(F) = \exists x \neg (x=x)$. Claramente el sentido de la fórmula ha cambiado, mientras que en la primera fórmula se establece que debe haber, al menos, dos objetos distintos en la segunda se tiene que existe al menos un objeto que es distinto de sí mismo (que es sencillamente falso.)

 De esta forma:

 > Una variable, $x_i \in dom(\theta)$, de una fórmula, $F$, es sustituible por el término correspondiente, $t_i$, si y sólo si la aplicación de la sustitución, $\theta(F)$ no produce nuevas ocurrencias ligadas.

 Formalmente, una variable $x_i$ de $F$ es sustituible por $t_i$ si se da alguna de las siguientes condiciones:

 1. $F$ es atómica.
 2. $F  \equiv \neg G$ y $x_i$ es sustituible por $t_i$ en $G$
 3. $F  \equiv G \left( \wedge | \vee | \rightarrow | \leftrightarrow \right) H$ y $x_i$ es sustituible por $t_i$ en $G$ y en $H$.
 4. $F \equiv \exists x G$ tal que o bien $(x=x_i)$, o bien $(x \neq x_i) \wedge (x \textit{ no ocurre en } t_i) \wedge (x_i \textit{ es sustituible en G})$.
 5. $F \equiv \forall x G$ tal que o bien $(x=x_i)$, o bien $(x \neq x_i) \wedge (x \textit{ no ocurre en } t_i) \wedge (x_i \textit{ es sustituible en G})$.

 De ahora en adelante, cuando escribamos $F\{x/t\}$ supondremos que $x$ es sustituible por $t$ en $F$.

 [*NOTA:* Si dada una fórmula $F(x_1, \ldots, x_n)$, el orden de las variables está claro podemos abreviar $F\{x_1/t_1, \ldots, x_n/t_n\}$ por $F(t_1, \ldots, t_n)$]

 $\longrightarrow$ <u>Sustituciones en LogicUS</u>

Según lo estudiado, las sustituciones establecen una correspondencia entre dos elementos, incluso notadas como un conjunto de pares variable-término. Esto es directamente expresable en el *Elm* como *List Variable Term*, incluso si tomamos únicamente las *Strings* de las variables podríamos expresarlo como *List String Term* o mejor como *Dict String Term* (que no permite elementos repetidos en la clave (*String*)):

    type alias Substitution = Dict String Term

De forma que podemos definir una sustitución a través de la función *Dict.fromList*. Por ejemplo, definamos la sustitución $\theta = \{x/(x+y), z/\boldsymbol{0}, u/z\}$

```elm {l context="16"}
import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Dict exposing (..)

theta : Substitution
theta =  Dict.fromList [("x", Func "+" [Var "x", Var "y"]), ("z", Func "0" []), ("u", Var "z")]

```
Aunque no resulta demasiado engorrosa esta definición de las sustituciones se ha provisto un parser en la función *fromStringToSubstitutionLPO* para poder definir más cómodamente las sustituciones siguiendo la notación según el patrón:
<center><i>{[variable] / [término], [variable] / [término], ..., [variable] / [término]}</i></center>

Tal que:

- Se nota como una secuencia escrita entre llaves y separada por comas.
- Los elementos de la secuencia corresponden a pares variable término, separados por ' / ', de forma que la variable ha de seguir los criterios dados, anteriormente, para la sintáxis de variables y los términos, análogamente, la sintáxis dada para la definición de términos.

Así la sustitución anterior se puede dar como:

```elm {l context="16"}

theta2 : Substitution
theta2 =  fromStringToSubstitutionLPO "{x/_+[x;y;], z/_0 , u/z}" |> extractReadSubstitutionLPO

```

^^^elm {m=(Debug.toString(theta2)) context="16"}^^^

*(NOTA: Recuérdese que las constantes se definiían como funciones sin argumentos, esto seguidas de un espacio.)*

$-$ *Aplicación de sustituciones a funciones*

La librería Logicus provee la función *applySubsToFormula* que permite aplicar una sustitución a una fórmula siguiendo los criterios estudiados anteriormente. Dada la definición recursiva de sustitución y término la implementación es directamente la aplicación de esa definición, tanto para los términos como para las fórmulas.

    applySubsToVar : Substitution -> Variable -> Term
    applySubsToVar s x = Maybe.withDefault x <| Dict.get (getVarSymb x) s
    
    applySubsToTerm : Substitution -> Term -> Term
    applySubsToTerm s t=
        case t of
            Var _ -> applySubsToVar s t
            Func sf ts -> Func sf (List.map (\term -> applySubsToTerm s term) ts)
    
    applySubsToFormula : Substitution -> FormulaLPO -> FormulaLPO
    applySubsToFormula s f =
        case f of
            Pred n ts ->  Pred n <| List.map (\t -> applySubsToTerm s t) ts
            Equal t1 t2 -> Equal (applySubsToTerm s t1)  (applySubsToTerm s t2)
            Neg p ->  Neg <| applySubsToFormula s p
            Conj p q -> Conj (applySubsToFormula s p) (applySubsToFormula s q)
            Disj p q -> Disj (applySubsToFormula s p) (applySubsySubsToFormula : SubstitToFormula s q)
            Impl p q -> Impl (applySubsToFormula s p) (applySubsToFormula s q)
            Equi p q -> Equi (applySubsToFormula s p) (applySubsToFormula s q)
            Exists v p ->
                let
                    s2 = Dict.filter (\ k _ -> k /=  getVarSymb v) s
                in
                    Exists v (applySubsToFormula s2 p)
            Forall v p ->  
                let
                    s2 = Dict.filter (\ k _ -> k /=  getVarSymb v) s
                in
                    Forall v (applySubsToFormula s2 p)
            Insat -> Insat

De forma que, por ejemplo, para aplicar la sustitución  $\theta = \{x/(x+y), y/\boldsymbol{0}, u/\boldsymbol{1}\}$ a la fórmula $F \equiv Z(x) \wedge Z(y) \rightarrow \exists z \, ((x·y)=z \wedge Z(z))$ (*el producto de números enteros es interno*).

```elm {l context="17"}
import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Dict exposing (..)

f : FormulaLPO
f = fromStringToFLPO "Z[x;] AND Z[y;] IMPLIES EXISTS{z} ((_·[x;y;]=z) AND Z[z;])" |> extractReadFLPO

theta : Substitution
theta =  fromStringToSubstitutionLPO "{x/_+[x;y;], y/_0 , z/_0}" |> extractReadSubstitutionLPO

f2 = applySubsToFormula theta f
```
^^^elm {m=(toLatexFLPO f2) context="17"}^^^

### Semántica de la Lógica de Primer Orden

Vista la forma en la que se escriben y se leen las fórmulas en la Lógica de Primer, el objetivo de la semántica es dotar de significado a los términos y fórmulas de un Lenguaje de Primer Orden. Para ello vamos a ver los elementos que conforman la semántica:

> Sea $L$ un lenguaje de primer orden. Una **$L$–estructura** (o $interpretación$) corresponde a un par $\mathcal{M}= (M, I)$ donde $M$ es un conjunto no vacío llamado **universo** (o dominio) de la $L$-estructura e $I$ es una aplicación tal que:
>1. Aporta una interpretación para cada constante, dicha interpretación se denota por $c^{\mathcal{M}}$, de forma que $\forall c \in L: \, c^\mathcal{M} \in M$. Esto es, a cada constante le asigna uno y sólo uno de los elementos del universo.
>2. Aporta una interpretación para cada uno de los símbolos de función en $L$, tal que si $f$ corresponde a un símbolo de función $n$-aria ($n>0$): $f^{\mathcal{M}} : M^{n} \longrightarrow M$
>3. Aporta una interpretación booleana para cada uno de los símbolos de predicado en $L$, tal que si $P$ corresponde a un símbolo de predicado $n$-ario: $f^{\mathcal{M}} : P^{n} \longrightarrow \{0,1\}$, O equivalente se puede dar una interpretación de que conjuntos $n$-arios cumplen dicho predicado de forma que $P^{n} \subseteq M^{n} $.
>En caso de trabajar con un LPO con igualdad: $=^{\mathcal{M}}: \{(a,a): a \in M\} $.

(Para facilitar la lectura, si no hay ambigüedad escribiremos $M$ en vez de $\mathcal{M}$)

Vamos a exponer algunos ejemplos de $L$-estructuras.

Tomemos el lenguaje $LA = \{\underbrace{\boldsymbol{0}, \boldsymbol{1}}_{const.}, \overbrace{<^{\left(2\right)} , =^{\left(2\right)}}^{pred.}, \underbrace{·^{\left(2\right)}, +^{\left(2\right)}}_{func.}\}$

Una $L$-estructura podría ser: $$ \mathcal{M_1} = \left\lbrace\begin{array}{l} M_1 = \mathbb{N} \\ \boldsymbol{0}^{M_1} = 0; \boldsymbol{1}^{M_1} = 1; \\ +^{M_1} : \mathbb{N^2} \longrightarrow \mathbb{N}, \, +^{M_1}(n_1, n_2) =  n_1 + n_2 \\ ·^{M_1} : \mathbb{N^2} \longrightarrow \mathbb{N}, \, ·^{M_1}(n_1, n_2) =  n_1 · n_2 \\ <^{M_1} : \mathbb{N^2} \longrightarrow Bool, \, <^{M_1} = \{(i,j): (i,j) \in \mathbb{N^2} \wedge (i < j)\}  \\  =^{M_1} : \mathbb{N^2} \longrightarrow Bool, =^{M_1} = \{(i,i) : i \in \mathbb{N}\}  \\ \end{array}\right.$$

Pero otra podría corresponder a: $$ \mathcal{M_2} = \left\lbrace\begin{array}{l} M_2 = \mathbb{Q} \\ \boldsymbol{0}^{M_2} = \frac{1}{2}; \boldsymbol{1}^{M_2} = 2; \\ +^{M_2} : \mathbb{Q}^2 \longrightarrow \mathbb{Q}, \, +^{M_2}(n_1, n_2) =  | n_1 - n_2 | \\ ·^{M_2} : \mathbb{Q}^2 \longrightarrow \mathbb{Q}, \, ·^{M_2}(n_1, n_2) =  n_1 \\ <^{M_2} : \mathbb{Q}^2 \longrightarrow Bool, \, <^{M_2} = \{(i,j): (i,j) \in \mathbb{Q^2} \wedge (i · j > 0)\}  \\  =^{M_2} : \mathbb{Q^2} \longrightarrow Bool, =^{M_2} = \{(i,i) : i \in \mathbb{N}\}  \\ \end{array}\right.$$

Recordemos que el predicado de igualdad es invariante en cualquier $L$-estructura y expresa la igualdad entre objetos.

$\longrightarrow$ <u>$L$-estructuras en logicus</u>

Como hemos señalado una $L$-estructura se compone de 2 elementos un universo y una interpretación, de forma que:

    type alias L_estructure a = (Universe a , Interpretation a)

El universo correspondía a un conjunto de objetos:

    type alias Universe a = List a

Las interpretaciones corresponden a la definición de aplicaciones de $U^n \longrightarrow U$ para los símbolos de funciones y $U^n \longrightarrow Bool$ para los símbolos de predicados. Luego:

    type alias Interpretation a =
        { i_const : Dict String a
         , i_funct : Dict String ((List a) -> a)
         , i_pred : Dict String ((List a) -> Bool)
        }

Esto nos permite definir toda $L$-estructura sobre universos finitos, por ejemplo, tomando el lenguaje de la aritmética y la $L$-estructura (de forma que cada elemento del universo tiene asociada la constante correspondiente):

$$ \mathcal{M} = \left\lbrace\begin{array}{l} M = \mathbb{N_{10}} \\ +^{M} : \mathbb{(N_{10})^2} \longrightarrow \mathbb{N_{10}}, \, +^{M}(n_1, n_2) =  n_1 + n_2 \\ ·^{M} : \mathbb{(N_{10})^2} \longrightarrow \mathbb{N_{10}}, \, ·^{M}(n_1, n_2) =  n_1 · n_2 \\ <^{M} : \mathbb{(N_{10})^2} \longrightarrow Bool, \, <^{M}(n_1, n_2) = n_1 < n_2  \\  =^{M} : \mathbb{(N_{10})^2} \longrightarrow Bool, =^{M}(n_1, n_2) = (n_1 = n_2)  \\ \end{array}\right.$$

Recordemos que el predicado de igualdad no necesita definición y que las constantes en logicus también se definen como funciones, de forma que:

```elm {l context="18"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Dict exposing (..)

m : Universe Int
m = [0,1,2,3,4,5,6,7,8,9,10]

isuma : List Int -> Int
isuma ls = List.sum ls

iprod : List Int -> Int
iprod ls = List.product ls

imenor : List Int -> Bool
imenor ls=
  case ls of
    [x,y] -> x < y
    _ -> False

i : Interpretation Int
i = { i_const = Dict.fromList <| List.map (\x -> (String.fromInt x, x)) m
    , i_funct = Dict.fromList [("+", isuma), ("·", iprod)]
    , i_pred = Dict.fromList [("<", imenor)]}

m_estr : L_estructure Int
m_estr = (m, i)
```
^^^elm {m=(Debug.toString m_estr) context="18"}^^^

#### Interpretación de las fórmulas en LPO

Antes de explicar la interpretación de las fórmulas vamos ver cómo se interpretar los términos que las conforman:

> Dada una $L$-estructura $\mathcal{M}$ a cada término término $t$ de $L$, **sin variables** , le corresponde un objeto o elemento de $M$, que viene dado por la interpretación de la $L$-estructura ($t^{\mathcal{M}}$), de forma que: $$t^{\mathcal{M}} = \left\lbrace \begin{array}{ll} c^{\mathcal{M}} & \textrm{si } t \equiv c \, (\textrm{con } c=cte) \\ f^{\mathcal{M}}(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) & \textrm{si } t \equiv f(t_1, \ldots, t_n) \end{array}\right.$$

De forma que una vez interpretados los términos, podemos llevar a cabo la interpretación de las fórmulas, de forma que:

> Dada una $L$-estructura $\mathcal{M}$ decimos que una fórmula **cerrada**, $F$, se satisface en $\mathcal{M}$ (y se denota por $\mathcal{M} \models F$) si se da alguno de los siguientes supuestos:
> 1. $F \equiv P(t_1, \ldots, t_n)$ y además $P^{\mathcal{M}}(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) = True$ o, equivalentemente, $(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) \in P^\mathcal{M}$
> 2. $F \equiv \neg F_1$ y además $\mathcal{M} \not \models F_1$
> 3. $F \equiv F_1 \vee F_2$ y se tiene que  $\mathcal{M} \models F_1$ o  $\mathcal{M} \models F_2$ (análogo para el resto de conectivas).
> 4. $F \equiv \exists x \, F_1$ y además hay algún elemento $e \in M$ (representado por el término $e$) tal que $\mathcal{M} \models F_1\{x/e\}$.
> 5. $F \equiv \forall x \, F_1$ y además todo elemento $e \in M$ (representado por el término $e$) verifica $\mathcal{M} \models F_1\{x/e\}$.

En caso de que $F$ no sea cerrada se tiene, por definición:

$$\left( \mathcal{M} \models F \right) \Leftrightarrow \left(\mathcal{M} \models \forall{x_1, \ldots, x_n} F(x_1, \ldots, x_n)\right)$$

$\longrightarrow$ <u>Interpretación de términos y fórmulas en Logicus</u>

Acudiendo a la definición expuesta:

    interpretsTerm : Term -> Interpretation a ->  Maybe a
    interpretsTerm t i =
        case t of
            Var _ -> Nothing
            Func s [] -> Dict.get s i.i_const
            Func s args ->         
                let f = Dict.get s i.i_funct in
                    case f of
                        Nothing -> Nothing
                        Just x ->
                            let ls = List.map (\t2 -> interpretsTerm t2 i) args in
                                if List.any isNothing ls then
                                    Nothing
                                else
                                    Just <| x (values ls)

(Recuérdese que sólo se admiten interpretaciones sobre términos sin variables, luego, si en un término aparecen variables no es posible realizar su interpretación por lo que el objeto devuelto corresponde a un objeto vacío.)

Análogamente, según la definición recursiva dada para la interpretación de las fórmulas:

    interpretsFLPO : FormulaLPO -> L_estructure a -> Maybe Bool
    interpretsFLPO f estr = interpretsFLPOAux (universalClausureFLPO f) estr
    
    interpretsFLPOAux : FormulaLPO -> L_estructure a -> Maybe Bool
    interpretsFLPOAux f (m,i) =
        case f of
            Pred sp terms ->
                let ip = Dict.get sp i.i_pred in
                    case ip of
                        Nothing -> Nothing
                        Just x ->
                            let ls = List.map (\t -> interpretsTerm t i) terms in
                                if List.any isNothing ls then
                                    Nothing
                                else
                                    Just <| x (values ls)
            Equal t1 t2->
                let it1 = interpretsTerm t1 i
                    it2 = interpretsTerm t2 i
                in
                    if isNothing it1 || isNothing it2 then
                        Nothing
                    else Just  (it1 == it2)
    
            Neg f1 -> andThen (\if1 -> Just (not if1)) (interpretsFLPOAux f1 (m,i))
            Conj f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x && y)
            Disj f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x || y)
            Impl f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (not x || y)
            Equi f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x == y)
            Exists v f1 ->
                let ls = combine <| List.map (\o -> interpretsFLPOAux (applySubsToFormula (Dict.singleton (getVarSymb v) (Func o [])) f1) (m,i)) (Dict.keys i.i_const)in
                    case ls of
                        Nothing -> Nothing
                        Just li -> Just <| List.any (\x -> x) li
            Forall v f1 ->
                let ls = combine <| List.map (\o -> interpretsFLPOAux (applySubsToFormula (Dict.singleton (getVarSymb v) (Func o [])) f1) (m,i)) (Dict.keys i.i_const)in
                    case ls of
                        Nothing -> Nothing
                        Just li -> Just <| List.all (\x -> x) li
            Insat -> Just False

(De forma que la función devolverá un objeto vacío si existe algún símbolo en la fórmula que no esté recogido en la $L$-estructura, por tanto imposible de interpretar).

Veámos algunos ejemplos, probando si se cumplen algunas propiedades sobre el ejemplo anterior:

1. El elemento neutro de la suma es el 0: $\forall x \in \mathbb{N}_{10}: \, (x+0)=x$

```elm {l context="18"}

f1 = fromStringToFLPO "_+[x;_0;] = _0 " |> extractReadFLPO

-- Ejecutamos interpretsFLPO f1 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f1 m_estr) context="18"}^^^

2. Todo número múltiplo de 4 es también múltiplo de 2: $\forall x (\exists y (4·y)=x \rightarrow \exists y (2·y)=x)$

```elm {l context="18"}

f2 = fromStringToFLPO "FORALL{x} (EXISTS{y} (_·[_4;y;] =x) IMPLIES EXISTS{y} (_·[_2;y;] = x))" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f2 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f2 m_estr) context="18"}^^^

Sin embargo, el recíproco no es cierto:

```elm {l context="18"}

f3 = fromStringToFLPO "FORALL{x} (EXISTS{y} (_·[_2;y;] =x) IMPLIES EXISTS{y} (_·[_4;y;] = x))" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f3 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f3 m_estr) context="18"}^^^

3. Veámos que la suma no es interna, esto es, $\neg \forall x \forall y \exists z (z = (x+y))$

```elm {l context="18"}

f4 = fromStringToFLPO "NOT FORALL{x} FORALL{y} EXISTS{z} (z=_+[x;y;])" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f4 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f4 m_estr) context="18"}^^^

4. Veámos que no se tiene que para todo número existe uno que es mayor, $\forall x \exists y (x < y)$
```elm {l context="18"}

f5 = fromStringToFLPO "FORALL{x} EXISTS{y} (<[x;y;])" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f5 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f5 m_estr) context="18"}^^^

####  Satisfactibilidad, Validez y Consecuencia Lógica en LPO

Igual que veíamos que una fórmula en LP es satisfactible si existía al menos un modelo, en LPO se dice que una fórmula es **satisfactible** si existe, al menos, un modelo para dicha fórmula, esto es si existe una $L$-estructura en la que se satisface ($\mathcal{M} \models F$). De forma análoga un conjunto de fórmulas $\Sigma$ es **consistente** si existe una $L$-estructura tal que toda fórmula de $\Sigma$ se satisface en $\mathcal{M}$

Una fórmula se dice **lógicamente válida** si para toda $L$-estructura ($\mathcal{M}$) se tiene $\mathcal{M} \models F$ (por ejemplo, $\forall{x} P(x) \vee \exists x \neg P(x)$)

Por último, de igual forma que veíamos el concepto de consecuencia lógica en LP, en LPO se tiene que una fórmula $F$ es **consecuencia lógica** de un conjunto de fórmulas $\Sigma$ (y se denota por $\Sigma \models F$) si se tiene que para toda $L$-estructura $\mathcal{M}$, $\mathcal{M} \models \Sigma \Rightarrow \mathcal{M} \models F$

Al contrario que en LP, en el que existían algoritmos (aunque ineficientes) que permitían determinar los problemas de consistencia y consecuencia lógica, en LPO este mismo problema no es decidible, esto es no existen algoritmos que permitan determinar, de forma completa, la consistencia de un conjunto de fórmulas (equivalente al problema de la consecuencia lógica).

Durante los siguientes temas estudiaremos algoritmos que tratarán de resolver el problema, aunque no sean decisivos en todos los casos.
