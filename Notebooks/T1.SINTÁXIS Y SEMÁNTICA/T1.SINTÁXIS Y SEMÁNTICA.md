---
elm:
  source-directories:
    - ../../elm-sources/src
  dependencies:
      elm/browser: latest
      elm/core: latest
      elm/file: latest
      elm/html: latest
      elm/parser: latest
      elm-community/graph: latest
      elm-community/list-extra: latest
      elm-community/maybe-extra: latest
      munksgaard/char-extra: latest
      gicentre/elm-vegalite: latest
      avh4/elm-fifo: latest
      elm/bytes: latest
      elm/json: latest
      elm/time: latest
      elm/url: latest
      elm/virtual-dom: latest
      elm-community/intdict: latest
      Chadtech/elm-bool-extra: latest
---

<!-- Cargamos algunas funciones js que necesitamos -->

<script src="../js/d3.min.js"></script>
<script src="../js/viz.js" type="javascript/worker"></script>
<script src="../js/d3-graphviz.js"></script>
<script type="text/javascript">

    function plotDot(graphId){
        d3.select('#svgContainer' + graphId)
        .graphviz()
        .renderDot(document.getElementById("inDOT" + graphId).value.replace(/\\n/g, "\n").replace(/\\"/gm, '"'));
    
        document.getElementById("outputGraph" + graphId).style.display = "inline-block";
        document.getElementById("inputGraph" + graphId).style.display = "none";
    };
    
    function generatePng(graphId){
        var svgElement = document.getElementById('svgContainer' + graphId).querySelector('svg');
        var svgString = new XMLSerializer().serializeToString(svgElement);
        var canvas = document.getElementById("canvas" + graphId);
        canvas.width = svgElement.getBBox().width*1.33;
        canvas.height = svgElement.getBBox().height*1.33;
        var ctx = canvas.getContext("2d");
        var DOMURL = self.URL || self.webkitURL || self;
        var img = new Image();
        var svg = new Blob([svgString], {type: "image/svg+xml;charset=utf-8"});
        var url = DOMURL.createObjectURL(svg);
        img.onload = function() {
            ctx.drawImage(img, 0, 0);
            var png = canvas.toDataURL("image/png");
    
            document.querySelector("#pngContainer" + graphId).innerHTML = '<a id="downloadPNG'+ graphId +'" href="'+png+'" download/> PNG Image </a>';
            imgdownload = document.getElementById("downloadPNG"+ graphId)
            imgdownload.click();
            DOMURL.revokeObjectURL(png);
        };
        img.src = url;
    };
</script>


# Tema 1: Sintaxis y Sem√°ntica en LP y LPO

## Descripci√≥n general del cap√≠tulo

Como hemos visto en el tema anterior (LINK) hay varias posibles aproximaciones a la L√≥gica como herramienta formal para representar y formalizar tanto el conocimiento como los m√©todos de obtenci√≥n de nuevas verdades de forma deductiva. En este sentido, nosotros vamos a considerar a lo largo de nuestra aproximaci√≥n un problema que a√∫na estos esfuerzos dentro de lo que podemos considerar *el problema central de la deducci√≥n*, y que se puede expresar como sigue:

> *Dado un conjunto de asertos (afirmaciones que conforman nuestro conocimiento en un determinado √°mbito),y que denotaremos por $\mathcal{BC}$ (por *Base de conocimiento*), y una afirmaci√≥n adicional, $\mathcal{A}$, el problema central que queremos abordar es el de decidir si $\mathcal{A}$ ha de ser necesariamente cierta supuesto que son ciertas todas las afirmaciones de $\mathcal{BC}$.*


Si queremos tener la seguridad de que el problema anterior lo abordamos adecuadamente, es necesario disponer de los siguientes elementos:

-   Un lenguaje que permita expresar de manera formal y precisa las afirmaciones, hechos e hip√≥tesis. (las reglas que establecen la correcci√≥n de las expresiones que usemos es lo que denominaremos como **Sintaxis**).

-   Una definici√≥n clara de qu√© se considera *afirmaci√≥n cierta*  (las reglas que establecen la veracidad de las expresiones que usemos es lo que denominaremos como **Sem√°ntica**).

-   Mecanismos efectivos (y, en la medida de lo posible, eficientes) que garanticen la *correcci√≥n* (y, cuando sea posible, la *completitud*) de las deducciones obtenidas (estos mecanismos los daremos por medio de los que denominaremos **Algoritmos de decisi√≥n**).

A lo largo de los siguientes cap√≠tulos abordaremos estos puntos para las dos l√≥gicas m√°s comunes que se usan: la **L√≥gica Proposicional** (*LP*, o *PL*, por sus siglas en ingl√©s) y la **L√≥gica de Primer Orden** (*LPO*, o *FOL*, por sus siglas en ingl√©s).

Nuestro objetivo central en este primer cap√≠tulo ser√° presentar los dos primeros elementos para est√°s l√≥gicas, aunque veremos que esta tarea, de forma natural, nos permitir√° introducirnos superficialmente (aunque, de forma muy fundamental desde el punto de vista conceptual) en el tercero de los elementos, pero ser√°n los siguientes cap√≠tulos los que est√©n dedicados casi en su totalidad en el desarrollo de los algoritmos de decisi√≥n y otras t√©cnicas que faciliten el camino hacia las soluciones que proporcionaremos para el problema central anterior.

### LogicUS

Pero la novedad que ofrece este texto frente a otras aproximaciones a la L√≥gica Proposicional y De Primer Orden es que iremos entrelazando los conceptos con una implementaci√≥n computacional de todos los conceptos y m√©todos que iremos viendo a lo largo del texto. As√≠, en este cap√≠tulo veremos, de forma detallada, los m√≥dulos implementados que reflejan tanto la sintaxis como la sem√°ntica de ambas l√≥gicas: 

-   **M√≥dulo SintaxSemanticsLP**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sint√°cticos y sem√°nticos de la LP.

-   **M√≥dulo SintaxSemanticsLPO**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sint√°cticos y sem√°nticos de la LPO.

-   **M√≥dulo IO\_LP**. Recoge las implementaciones de los m√©todos relacionados con la lectura y representaci√≥n de las f√≥rmulas LP.

-   **M√≥dulo IO\_LPO**. Recoge las implementaciones de los m√©todos relacionados con la lectura y representaci√≥n de las f√≥rmulas LPO.

Complementariamente, en el *Anexo A. Parsers* se ofrece el desarrollo de varias herramientas que permiten usar una escritura m√°s natural de las f√≥rmulas, m√°s cercana a la que se usa en la representaci√≥n matem√°tica est√°ndar.


## Fundamentos de L√≥gica Proposicional

Vamos a abordar desde un punto de vista te√≥rico-pr√°ctico, los elementos base que conforman la L√≥gica Proposicional, esto es la S√≠ntaxis y la Sem√°ntica, mostrando unificadamente los desarrollos formales y las implementaciones llevadas a cabo para modelar cada uno de ellos en LogicUS.

### Caracter√≠sticas fundamentales

La L√≥gica Proposicional comienza a desarrollarse en la Grecia antigua y, aunque su formalizaci√≥n puede haber variado a lo largo de los siglos para acondicionarla a los nuevos tiempo, esencialmente seguimos usando el mismo esquema sint√°ctico y bajo los mismos par√°metros. Es la l√≥gica m√°s simple que podemos considerar, con unos elementos m√°s r√≠gidos que otras aproximaciones y, por tanto, ofreciendo una menor capacidad expresiva. Esta es la raz√≥n por la que ha sufrido ampliaciones (LPO es realmente una ampliaci√≥n de LP, pero hay otras) que han tenido como objetivo  aplicar la l√≥gica a problemas m√°s complejos. Pero tambi√©n es cierto que, gracias a esta simplicidad, presenta caracter√≠sticas que la hacen especialmente adecuada a su implementaci√≥n computacional ya que, como veremos m√°s adelante, disponemos de herramientas completas para su mainpulaci√≥n sint√°ctica y sem√°ntica. 

Informalmente, las caracter√≠sticas m√°s importantes que definen a la L√≥gica Proposicional son:

-   Sus expresiones (denominadas f*√≥rmulas proposicionales* o *proposiciones*) modelan afirmaciones que pueden considerarse *ciertas* o *falsas*. No hay posibles estados intermedios ni distintos, cada afirmaci√≥n del lenguaje solo tiene esas dos opciones.

-   Las f√≥rmulas proposicionales (en adelante f√≥rmulas, si no existe ambig√ºedad) se construyen mediante un conjunto de expresiones  b√°sicas (*f√≥rmulas at√≥micas* o *√°tomos*) y un conjunto de operadores (*conectivas l√≥gicas*). Las conectivas disponibles permiten modelar los siguientes tipos de afirmaciones:

    -   *Conjunci√≥n*: ‚Äò... tal ... Y ... cual ...‚Äô

    -   *Disyunci√≥n*: ‚Äò... tal ... O ... cual ...‚Äô

    -   *Implicaci√≥n*: ‚ÄòSI tal ... ENTONCES ... cual ...‚Äô

    -   *Equivalencia*: ‚Äò... tal ... SI Y S√ìLO SI ... cual ...‚Äô

    -   *Negaci√≥n*: ‚ÄòNO es cierto tal ...‚Äô

    Profundizaremos en este aspecto en la pr√≥xima secci√≥n, cuando presentemos la *Sintaxis Formal de la LP*.

-   El lenguaje s√≥lo permite modelar este tipo de afirmaciones, por lo que muchas veces puede ser dif√≠cil (o imposible) representar algunos problemas en este tipo de L√≥gica, y es necesario recurrir a otras formalizaciones m√°s expresivas (como el propio *LPO*, las conocidas como *L√≥gicas Modales*, la *L√≥gica Difusa*, etc.). Veremos limitaciones espec√≠ficas m√°s adelante, que nos servir√°n para justificar las ampliaciones que aporta LPO.

-   Aunque esta L√≥gica puede resultar de una aparente sencillez, veremos que hay ciertos restos que ya aparecen en ella (como el problema *SAT*) y que caen dentro de la categor√≠a de problemas **NP**-completos, esto es, problemas complejos para los que no se conocen algoritmos eficientes (en tiempo polinomial) para resolverlos. Trataremos de nuevo este aspecto en la introducci√≥n a los algoritmos de decisi√≥n. De hecho, $SAT$ fue el primer problema que se demostr√≥ matem√°ticamente dentro de esa clase de complejidad. 


### Sint√°xis de la l√≥gica Proposicional

#### El alfabeto proposicional

El concepto ‚Äò*alfabeto proposicional*‚Äô referencia al conjunto de s√≠mbolos que forman parte de este lenguaje. En la L√≥gica Proposicional podemos distinguir las siguientes categor√≠as:

-   **Variables proposicionales** o **√°tomos**. Ya hemos se√±alado previamente que todo problema est√° representado por relaciones entre un conjunto finito de afirmaciones b√°sicas, en LP estas afirmaciones se representan por s√≠mbolos proposicionales de un conjunto infinito: $VP = \{p_0, p_1, \ldots, p, q, r\}$. 

    Aunque formalmente no existe ninguna restricci√≥n, en LogicUS vamos a adoptar el siguiente criterio en relaci√≥n a la sintaxis de los s√≠mbolos proposicionales:

    > Los s√≠mbolos proposicionales deben comenzar por una letra min√∫scula, seguida (opcionalmente) de otros caract√©res en min√∫scula o d√≠gitos num√©ricos, exclusivamente.

-   **Conectivas L√≥gicas**. Modelan las relaciones entre las distintas afirmaciones b√°sicas (√°tomos) y, seg√∫n el n√∫mero de operandos sobre los que act√∫an (aridad), podemos distinguir:

    -   De aridad 1 (o monoaria) : *Negaci√≥n* ($\neg$).

    -   De aridad 2 (o binarias): *Conjunci√≥n* ($\wedge$), *Disyunci√≥n* ($\vee$), *Condicional* ($\rightarrow$), *Bicondicional* ($\leftrightarrow$).

-   **S√≠mbolos Auxiliares**: ‚Äò$($‚Äô y ‚Äò$)$‚Äô. Permiten expresar relaciones de prioridad entre conectivas l√≥gicas y evitar la ambigi√ºedad en la interpretaci√≥n de las f√≥rmulas.

#### F√≥rmulas Proposicionales

En todos los lenguajes formales una **expresi√≥n** es una sucesi√≥n finita (y no vac√≠a) de s√≠mbolos del lenguaje. Por tanto, en el lenguaje de LP, tanto "$a \rightarrow b )ca\vee$" como "$(a \rightarrow b ) \vee c$" son expresiones. Sin embargo, parece claro que la segunda de ellas muestra ‚Äúuna coherencia‚Äù o ‚Äúequilibrio" que no parece tener la primera, por lo que no todas las expresiones tienen el mismo valor para nosotros. De esta forma, a las expresiones "bien formadas", aquellas que muestran una coherencia informativa que podemos utilizar, las denominaremos **f√≥rmulas proposicionales**, pero hay que dar alg√∫n procedimiento efectivo que permita diferenciar formalmente las expresiones bien formadas de las que no, as√≠ que podemos definir:

> Formalmente, el conjunto de las f√≥rmulas proposicionales, $PROP$, es el menor conjunto de expresiones que verifica:
> - $VP \subseteq PROP$
> - Es cerrado bajo las conectivas l√≥gicas, es decir:
    - Si una f√≥rmula $F \in PROP$, entonces $\neg F \in PROP$
    - Si las f√≥rmulas $F, G \in PROP$, entonces $(F \wedge G), (F \vee G), (F \rightarrow G), (F \leftrightarrow G) \in PROP$

Aunque esta definici√≥n puede resultar un poco oscura, nos ofrece un camino constructivo de reconocer las expresiones bien formadas de las que no lo son (formalmente, decimos que ofrece una definici√≥n recursiva): partiendo de las f√≥rmulas bien construidas m√°s peque√±as posibles, los √°tomos, podemos construir nuevas f√≥rmulas m√°s grandes bien construidas aplicando conectivas sobre una o dos f√≥rmulas bien construidas m√°s peque√±as (ser√°n una o dos dependiendo de la aridad de la conectiva utilizada).

##### √Årboles de formaci√≥n

Siguiendo los pasos de construcci√≥n, cada f√≥rmula se puede asociar a un grafo de tipo √°rbol (esencialmente √∫nico, salvo diferencias de orden), que muestra el desarrollo de formaci√≥n de la f√≥rmula.

Por ejemplo a la f√≥rmula: $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$ tiene asociada el **√°rbol de formaci√≥n** siguiente:

<center> <img src="images/T1Img1.png" title="√Årbol formaci√≥n (ejemplo)"></center><br>

Las distintas f√≥rmulas que aparecen en los nodos del √°rbol de formaci√≥n de una f√≥rmula $F$ se denominan **subf√≥rmulas** de $F$.

##### Prioridad de conectivas y Reducci√≥n de par√©ntesis.

Para facilitar la escritura y lectura de las f√≥rmulas podemos adoptar algunos criterios adicionales que permitir√°n simplificar su expresi√≥n reduciendo el n√∫mero de par√©ntesis que se usan en su representaci√≥n formal:

1.  Omitimos los par√©ntesis m√°s exteriores de la f√≥rmula. Por ejemplo, $F\vee G$ es una representaci√≥n alternativa de $(F\vee G)$.
2.  Tomaremos como orden de precedencia de las conectivas (de mayor a menor precedencia): $\neg$, $\wedge$, $\vee$ , $\rightarrow$, $\leftrightarrow$. Para la conectiva $\leftrightarrow$ se recomienda mantener los par√©ntesis en todos los casos. Por ejemplo, $F\wedge G \rightarrow H$ es una representaci√≥n alternativa de $((F\wedge G) \rightarrow H)$).
3.  Cuando una conectiva se usa repetidamente, se asocia por la derecha. Por ejemplo, $F_1 \wedge F2 \wedge F_3$ es una representaci√≥n alternativa de $(F_1 \wedge (F2 \wedge F_3))$.

##### Principio de inducci√≥n sobre f√≥rmulas

Gracias a la definici√≥n de $PROP$ (y su estructura recursiva), para probar que toda f√≥rmula proposicional satisface una cierta propiedad ($\Psi$), podemos hacerlo aplicando el m√©todo de inducci√≥n sobre f√≥rmulas.

De esta forma, si queremos probar que todas las f√≥rmulas de $PROP$ verifican $\Psi$ basta:

1.  *Caso base*: Probar que todos los elementos de $VP$ verifican la propiedad $\Psi$.

2.  *Paso de inducci√≥n*:
-  Si $F \in PROP$ verifica la propiedad $\Psi$, entonces $\neg F$ verifica la propiedad $\Psi$.
   
-  Si $F, G \in PROP$, verifican la propiedad $\Psi$ entonces $(F \wedge G)$, $(F \vee G)$, $(F \rightarrow G)$, $(F \leftrightarrow G)$  verifican la propiedad $\Psi$.

##### Escritura de las f√≥rmulas en LogicUS

Vamos a exponer cu√°l es la sintaxis de las f√≥rmulas utilizando la librer√≠a Logicus, que nos permitir√° definir f√≥rmulas y posteriormente aplicar diversos algoritmos sobre ellas.

En la librer√≠a podemos definir las f√≥rmulas de dos formas distintas, o bien acudiendo directamente a los constructores internos de las f√≥rmulas (un proceso largo y engorroso), o bien utilizando un Parser (m√°s similar a la escritura natural de las f√≥rmulas).

###### Definici√≥n de f√≥rmulas

Si recordamos la definici√≥n recursiva que se ha dado para las f√≥rmulas, expusimos que las mismas pueden corresponder o bien a √°tomos (*caso base*), o bien a la aplicaci√≥n de las conectivas, teniendo en cuenta la aridad de √©stas, sobre f√≥rmulas proposicionales (*caso recursivo*).

Siguiendo el m√©todo constructivo asociado al √°rbol de formacion, la implementaci√≥n para las f√≥rmulas que la librer√≠a proporciona ofrece dos constructores para, respectivamente, generar √°tomos o aplicar conectivas:

- Los s√≠mbolos proposicionales se definen como cadenas de caract√©res (con la restricci√≥n de que deben usar min√∫sculas):

        type alias PSymb = String

- Las f√≥rmulas proposicionales se definen seg√∫n la estructura recursiva dada por:

        type FormulaLP = Atom PSymb                 -- caso base
                        | Neg FormulaLP             --‚é´
                        | Conj FormulaLP FormulaLP  --‚é™
                        | Disj FormulaLP FormulaLP  --‚é¨ casos recursivos
                        | Impl FormulaLP FormulaLP  --‚é™
                        | Equi FormulaLP FormulaLP  --‚é≠
                        | Insat                     -- f√≥rmula insatisfactible

Para poder hacer uso de LogicUS previamente se deben importar los m√≥dulos correspondientes a las funciones y tipos necesarios. Por ejemplo, para definir las siguientes f√≥rmulas en LogicUS:

a. $(p \wedge q) \vee (p \wedge r) \quad$ 

b. $ (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q \quad$ 

c. $(p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p$

Debemos escribir:

```elm {l context="1"}
import Logicus.IO_LP exposing (toLatexFLP)
import Logicus.SintaxSemanticsLP exposing (FormulaLP(..))

a : FormulaLP
a = Disj (Conj (Atom "p") (Atom "q")) (Conj (Atom "p") (Atom "r"))
```
^^^elm {m=(">" ++ toLatexFLP "a" a) context="1"}^^^

```elm {l context="1"}
b : FormulaLP
b = Impl (Disj (Conj (Atom "p") (Atom "r")) (Conj (Neg (Atom "p")) (Atom "q"))) (Neg (Atom "q"))
```

^^^elm {m=(">" ++ toLatexFLP "b" b) context="1"}^^^

```elm{l context="1"}
c : FormulaLP
c = Conj (Conj (Equi (Atom "p") (Atom "q")) (Impl (Atom "p") (Neg (Atom "q")))) (Atom "p")
```

^^^elm {m=(">" ++ toLatexFLP "c" c) context="1"}^^^

Desde luego, escribir las f√≥rmulas de esta forma puede convertirse en una tarea ardua y propensa a errores, ya que es necesario construir previamente el √°rbol de formaci√≥n y reproducirlo en el lenguaje. Por eso, se ha desarrollado un parser que permite escribir las f√≥rmulas de forma m√°s c√≥moda. Para poder utilizarlo se han establecido una serie de requisitos sint√°cticos, an√°logos a los presentados anteriormente:

- Los s√≠mbolos proposicionales deben comenzar por un caracter en min√∫scula seguido, opcionalmente, de caracteres en min√∫scula, d√≠gitos o el s√≠mbolo '_'.
- Para las conectivas se usar√°n los siguientes s√≠mbolos en may√∫sculas, manti√©ndose la prioridad de las conectivas definida anteriormente.

|           Conectiva L√≥gica           | S√≠mbolo LogicUS |
| :----------------------------------: | :-------------: |
|             ¬¨ (Negaci√≥n)             |       NOT       |
|            ‚àß (Conjunci√≥n)            |       AND       |
|            ‚à® (Disyunci√≥n)            |       OR        |
|           ü°í (Implicaci√≥n)            |     IMPLIES     |
| ü°ò (Doble Implicaci√≥n o Equivalencia) |      EQUIV      |

- Los par√©ntesis se utilizan tal y como se han definido formalmente y se pueden evitar los que vegan determinados por las leyes de precedencia. No son necesarios los par√©ntesis externos de las f√≥rmulas.

- En caso de uso repetido de una misma conectiva, se realizar√° asociaci√≥n por la derecha.

As√≠, para definir los ejemplos expuestos anteriormente podr√≠amos escribir:

```elm {l context="2"}
import Logicus.SintaxSemanticsLP exposing (FormulaLP(..))
import Logicus.IO_LP exposing (toLatexFLP, fromStringToFLP, extractReadFLP)

a : FormulaLP
a = fromStringToFLP "(p AND q) OR (p AND t)" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "a" a) context="2"}^^^
```elm{l context="2"}
b : FormulaLP
b = fromStringToFLP "(p AND r) OR (NOT p AND q) IMPLIES NOT q" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "b" b) context="2"}^^^
```elm{l context="2"}
c : FormulaLP
c = fromStringToFLP "(p EQUIV q) AND (p IMPLIES NOT q) AND p" |> extractReadFLP
```
^^^elm {m=(">" ++ toLatexFLP "c" c) context="2"}^^^

La funci√≥n `fromStringToFLP` recibe una cadena de entrada y devuelve una tupla de dos elementos: el primero de ellos corresponde a la representaci√≥n interna de la f√≥rmula le√≠da, y el segundo a una cadena de texto. Si la cadena de entrada contiene alg√∫n error sint√°ctico y no es una f√≥rmula bien formada, el Parser no ser√° capaz de interpretarla correctamente, y la funci√≥n una tupla de la forma `(Nothing,error)`, donde el segundo elemento es el mensaje de error obtenido, y el primer elemento es un objeto vac√≠o (porque no se ha generado una f√≥rmula de salida).

Nota: En lo que sigue, haremos uso del parser para definir todas las f√≥rmulas de los ejemplos que usemos.

Una vez le√≠da la f√≥rmula correctamente podemos extraerla utilizando la funci√≥n *extractReadFLP*. Si se utiliza esta funci√≥n sobre una f√≥rmula le√≠da incorrectamente, entonces se obtendr√° como f√≥rmula la f√≥rmula insatisfactible.

######  √Årboles de formaci√≥n en LogicUS

La librer√≠a tambi√©n permite obtener el √°rbol de formaci√≥n de una f√≥rmula. La funci√≥n `formtree` genera la representaci√≥n del √°rbol de formaci√≥n en formato texto DOT.

Por ejemplo, para la f√≥rmula $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$:

```elm {l context="3"}
import Logicus.IO_LP exposing (toLatexFLP, fromStringToFLP, extractReadFLP, formTree)
import Logicus.SintaxSemanticsLP exposing (FormulaLP(..))
import Logicus.AuxForLitvis exposing (showGraphViz)

a : FormulaLP
a = fromStringToFLP "NOT ( NOT (p OR q) IMPLIES (NOT r AND s))" |> extractReadFLP

fta : String
fta = formTree a
```
De forma que se obtiene:

^^^elm {m=(showGraphViz "G1" fta) context="3"}^^^

#### Conjuntos de f√≥rmulas

Definido $PROP$, los conjuntos de f√≥rmulas no son m√°s que subconjuntos de $PROP$, esto es, corresponden a agrupaciones de f√≥rmulas proposicionales.


##### Conjuntos de f√≥rmulas en LogicUS

Los conjuntos proposicionales se definen como listas de f√≥rmulas proposicionales:


    type alias LPSet = List FormulaLP

Si, por ejemplo, queremos definir el conjunto:
$$ M = \left\lbrace (p \wedge q) \vee (p \wedge r), (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q, (p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p \right\rbrace$$

Basta escribir:

```elm{l context="4"}
import Logicus.IO_LP exposing (..)
import Logicus.SintaxSemanticsLP exposing (..)

a : FormulaLP
a = fromStringToFLP "(p AND q) OR (p AND r)" |> extractReadFLP

b : FormulaLP
b = fromStringToFLP "(p AND r) OR (NOT p AND q) IMPLIES NOT q" |> extractReadFLP

c: FormulaLP
c = fromStringToFLP "(p EQUIV q) AND (p IMPLIES NOT q) AND p" |> extractReadFLP

m : LPSet
m = [a,b,c]
```

Obteniendo:

^^^elm{m=(toLatexLPSet m) context="4"}^^^

### Sem√°ntica de la L√≥gica Proposicional

#### Interpretaciones, Modelos, Satisfactibilidad y Validez L√≥gica

Tras haber visto la sintaxis, pasamos a presentar formalmente la sem√°ntica de la L√≥gica Proposicional. Como ya comentamos, hemos de abordar la interpretaci√≥n de certeza o veracidad de las f√≥rmulas. Para ello, previamente, hemos de introducir los conceptos de *valor de verdad* y *funci√≥n de verdad*.

> -  **Valor de verdad**. Los elementos del conjunto $\{0,1\}$ se denominan valores de verdad o valores booleanos. Representan si un hecho es cierto o no, de forma que el valor $1$ se asocia a *verdadero* y el valor $0$ a *falso*.
>  -   **Funciones de verdad**. Formalmente, una funci√≥n de verdad es una funci√≥n que toma valores de verdad y devuelve un valor de verdad, es decir, $f:\{0,1\}^n\mapsto \{0,1\}$, y nos servir√°n para definir la sem√°ntica dentro de las l√≥gicas booleanas. As√≠, el significado (valor de verdad asociado) de cada una de las conectivas l√≥gicas viene dado por una funci√≥n de verdad, de forma que:
      $$\begin{array}{l l} H_{\neg}(i) = \left\lbrace \begin{array}{l l}
        1 & \textrm{, si } i = 0\\
        0 & \textrm{, si } i = 1\\
        \end{array} \right. & H_{\wedge}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{, si } i = j = 1\\
        0 & \textrm{, e.o.c}\\
        \end{array} \right.\\\\ H_{\vee}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{, si } i = j = 0\\
        1 & \textrm{, e.o.c}\\
        \end{array} \right. & H_{\rightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{, si } i = 1, j = 0\\
        1 & \textrm{, e.o.c}\\
        \end{array} \right.\\\\ H_{\leftrightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{, si } i = j\\
        0 & \textrm{, e.o.c}\\
        \end{array} \right.\end{array}$$

Fijados unos valores de verdad de las variables proposicionales (es decir, una indicaci√≥n acerca de cu√°les son verdad y cu√°les no), lo que se denomina una *valoraci√≥n* o *interpretaci√≥n*, podemos extender este valor para evaluar si las f√≥rmulas proposicionales son ciertas o no bajo ese contexto. Para ello, basta usar el valor de las variables que intervienen en la f√≥mrula y las funciones de verdad de las conectivas que contiene. Adem√°s, es f√°cil probar que esta extensi√≥n es √∫nica. Si $v: VP \mapsto \{0,1\}$ es la valoraci√≥n actual de las variables proposicionales, entonces basta tener en cuenta las siguienets extensiones parciales:

$$\begin{array}{c c} v((F \wedge G))= H_{\wedge}(v(F), v(G)) & v((F \vee G))= H_{\vee}(v(F), v(G))\\\\ v((F \rightarrow G))= H_{\rightarrow}(v(F), v(G)) & v((F \leftrightarrow G))= H_{\leftrightarrow}(v(F), v(G)) \end{array}$$

Haciendo uso del √°rbol de formaci√≥n de una f√≥rmula, $F$, que ocupa el nodo ra√≠z del √°rbol, podemos ir elevando los valores de $v$ desde las hojas hasta la ra√≠z por los m√©todos anteriores, obteniendo un valor final para $F$ que representa el valor de verdad de la f√≥rmula.

Por ejemplo el c√°lculo de la valoraci√≥n de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$ (solo indicamos la valoraci√≥n de las variables que intervienen en $F$):

<center> <img src="images/T1Img3.png" title="C√°lculo de la valoraci√≥n con el AF."></center><br>

> Dada una f√≥rmula $F \in PROP$, se dice que $v(F)$ es el valor de verdad de $F$ respecto de la valoraci√≥n $v$.

Muchas veces el conjunto de c√°lculos que se realizan en el √°rbol de formaci√≥n se expresan de forma equivalente a partir de una tabla en la que se anotan en las cabeceras de las columnas las diversas subf√≥rmulas que aparecen en el √°rbol, y bajo ellas los valores de verdad que toman al ir aplicando las funciones de verdad de las conectivas. Para el ejemplo anterior:

| $p$  | $q$  | $r$  | $s$  | $\neg r$ | $p\vee q$ | $\neg(p\vee q)$ | $\neg r \vee s$ | $\neg(p\vee q) \vee \neg(r\vee s)$ | $\neg(\neg(p\vee q)\vee(\neg r\vee s))$ |
| :--: | :--: | :--: | :--: | :------: | :-------: | :-------------: | :-------------: | :--------------------------------: | :-------------------------------------: |
|  1   |  1   |  0   |  0   |    1     |     1     |        0        |        1        |                 1                  |                    0                    |

##### Tablas de Verdad

Una **tabla de verdad** es una estructura similar a la anterior (nosotros s√≥lo reflejaremos el valor de las variables proposicionales y el valor de verdad de la f√≥rmula completa), en la que cada fila presenta una posible valoraci√≥n (es decir, el valor concreto de las variables proposicionales que intervienen en la f√≥rmula) y el valor de verdad de la f√≥rmula respecto a ella.

La tabla de verdad de la f√≥rmula anterior ser√≠a:

| $p$  | $q$  | $r$  | $s$  | $\neg(\neg(p\vee q)\vee(\neg r\vee s))$ |
| :--: | :--: | :--: | :--: | :-------------------------------------: |
|  0   |  0   |  0   |  0   |                    0                    |
|  0   |  0   |  0   |  1   |                    0                    |
|  0   |  0   |  1   |  0   |                    0                    |
|  0   |  0   |  1   |  1   |                    0                    |
|  0   |  1   |  0   |  0   |                    0                    |
|  0   |  1   |  0   |  1   |                    0                    |
|  0   |  1   |  1   |  0   |                    1                    |
|  0   |  1   |  1   |  1   |                    0                    |
|  1   |  0   |  0   |  0   |                    0                    |
|  1   |  0   |  0   |  1   |                    0                    |
|  1   |  0   |  1   |  0   |                    1                    |
|  1   |  0   |  1   |  1   |                    0                    |
|  1   |  1   |  0   |  0   |                    0                    |
|  1   |  1   |  0   |  1   |                    0                    |
|  1   |  1   |  1   |  0   |                    1                    |
|  1   |  1   |  1   |  1   |                    0                    |


##### Modelos, Satisfactibilidad y Validez L√≥gica

Las valoraciones determinan de alguna forma el *contexto del mundo*, es decir, qu√© afirmaciones at√≥micas son ciertas o no en una determinada configuraci√≥n, y hemos visto que eso determina el valor de verdad de cualquier afirmaci√≥n que se pueda hacer, sea at√≥mica o no. Fijada una f√≥rmula, habr√° valoraciones en las que puede ser verdad, y otras valoraciones en las que posiblemente no lo sea. En este sentido, podemos dar las siguientes definiciones:

> -  **Modelo.** Se dice que una f√≥rmula $F$ es **v√°lida** en una valoraci√≥n $v$ o, equivalentemente, que $v$ es **modelo** de $F$, si $v(F)=1$ y se denota por $v \models F$. En caso contrario, se dice que $v$ es **contramodelo** de $F$ y se denota por $v \not \models F$.
> - **Satisfactibilidad.** Una f√≥rmula $F$ se dice **satisfactible** (o **consistente**) si existe una valoraci√≥n $v$ que es modelo de $F$ (es decir, hay un mundo en el que la f√≥rmula es verdadera). En caso contrario se dice que $F$ es **insatisfactible** (o **inconsistente**), y se denota por $\perp$.
> - **Validez l√≥gica o Tautolog√≠a**. Una f√≥rmula $F$ se dice **tautolog√≠a** (o [l√≥gicamente] v√°lida) si toda valoraci√≥n es modelo de $F$, es decir, es cierta en cualquier mundo posible, y se denota $\models F$.

###### Relaci√≥n entre Validez y Satisfactibilidad

> *LEMA*: Para cada $F \in PROP$ se verifica:
>
> -  Si $F$ es tautolog√≠a, entonces $F$ es satisfactible.
> -  $F$ es tautolog√≠a si y s√≥lo si $\neg F$ es insatisfactible.

##### Sem√°ntica de F√≥rmulas LP en LogicUS

La librer√≠a dispone de funciones que modelan todos los conceptos sem√°nticos que hemos visto hasta ahora.

###### Valores, Funciones de Verdad e Interpretaciones

Como hemos estudiado, los **valores de verdad** corresponden a 1 (*verdadero*) y 0 (*falso*). Elm ya provee esos valores booleanos en el tipo *Bool*, por lo que no es necesario realizar ninguna definici√≥n alternativa para este concepto.

Las definici√≥n de las funciones de verdad asociadas a las conectivas corresponden directamente a la aplicaci√≥n de dichas funciones en la evaluaci√≥n de las f√≥rmulas. Antes de ver la evaluaci√≥n resulta necesario ver la definici√≥n que se ha dado para las interpretaciones. Para ello, se ha elegido una representaci√≥n "dispersa" que indica por medio de una lista los s√≠mbolos proposicionales de las variables proposicionales que son verdaderas. Las variables proposicionales asociadas a s√≠mbolos que no aparecen en la lista ser√°n considerados como falsas.

    type alias Interpretation = List PSymb

Con esta definici√≥n resulta sencillo llevar a cabo la evaluaci√≥n de las f√≥rmulas siguiendo exactamente los dos pasos anotados:

- **Evaluaci√≥n de variables**. Una variable ser√° verdadera si pertenece a la lista de la interpretaci√≥n, y ser√° falsa en caso contrario.

- **Evaluaci√≥n de conectivas**.

De forma que:

    valuation : FormulaLP -> Interpretation -> Bool
    valuation pr i =
        case pr of
            Atom p -> List.member p i
            Neg p -> not (valuation p i)
            Conj p q -> valuation p i &&  valuation q i
            Disj p q ->   valuation p i ||  valuation q i
            Impl p q ->   not (valuation p i) ||  valuation q i
            Equi p q ->   valuation (Impl p q) i &&  valuation (Impl q p) i
            Insat -> Basics.False

NOTA: n√≥tese que la f√≥rmula insatisfactible es falsa respecto de cualquier valoraci√≥n.

Podemos usar esta funci√≥n para calcular la valoraci√≥n de una f√≥rmula respecto de una valoraci√≥n. Por ejemplo, calculemos la valoraci√≥n de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$ basta hacer:

```elm{l context="5"}
import Logicus.IO_LP exposing (..)
import Logicus.SintaxSemanticsLP exposing (..)

f : FormulaLP
f = fromStringToFLP "NOT (NOT (p OR q) OR (NOT r OR s))" |> extractReadFLP

i : Interpretation
i = ["p", "q"]
```

^^^elm{r=(valuation f i) context="5"}^^^

###### Tabla de Verdad, Modelos, Satisfactibilidad y Validez

Como se ha expuesto anteriormente, una tabla de verdad recoge las valoraciones de una f√≥rmula respecto a todas las posibles interpretaciones de sus s√≠mbolos proposicionales. En nuestro sistema, todas las posibles interpretaciones  que afectan a una f√≥rmula proposicional se corresponde con todos los posibles subconjuntos del conjunto formado por los s√≠mbolos proposicionales que participan en la f√≥rmula. De esta forma:

    symbInProp : FormulaLP -> Set.Set PSymb
    symbInProp f=
        case f of
            Atom p -> Set.singleton p
            Neg p -> symbInProp p
            Conj p q -> Set.union (symbInProp p ) (symbInProp q)
            Disj p q -> Set.union (symbInProp p ) (symbInProp q)
            Impl p q -> Set.union (symbInProp p ) (symbInProp q)
            Equi p q -> Set.union (symbInProp p ) (symbInProp q)
            Insat -> Set.empty
    
    allInterpretations : FormulaLP -> List Interpretation
    allInterpretations x =  Aux.powerset <| List.sort <| Set.toList <| symbInProp x

Y la tabla de verdad se corresponde con el conjunto de pares `(Interpretaci√≥n, Valoraci√≥n)`, aplicadas sobre todas las posibles interpretaciones:

    truthTable : FormulaLP -> List (Interpretation, Bool)
    truthTable x = List.map (\xs ->  (xs,valuation x xs)) <| allInterpretations x

Para el ejemplo anterior:

```elm{l context="6"}
import Logicus.IO_LP exposing (..)
import Logicus.SintaxSemanticsLP exposing (..)
import Logicus.AuxForLitvis exposing (showTable)
import Logicus.AuxiliarFunctions exposing (uncurry)
import Bool.Extra exposing (toString)

f : FormulaLP
f = fromStringToFLP "NOT (NOT (p OR q) OR (NOT r OR s))" |> extractReadFLP

-- Ejecutamos: truthTable f |> truthTableToMDFormat (symbInProp f) |> uncurry (showTable)
```

^^^elm{m=(truthTable f |> truthTableToMDFormat (symbInProp f) |> uncurry (showTable)) context="6"}^^^

Una vez calculadas todas las posibles interpretaciones resulta sencillo calcular los modelos y contramodelos de una f√≥rmula proposicional, sin m√°s que filtrar aquellos que sean evaluados como verdaderos o falsos, respectivamente. Es decir:

    models : FormulaLP -> List Interpretation
    models x = List.filter (\y -> valuation x y) (allInterpretations x)
    
    countermodels : FormulaLP -> List Interpretation
    countermodels x = List.filter (\y -> not(valuation x y)) (allInterpretations x)

As√≠ pues, para la f√≥rmula anterior, el conjunto de modelos y contramodelos corresponder√≠a a:

```elm{l context="6"}
modelos_f : List Interpretation
modelos_f =  models f
```

^^^elm{m=(interpretations2MDFormat modelos_f) context="6"}^^^

```elm{l context="6"}
contramodelos_f : List Interpretation
contramodelos_f = countermodels f
```

^^^elm{m=(interpretations2MDFormat contramodelos_f) context="6"}^^^

De forma an√°loga, resulta directo decidir la satisfactibilidad y validez de las f√≥rmulas proposicionales sin m√°s que comprobar si todas las interpretaciones hacen a la f√≥rmula verdadera (*tautolog√≠a*), si alguna de ellas la hace verdadera (*f√≥rmula satisfactible*), o si no la hace ninguna de ellas (*f√≥rmula insatisfactible*):


    satisfactibility : FormulaLP -> Bool
    satisfactibility x = List.any (\xs-> valuation x xs) (allInterpretations x)
    
    validity : FormulaLP -> Bool
    validity x = List.all (\xs-> valuation x xs) (allInterpretations x)
    
    insatisfactibility : FormulaLP -> Bool
    insatisfactibility x = List.all (\xs-> not(valuation x xs)) (allInterpretations x)

En el caso dela f√≥rmula anterior, sabemos que es satisfactible ya que su conjunto de modelos no es vac√≠o, y no es tautolog√≠a ya que el de contramodelos tampoco lo es. Utilizando las funciones provistas por la librer√≠a:

```elm{l context="6"}

isSatisfactible_f : Bool
isSatisfactible_f = satisfactibility f
```
^^^elm{m=(toString isSatisfactible_f) context="6"}^^^

```elm{l context="6"}

isTaut_f : Bool
isTaut_f = validity f
```
^^^elm{m=(toString isTaut_f) context="6"}^^^

```elm{l context="6"}

isInsatisfactible_f : Bool
isInsatisfactible_f = insatisfactibility f
```

^^^elm{m=(toString isInsatisfactible_f) context="6"}^^^

#### Conjuntos de F√≥rmulas. Modelos y Consistencia

Podemos extender las definiciones anteriores a conjuntos de f√≥rmulas:

>- **Modelo.** Se dice que una valoraci√≥n $v$ es **modelo** de un conjunto de f√≥rmulas $U$ si para toda f√≥rmula $F \in U$ se tiene que $v(F)=1$, y se denota por $v \models U$. En caso contrario, se dice **contramodelo**.
> -   **Consistencia** Un conjunto de f√≥rmulas $U$ se dice **consistente** si existe una valoraci√≥n $v$ que es modelo de $U$. En caso contrario, se dice que $U$ es **inconsistente**.


##### Consecuencia L√≥gica

>Una f√≥rmula $F$ es **consecuencia l√≥gica** (o se sigue l√≥gicamente) de un conjunto de f√≥rmulas $U$, y se denota por $U \models F$, si todo modelo de $U$ es tambi√©n modelo de $F$.

Es este concepto el que permitir√° formalizar el problema b√°sico inicial en el marco de la l√≥gica proposicional, que planteamos como objetivo de la LP.

##### Relaci√≥n entre consecuencia l√≥gica, consistencia y validez

> *PROPOSICI√ìN*: Sea $\{F_1, F_2, \ldots, F_n \} \subseteq PROP$ y $F \in PROP$ son equivalentes:
>
> - $\{F_1, F_2, \ldots, F_n \} \models F$
> - $(F_1 \wedge F_2 \wedge \ldots \wedge F_n) \rightarrow F \in TAUT$
> - $\{F_1 , F_2 , \ldots , F_n , \neg F\}$  es inconsistente.

##### Sem√°ntica de Conjuntos LP en LogicUS

Teniendo en cuenta que el lenguaje en el que se soporta LogicUS ademite el tipo de dato de conjunto, podemos extender tambi√©n en la implementaci√≥n el trabajo con conjuntos de f√≥rmulas:

    setSymbols : List FormulaLP -> Set.Set PSymb
    setSymbols xs = List.foldr (\x acc -> Set.union acc (symbInProp x)) Set.empty xs
    
    allSetInterpretations : List FormulaLP -> List Interpretation
    allSetInterpretations xs = Aux.powerset <| Set.toList <| setSymbols xs

De esta forma, el c√°lculo de modelos, contramodelos, consistencia e inconsistencia se reduce a aplicar las definiciones sobre el conjunto de f√≥rmulas:

    isSetModel : List FormulaLP -> Interpretation -> Bool
    isSetModel xs i =  List.all (\x -> valuation x i) xs
    
    allSetModels : List FormulaLP -> List Interpretation
    allSetModels xs = List.filter (isSetModel xs) (allSetInterpretations xs)
    
    allSetCounterModels : List FormulaLP -> List Interpretation
    allSetCounterModels xs = List.filter (\x -> not(isSetModel xs x)) <| allSetInterpretations xs
    
    isConsistent : List FormulaLP -> Bool
    isConsistent xs = List.any (\x -> isSetModel xs x) <| allSetInterpretations xs
    
    isInconsistent: List FormulaLP -> Bool
    isInconsistent xs = not(isConsistent xs)

###### Consecuencia l√≥gica

Dada la definici√≥n de conseciencia l√≥gica, y teniendo en cuenta la relaci√≥n entre consecuencia l√≥gica, consistencia y validez (√∫ltimo caso), LogicUS tiene varias v√≠as para desarrollar el concepto de Consecuencia L√≥gica. Por ejemplo, a partir de la definici√≥n formal, o haciendo uso del tercer punto de la proposici√≥n anterior. Hemos optado por esta √∫ltima v√≠a, que tiene m√°s aplicaciones directas a lo largo de desarrollos futuros.

    isConsecuence : List FormulaLP -> FormulaLP -> Bool
    -- isConsecuence xs x = List.all (\y -> valuation x y) <| allSetModels xs
    isConsecuence xs x = isInconsistent (xs ++ [Neg x])

Por ejemplo, dado el conjunto de f√≥rmulas $U=\{p \rightarrow q,q \rightarrow p \wedge r\}$ y la f√≥rmula $ F = p \rightarrow (p \rightarrow q) \rightarrow r$, ve√°mos si se cumple $U \models F$:

```elm{l context="7"}
import Logicus.IO_LP exposing (..)
import Logicus.SintaxSemanticsLP exposing (..)
import Bool.Extra exposing (toString)

u1 : FormulaLP
u1 = fromStringToFLP "p IMPLIES q" |> extractReadFLP

u2 : FormulaLP
u2 =  fromStringToFLP "q IMPLIES p AND r" |> extractReadFLP

uSet : LPSet
uSet = [u1, u2]

f : FormulaLP
f = fromStringToFLP "p IMPLIES (p IMPLIES q) IMPLIES r" |> extractReadFLP

-- Ejecutamos toString <| isConsecuence uSet  f
```

^^^elm{m=(toString <| isConsecuence uSet  f) context="7"}^^^

De hecho, acudiendo a la definici√≥n podemos ver que, en efecto, todo modelo del conjunto $U$ es tambi√©n modelo de la f√≥rmula $F$.

```elm{l context="7"}
modelos_U : List Interpretation
modelos_U = allSetModels uSet

modelos_F : List Interpretation
modelos_F = models f

{-Ejecutamos:
    interpretations2MDFormat modelos_U
    interpretations2MDFormat modelos_F
  -}
```
Los modelos de $U$ son:

^^^elm{m=(interpretations2MDFormat modelos_U) context="7"}^^^

Y los modelos de $F$ son:

^^^elm{m=(interpretations2MDFormat modelos_F) context="7"}^^^

Donde podemos comprobar que, en efecto, todo modelo de $U$ es tambi√©n modelo de $F$, luego $U\models F$.

### Algoritmos de decisi√≥n en LP

Como hemos se√±alado, a continuaci√≥n vamos a presentar de forma muy superficial algo sobre algoritmos de decisi√≥n en LP, e iremos desarrollando algunos de los algoritmos m√°s importantes a lo largo de los distintos cap√≠tulos que componen este curso.

> Dado un conjunto de f√≥rmulas $U$, un **algoritmo de decisi√≥n** para $U$ es aquel que, dada una f√≥rmula $A \in PROP$, devuelve `SI` cuando $A \in U$ y `NO` cuando $A \not\in U$.

Esto da pie a la definici√≥n de algunos problemas especialmente interesantes:

> - $SAT = \{A \in PROP: \, A \textit{ es satisfactible}\}$.
> - $TAUT = \{A \in PROP: \, A \textit{ es tautolog√≠a}\}$.
> - Fijado $U \subseteq PROP$, la *Teor√≠a de $U$* corresponde a: $\mathcal{T}(U) = \{A \in PROP: \, U \models A\}$.

Precisamente, un algoritmo de decisi√≥n para $\mathcal{T}(U)$ proporciona una respuesta al Problema B√°sico que planteamos al comienzo del cap√≠tulo. Por tanto, podemos reducir dicho problema a uno nuevo:
> Obtener un algoritmo que, dado un conjunto finito de f√≥rmulas proposicionales, $U$, y una f√≥rmula, $F$, decida si $U \models F$.

Y este, a su vez, se reduce a comprobar la satisfactibilidad de una cierta f√≥rmula (o bien la validez de otra), que  se corresponde con el problema conocido como *Problema $SAT$*.

De hecho, ya hemos visto un algoritmo, por medio de las Tablas de Verdad, que resuelve, de forma simple, el problema, pero la complejidad de dicho algoritmo es exponencial en el n√∫mero de s√≠mbolos proposicionales, lo que lo hace inabordable para f√≥rmulas de cierta complejidad (una f√≥rmula que use 1000 variables proposicionales, relativamente peque√±a en problemas que aparecen en el mundo real, requerir√≠a de la construcci√≥n de una tabla con $2^{1000}$ filas, completamente inabordable por medios directos.

A lo largo de los siguientes cap√≠tulos analizaremos otros algoritmos de decisi√≥n para el problema $SAT$, algunos de los cuales parecer√°n m√°s eficientes que otros, pero hemos de recordar que no se ha encontrado ninguno capaz de resolver el problema eficientemente (complejidad polinomial), y, de hecho, se duda (fuertemente) de la existencia de un tal algoritmo, porque como dijimos el problema $SAT$ es **NP**-completo, y se piensa que las clases **P** (*grosso modo*, los problemas que se pueden resolver en tiempo polinomial) y **NP** son distintas.

## Conceptos B√°sicos de L√≥gica de Primer Orden

### Limitaciones de la L√≥gica Proposicional

Aunque la l√≥gica proposicional posee un sem√°ntica sencilla y existen algoritmos de decisi√≥n (poco eficientes) para sus problemas b√°sicos, como $SAT$ o la consecuencia l√≥gica, la expresividad de LP es bastante limitada, esto hace que muchos problemas no sean modelables en LP, bien porque requieren un gran n√∫mero de f√≥rmulas o f√≥rmulas de gran tama√±o, o
bien porque no puedan ni siquiera expresarse en este lenguaje. El siguiente ejemplo presenta un razonamiento que es v√°lido, sin embargo no es expresable en LP:

1. Todo hombre es mortal.
2. S√≥crates es hombre.
3. Por tanto, S√≥crates es mortal.

¬øC√≥mo expresar el concepto de ser hombre?¬øComo expresar qui√©n es S√≥crates?, pero a√∫n m√°s ¬øC√≥mo expresar que todos es mortal?. Es aqu√≠ precisamente donde comienza el √°mbito de la L√≥gica de PrimerOrden.

### Caracterizaci√≥n de la L√≥gica de Primer Orden

La L√≥gica de Primer Orden (LPO) extiende la L√≥gica Proposicional, ganando capacidad expresiva, que permite abordar cuestiones como:

- Realizar cuantificaci√≥n sobre los objetos de un dominio, esto es, expresar en qu√© medida se tiene una propiedad sobre un conjunto de objetos.

- Representar propiedades de los objetos particulares del dominio por medio de predicados y funciones.

- Trabajar con subconjuntos de objetos que pueden venir caracterizados por propiedades que se describen por medio de predicados y funciones.

### Fundamentos de la L√≥gica de Primer Orden

De forma an√°loga a como se ha visto para la l√≥gica proposicional vamos a estudiar los elementos que definen la L√≥gica de Primer Orden (Sint√°xis y Sem√°ntica) dejando para cap√≠tulos futuros el desarrollo de los Algoritmos de Decisi√≥n.

### Sint√°xis de la L√≥gica de Primer Orden

Formalmente,

> La **L√≥gica de Primer Orden** o **L√≥gica de Predicados** es un sistema formal dise√±ado para estudiar los m√©todos inferenciales en los leguajes de primer orden.

Un **lenguaje de primer orden** corresponde a un lenguaje formal que consta de:

- <u>S√≠mbolos l√≥gicos</u> (comunes a todos los lenguajes): En los que se engloban:

    -   Un conjunto de *Variables:* $V = \{x, x_0, x_1, \ldots, y, y_0, \ldots \}$

    -   *Conectivas l√≥gicas :* $\neg$ (negaci√≥n), $\wedge$ (conjunci√≥n), $\vee$ (disyunci√≥n), $\rightarrow$ (implicaci√≥n), $\leftrightarrow$ (equivalencia).

    -   *Cuantificadores:* $\exists$ (existencial), $\forall$ (universal).

    -   *S√≠mbolos auxiliares:* $`('$ y $`)'$

-   <u>S√≠mbolos no l√≥gicos</u> (propios de cada lenguaje): En los que se engloban:

    -   Un conjunto de *Constantes:* $L_{C}= \{a, b, \ldots, a_{0}, a_{1}, \ldots \}$

    -   Un conjunto de *s√≠mbolos de funci√≥n:* $L_{F} = \{f_{0}, f_{1}, \ldots\}$, cada uno con su aridad correspondiente.

    -   Un conjunto de **s√≠mbolos de predicado:** $L_P=\{P_{0}, P_{1}, \ldots, Q, Q_0, \ldots\}$, cada uno con su aridad correspondiente.

        Dos notas:

        -   Los s√≠mpolos de predicado de aridad 0 act√∫an como s√≠mbolos proposicionales.

        -   El s√≠mbolo de igualdad (‚Äò$=$‚Äô) no es un predicado com√∫n a todos los lenguajes de primer orden, pero si es corriente su aparici√≥n. La familia de lenguajes que incluyen este predicado es denominada *Lenguajes de Primer Orden con Igualdad*.

Este aparato permite la construcci√≥n de distintas expresiones, que componen las f√≥rmulas de LPO. Vamos a exponer una diferenciaci√≥n de dichas expresiones, distinguiendo *t√©rminos* y *f√≥rmulas*.

#### T√©rminos en LPO

Los t√©rminos se identifican con posibles objetos del mundo. Englobando los siguientes elementos:

- <u>Constantes</u> para hablar de objetos espec√≠ficos.
- <u>Variables</u> para hablar de objetos gen√©ricos.
- <u>Funciones</u> aplicadas a otros t√©rminos m√°s peque√±os, seg√∫n su aridad.

Para ejemplificar los conceptos expuestos a lo largo del tema vamos a modelar el mundo romano:
(los super√≠ndices indican la aridad)

$$LR = \{\underbrace{\boldsymbol{C√©sar}, \boldsymbol{Marco}}_{constantes}, \underbrace{P^{1}, L^{2}, O^{2}, R^{1}, IA^{2}}_{\textit{s√≠mbolos de predicado}}, \underbrace{f^{1}}_{\textit{s√≠mbolo de funci√≥n}} \}$$

tal que, donde, $C√©sar$ y $Marco$ son constantes, $P$ y $R$ son predicados unarios que denotan *ser pompeyano* y *ser romano*, respectivamente; $L$, $O$, $IA$ son predicados binarios que denotan *ser leal a*, *odiar a* , *intentar asesinar a*, respectivamente; y $f$ una funci√≥n unaria que represente el concepto de *padre de*.

De forma que son t√©rminos de $LR$:

- *Constantes*: *Marco*, *C√©sar*.
- *Variables*: $x$, $y$, $x_1$, ...
- *Funciones*: f(C√©sar), f(x), f(f(x)), ...

#### F√≥rmulas en LPO

Las f√≥rmulas se identifican con afirmaciones sobre los objetos del mundo, permitiendo hablar de la veracidad o falsedad de las afirmaciones. Est√°n formadas a partir de predicados sobre t√©rminos, y construcciones l√≥gicas de estos predicados (conjunciones, implicaciones, cuantificaciones, etc.). Ve√°mos esto formalmente.

Las f√≥rmulas pueden corresponder a:

- <u>√Åtomos o F√≥rmulas at√≥micas</u>. Corresponden a las expresiones $p(t_1, t_2, \ldots, t_n)$, tal que $p$ es un s√≠mbolo de predicado de aridad $n$ y $t_i$ son t√©rminos.

- <u>F√≥rmulas no at√≥micas</u>. Corresponden a expresiones formadas a partir de f√≥rmulas at√≥micas, mediante el empleo de conectivas y/o cuantificadores.

De esta forma, son f√≥rmulas de $L$:

- Toda f√≥rmula at√≥mica.

- Si F y G son f√≥rmulas de de $L$ entonces $\neg F$, $F \wedge G$, $F \vee G$, $F \rightarrow G$, $F \leftrightarrow G$, tambi√©n son f√≥rmulas de $L$.

- Si x es una variable y F es una f√≥rmula de $L$, entonces $\exists x \, F$ y $\forall x \, F$ son tambi√©n f√≥rmulas de $L$.

Volviendo al mundo romano, algunas posibles f√≥rmulas del lenguaje $LR$:

- *√Åtomos*: $P(\boldsymbol{C√©sar})$, $L(\boldsymbol{C√©sar}, \boldsymbol{Marco})$, $IA(\boldsymbol{Marco}, f(x))$.
- *F√≥rmulas compuestas*: $\forall x \exists y \, L(x,y)$, $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$

$\longrightarrow$ <u>Reglas de simplificaci√≥n de la notaci√≥n</u>

Para facilitar la lectura y escritura de las f√≥rmulas vamos a tomar varios criterios de notaci√≥n:

- Se omitir√°n los par√©ntesis externos.
- Las prioridades de las conectivas siguen el mismo orden que el expuesto en LP: $\neg, \wedge, \vee, \rightarrow, \leftrightarrow$ (para la √∫ltima se recomienda mantener los par√©ntesis).
- Los cuantificadores tienen prioridad sobre las conectivas.

##### √Årboles de formaci√≥n.

Al iguan que en las f√≥rmulas de LP, la definici√≥n de las f√≥rmulas en LPO presenta una estructura recursiva:

- *Caso base*. F√≥rmulas at√≥micas.
- *Casos recursivos* Aplicaci√≥n de las conectivas y cuantificadores sobre f√≥rmulas de LPO.

Y de forma an√°loga a la presentada en LP, se puede plasmar dicha estructura recursiva en un grafo tipo √°rbol (esencialmente √∫nico), de forma que el nodo ra√≠z corresponde a la f√≥rmula completa y las hojas corresponden a las f√≥rmulas at√≥micas que participan en la f√≥rmula. Al igual que en LP, toda f√≥rmula que aparezca en alg√∫n nodo (ya sea un nodo interno o una hoja) diremos que es **subf√≥rmula** de la f√≥rmula original.

Para la f√≥rmula $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$, se tendr√≠a el AF asociado:

<center> <img src="images/T1Img4.png" title="√Årbol de formaci√≥n en LPO (ejemplo)."></center><br>


##### Sintaxis de F√≥rmulas LPO en Logicus

Al igual que hicimos con la l√≥gica LP, vamos a exponer cu√°l es la sintaxis de las f√≥rmulas utilizando la librer√≠a Logicus, que nos permitir√° definir f√≥rmulas y aplicar diversos algoritmos sobre las mismas.

Bajo la librer√≠a podemos definir las f√≥rmulas de dos formas distintas, o bien acudiendo directamente a los constructores de las f√≥rmulas (largo y engorroso), o bien utilizando el Parser (de forma an√°loga a la escritura natural de las f√≥rmulas).

$\longrightarrow$ <u>Definici√≥n de f√≥rmulas a partir de constructores (M√≥dulo *SintaxSemanticsLPO*)</u>

Antes de introducirnos en el estudio de la sintaxis de f√≥rmulas vamos a presentar la sintaxis y definici√≥n de t√©rminos. Recordemos que la estuctura de los t√©rminos corresponde a una definici√≥n recursiva con <u>variables</u> y <u>constantes</u> como *casos base* y <u>funciones</u>.

Aunque la definici√≥n en la librer√≠a sigue esta idea, se ha decidido modelar las <u>constantes</u> como funciones independientes de variables, de forma que en la librer√≠a se tiene que un t√©rmino es o bien una variable o bien una funci√≥n.

    type Term = Var String
              | Func String (List Term)

De forma que las constantes corresponder√≠an a objetos con la estructura *Func String [ ]*.

De forma que podemos definir t√©rminos de forma sencilla mediante el uso de estos constructores. Volviendo al ejemplo presentado anteriormente, (*Constantes*: *Marco*, *C√©sar*; *Variables*: $x$, $y$, $x_1$, ...; *Funciones*: f(C√©sar), f(x), f(f(x))):

```elm{l context="8"}

import Logicus.SintaxSemanticsLPO exposing (..)

cesar = Func "cesar" []

marco = Func "marco" []

x = Var "x"

x_1 = Var "x_1"

f_cesar = Func "f" [cesar]

f_f_cesar = Func "f" [Func "f" [cesar]]
```

Ahora que ya podemos definir t√©rminos en LPO podemos pasar a ver la definici√≥n de f√≥rmulas. Si recordamos, las f√≥rmulas est√°n definidas con una estructura recursiva, de forma que las f√≥rmulas corresponden o bien a √°tomos (*caso base*), o bien a la aplicaci√≥n de las conectivas y/o cuantificadores sobre otras f√≥rmulas (*caso recursivo*).

Bien, pues la implementaci√≥n dada en la librer√≠a para las f√≥rmulas sigue fielmente dicha definici√≥n. De forma que: (definiendo el tipo *Variable* como alias de *Term*)

    type alias Variable = Term
    
    type FormulaLPO = Pred String (List Term)
                    | Equal Term Term
                    | Neg FormulaLPO
                    | Conj FormulaLPO FormulaLPO
                    | Disj FormulaLPO FormulaLPO
                    | Impl FormulaLPO FormulaLPO
                    | Equi FormulaLPO FormulaLPO
                    | Exists Variable FormulaLPO
                    | Forall Variable FormulaLPO
                    | Insat

De forma que esto nos permite expresar sint√°cticamente todas las f√≥rmulas en LPO. Para los ejemplos expuestos:

```elm{l context="9"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)


f1 : FormulaLPO
f1 = Pred "P" [Func "cesar" []]

```

^^^elm{m=(toLatexFLPO f1) context="9"}^^^

```elm{l context="9"}

f2 : FormulaLPO
f2 = Pred "L" [Func "cesar" [], Func "marco" []]

```

^^^elm{m=(toLatexFLPO f2) context="9"}^^^


```elm{l context="9"}

f3 : FormulaLPO
f3 = Pred "IA" [Func "cesar" [], Func "f"  [Var "x"]]

```

^^^elm{m=(toLatexFLPO f3) context="9"}^^^

```elm{l context="9"}

f4 : FormulaLPO
f4 = Forall (Var "x") (Exists (Var "y") (Pred "L" [Var "x", Var "y"]))

```

^^^elm{m=(toLatexFLPO f4) context="9"}^^^

```elm{l context="9"}

f5 : FormulaLPO
f5 = Forall (Var "x") (Impl (Pred "R" [Var "x"]) (Disj (Pred "L" [Var "x",Func "cesar" []]) (Pred "O" [Var "x",Func "cesar" []])))

```

^^^elm{m=(toLatexFLPO f5) context="9"}^^^

$\longrightarrow$ <u>Definici√≥n de f√≥rmulas LPO con Parser (M√≥dulo *IO_LPO*)</u>

Aunque ya podemos definir todas las f√≥rmulas en LPO, su escritura resulta una tarea muy pesada, para aliviar esa carga se ha desarrollado un Parser que permite la lectura de f√≥rmulas a partir de una cadena de texto en el que las f√≥rmulas se escriben de forma an√°loga a como se dan en el lenguaje formal de la l√≥gica. Se establecen algunas reglas sint√°cticas en su uso:

- Las <u>variables</u> se escriben con una letra en min√∫scula seguidas de caracteres alphanum√©ricos o el s√≠mbolo '_'. Algunos ejemplos: *'x'* , *'x_1'*, *'x1'*, ...

- Las *funciones* se definen siguiendo la notaci√≥n prefija, seg√∫n el patr√≥n:

    <center><i> [S√≠mbolo de funci√≥n] [par√°metros]</i></center>

    Tal que: 

    - El *s√≠mbolo de funci√≥n* debe comenzar por el car√°cter '_', seguido de una serie de caracteres, entre estos se admiten caracteres alfanum√©ricos y tambi√©n s√≠mbolos, excepto '[', ']', '(', ')', '{', '}', ',', ';'.

    - En los *par√°metros* se pueden dar 2 casos, o bien la funci√≥n corresponde a una <u>constante</u> y por tanto no tiene par√°metros, con lo cual bastar√≠a escribir el s√≠mbolo de funci√≥n (ejemplos: *'_a'*, *'_PEDRO'*, *'_1'*) o bien es una <u>funci√≥n</u> (dependiente de, al menos, un t√©rmino), en tal caso los argumentos se dan en una lista acotada por corchetes ('[', ']') y tras cada argumento ha de ir un ';' (ejemplos: *'_f[x;]'*, *'_g[x;y;]'*, *'_+[x;\_1;\_¬∑[y;\_2;]]'*).

- Los <u>predicados</u> se definen utilizando la notaci√≥n prefija seg√∫n el patr√≥n:

    <center><i> [s√≠mbolo de predicado] [par√°metros]</i></center>

    Tal que:

    - El *s√≠mbolo de predicado* debe comenzar por un car√°cter en may√∫scula o un s√≠mbolo (exceptuando '_',  '!', '(', ')', '[', ']', '}', '}' (tambi√©n se admiten d√≠gitos num√©ricos pero no se recomienda), seguido de una serie de caracteres, entre estos se admiten caracteres alfanum√©ricos y tambi√©n s√≠mbolos (exceptuando '(', ')', '[', ']', '}', '}'). Son palabras reservadas (y por tanto no se pueden usar como predicados) *"NOT", "AND", "OR", "IMPLIES", "EQUIV", "EXISTS", "FORALL", "INSAT"*.

    - En los *par√°metros* se pueden dar 2 casos, o bien la funci√≥n es un <u>predicado proposicional</u> (no tiene par√°metros), con lo cual bastar√≠a escribir el s√≠mbolo de predicado (ejemplos: *'P'*, *'Q\_1'*) o bien es un <u>predicado n-ario</u> (dependiente de, al menos, un par√°metro), en tal caso los argumentos se dan en una lista acotada por corchetes ('[', ']') y tras cada argumento ha de ir un ';' (ejemplos:'P[x;]', '>=[x;y;]', 'MAX[x;\_1;\_¬∑[y;\_2;]]').

    Hay una excepci√≥n, *predicado de igualdad* (binaria) se utilizar√° de forma infija separando los t√©rminos con el s√≠mbolo '=' (ejemplos: 'x=y' , 'x\_4=\_3', '\_f[x;]=\_f[y;]') (El predicado de igualdad es de uso exclusivamente binario).

    <center><i> [t√©rmino] = [t√©rmino]</i></center><br><br>

- Los <u>cuantificadores</u> se expresan de forma an√°loga al lenguaje formal de LPO seg√∫n el patr√≥n:

    <center><i> [s√≠mbolo de cuantificador] [variable] [f√≥rmula]</i></center><br><br>

    Tal que: 

    - Los *s√≠mbolos de cuantificadores* corresponden a:

      |      Cuantificador      | S√≠mbolo LogicUS |
  | :---------------------: | :-------------: |
    | $\exists$ (Existencial) |     EXISTS      |
  |  $\forall$ (Universal)  |     FORALL      |
    
    - La *variable* debe ir entre llaves ('{', '}'), respetando las reglas establecidas para la definici√≥n de variables.
    
    - La *f√≥rmula* escrita respetando los criterios dados para la escritura de las f√≥rmulas.


 - Las conectivas se usar√°n de forma infija (salvo para la *negaci√≥n*),  utilizando los siguientes s√≠mbolos, manti√©ndose la prioridad de las conectivas definida (en el orden de prioridad descendente expuesto en la tabla).

   |           Conectiva L√≥gica           | S√≠mbolo LogicUS |
   | :----------------------------------: | :-------------: |
   |             ¬¨ (Negaci√≥n)             |       NOT       |
   |            ‚àß (Conjunci√≥n)            |       AND       |
   |            ‚à® (Disyunci√≥n)            |       OR        |
   |           ü°í (Implicaci√≥n)            |     IMPLIES     |
   | ü°ò (Doble Implicaci√≥n o Equivalencia) |      EQUIV      |

- Los par√©ntesis se utilizan de igual forma en que se han definido en el lenguaje formal de la l√≥gica proposicional, con los s√≠mbolos '(' y ')'. No son necesarios los par√©ntesis externos de las f√≥rmulas.

- En caso de uso repetido de una misma conectiva y/o cuantificador, se realizar√° asociaci√≥n por la derecha.

Al igual que ocurr√≠a en el Parser de LP una vez le√≠da la f√≥rmula con la funci√≥n *fromStringToFLPO* es necesario extraerla utilizando la funci√≥n *extractReadFLPO*.

Vamos a mostrar algunos ejemplos de definici√≥n de las f√≥rmulas utilizando el Parser de LPO.

- Ejemplo 1: $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$

```elm{l context="10"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)

f1 : FormulaLPO
f1 = fromStringToFLPO "FORALL{x}(R[x;] IMPLIES (L[x;_cesar;] OR O[x; _cesar;]))" |> extractReadFLPO

-- Ejecutamos (toLatexFLPO f1) para mostrar la f√≥rmula
```

Que corresponde a:

^^^elm{m=(toLatexFLPO f1) context="10"}^^^

- Ejemplo 2 (tomando el lenguaje matem√°tico), definamos la propiedad biyectiva. Para expresarla consideremos el siguiente lenguaje: $L= \{O, I, f\}$, tal que:

    - $O$ es un predicado de aridad 1 que expresa si el objeto pertenece al conjunto origen.

    - $I$ es un predicado de aridad 1 que expresa si el objeto pertenece al conjunto imagen.

    - $f$ es una funci√≥n que dado un elemento del conjunto origen obtiene el correspondiente elemento del conjunto imagen y dado un elemento del conjunto imagen obtiene el correspondiente del conjunto origen.

    La propiedad biyectiva se formula como:

    <center><i> Una relaci√≥n es biyectiva si para todo elemento del conjunto origen existe un √∫nico elemento del conjunto imagen con el que est√° relacionado y todo elemento del conjunto imagen est√° relacionado con alg√∫n elemento del origen</i></center><br>

    Esto es: $$ \forall x,y \in O \, (x \neq y \rightarrow f(x) \neq f(y)) \wedge \forall x \in I \, \exists y \in O \, (f(x)=y)$$<br>

    ```elm{l context="10"}

    biyectiva : FormulaLPO
    biyectiva = fromStringToFLPO
                    "FORALL{x} FORALL{y} (O[x;] AND O[y;] AND NOT (x=y) IMPLIES NOT (_f[x;]=_f[y;])) AND FORALL{x}(I[x;] IMPLIES EXISTS{y}(O[y;] AND _f[y;]=x))"
                |> extractReadFLPO

    -- Ejecutamos (toLatexFLPO biyectiva) para mostrar la f√≥rmula
    ```

    ^^^elm{m=(toLatexFLPO biyectiva) context="10"}^^^

    $\longrightarrow$ <u>√Årboles de formaci√≥n LPO en Logicus</u>

    La librer√≠a tambi√©n permite la representaci√≥n de los √°rboles de formaci√≥n LPO. La funci√≥n *formtree* (del m√≥dulo *IO_LPO*) muestra la representaci√≥n del √°rbol de formaci√≥n en formato texto DOT, de forma an√°loga a como lo hac√≠a en el caso de LP

    Por ejemplo para la f√≥rmula $\forall x (R(x) \rightarrow \left( L(x, \boldsymbol{C√©sar}) \vee O(x, \boldsymbol{C√©sar}) \right)$:

    ```elm {l context="11"}
    import Logicus.IO_LPO exposing (..)
    import Logicus.SintaxSemanticsLPO exposing (..)
    import Logicus.AuxForLitvis exposing (showGraphViz)

    f : FormulaLPO
    f = fromStringToFLPO "FORALL{x}(R[x;] IMPLIES (L[x;_cesar;] OR O[x; _cesar;]))" |> extractReadFLPO

    ft_f : String
    ft_f = formTree f
    ```
    De forma que se obtiene:

    ^^^elm {m=(showGraphViz "G2" ft_f) context="11"}^^^

##### Alcance de los cuantificadores, FBF, clausura de f√≥rmulas y renombramiento de variables

Hemos estudiado la sint√°xis formal de las f√≥rmulas, pero a√∫n faltan algunos detalles por completar para establecer qu√© f√≥rmulas est√°n bien formadas y cu√°les no. Un tema importante es el tratamiento de la cuantificaci√≥n, esto es, a qu√© aparciones u ocurrencias (denominadas estancias) de una variable afecta un cuantificador.

> Una ocurrencia de una variable est√° afectada por un cuantificador (se dice que es una **estancia u ocurrencia ligada**) si hay un cuantificador sobre dicha variable actu√°ndo sobre la (sub)f√≥rmula que la contiene. En otro caso diremos que se trata de una **estancia u ocurrencia libre**

Para comprenderlo mejor vamos a explicar un ejemplo:

$$ \underbrace{\forall x}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {1}}}} \, \boxed{( P(\underbrace{x}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{x ligada}\end{array}}, \underbrace{y}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{y libre}\end{array}}) \rightarrow  \underbrace{\exists y}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {2}}}} \, \boxed{R(\underbrace{y}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{y ligada}\end{array}}, \underbrace{x}_{\begin{array}{c} \textit{ocurr. de}\\ \textit{x ligada}\end{array}})}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {2}}}} )}_{\raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {1}}}}$$

En la f√≥rmula podemos apreciar que el cuantificador, $\forall x$, afecta a toda la f√≥rmula siguiente, por tanto todas las ocurrencias de $x$ que aparezcan en la f√≥rmula ser√°n ocurrencias ligadas. Sin embargo, $P(x,y)$ no est√° afectado por ning√∫n otro cuantificador, por tanto, la ocurrencia de $y$ en $P(x,y)$ es libre. Por otra parte, $R(x,y)$ s√≠ est√° afectado por el cuantificador $\exists y$,  por tanto tanto la ocurrencia de $x$ como la de $y$ en $R(y, x)$ son ligadas.

De forma similar se definen las variables *libres* y *ligadas* como:

> Una variable $x$ se dice **varible libre** en una f√≥rmula $F$ si existe alguna ocurrencia libre de $x$ en $F$. <br>
Una variable $x$ se dice **varible ligada** en una f√≥rmula $F$ si existe alguna ocurrencia ligada de $x$ en $F$.

De forma que en una f√≥rmula una variable puede ser al mismo tiempo *variable libre* y *variable ligada*.

Por ejemplo, en la f√≥rmula anterior $x$ es una variable *exclusivamente cerrada* (todas sus ocurrencias son ligadas), sin embargo $y$ es una variable *libre* y *ligada* (hay una ocurrencia libre y otra ligada).

En base a los conceptos anteriores se definen los conceptos:

> Se dice que un **t√©rmino** es **cerrado** si no contiene ninguna variable.

Por ejemplo: $C√©sar$, $f(Marco)$, $f(f(C√©sar))$; son t√©rminos cerrados en el lenguaje $LR$.

> Se dice que una **f√≥rmula** es **cerrada** si no contiene variables libres, o equivalentemente si todas las estancias de todas las variables son ligadas.

Por ejemplo las f√≥rmulas $\forall x (L(x, C√©sar) \vee O(C√©sar, x))$, $\forall x L(x, C√©sar) \rightarrow \neg \exists y O(C√©sar, y)$ son una *f√≥rmulas cerradas*, mientras que las f√≥rmulas $\forall x L(x, C√©sar) \vee O(C√©sar, x)$ , $\forall x L(x, C√©sar) \rightarrow \neg \exists y IA(y, x)$ no lo son.

> Se dice que una **f√≥rmula** es **abierta** si no contiene cuantificadores, esto es todas las variables son, exclusivamente, *variables libres*.

Por ejemplo son f√≥rmulas abiertas $P(x)$, $R(C√©sar)$, $P(x) \leftrightarrow \neg IA(f(x), Marco)$.

Incidiremos m√°s en este aspecto cuando ve√°mos la sem√°ntica en LPO.

$\longrightarrow$ <u>F√≥rmulas bien formadas y renombramiento de variables</u>

Aunque las f√≥rmulas est√©n bien escritas sint√°cticamente, incluso aunque sean cerradas, es posible que su interpretaci√≥n sea ambigua, esta ambig√ºedad suele venir dada por un mal uso de los cuantificadores y las variables, por ejemplo tengamos la f√≥rmula:

$$\forall z\,\forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, \boxed{z}\right) \wedge P\left(x, y\right) \right) \right) \right)$$

La ocurrencia de $z$ se√±alada, es claramente ligada, pero ¬øa qu√© cuantificador?

> Diremos que una **f√≥rmula** est√° **bien formada** (*FBF* o *WFF*) si es correcta sint√°cticamente y no contiene dos cuantificadores anidados actuando sobre la misma variable.

Claramente, la **f√≥rmula** presentada no est√° **bien formada** y hay una ambig√ºedad en la interpretaci√≥n de la f√≥rmula, para resolver dicha ambig√ºedad vamos a adoptar el siguiente criterio:

"Una ocurencia est√° ligada (si es que lo est√°) al cuantificador de nivel superior m√°s cercano en el √°rbol de formaci√≥n"

De forma que la ocurrencia anterior la tomaremos ligada al existencial. N√≥tese que en el √°rbol de formaci√≥n es el cuantificador referido a $z$ de orden superior m√°s cercano:

<center> <img src="images/T1Img6.png" title="√Årbol formaci√≥n (ejemplo)"></center><br>

Adem√°s de adoptar un criterio, podemos, mejor, realizar un renombramiento de las variables, manteniendo el sentido original de las f√≥rmulas, de forma que la f√≥rmula anterior podr√≠amos renombrarla mejor como:
$$\forall z_1\,\forall x_1\,\exists y_1\,\left( P\left(x_1, y_1\right)\rightarrow \left( P\left(x_1, z_1\right) \vee \exists z_2\,\left( P\left(y_1, z_2\right) \wedge P\left(x_1, y_1\right) \right) \right) \right)$$

No es el √∫nico caso en el que es necesario renombrar las variables, por ejemplo, tengamos la f√≥rmula:

$$\forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, \raisebox{.5pt}{\textcircled{\raisebox{-.5pt} {$z$}}}\right) \vee \exists z\,\left( P\left(y, \boxed{z}\right) \wedge P\left(x, y\right) \right) \right) \right)$$

La primera ocurrencia de $z$ se√±alada es libre y la segunda es ligada, claramente el mismo s√≠mbolo de variable representa objetos distintos, lo que produce una cierta ambig√ºedad en la f√≥rmula. Sin embargo, podemos renombrar la f√≥rmula como:
$$\forall x_1\,\exists y_1\,\left( P\left(x_1, y_1\right)\rightarrow \left( P\left(x_1, z\right) \vee \exists z_1\,\left( P\left(y_1, z_1\right) \wedge P\left(x_1, y_1\right) \right) \right) \right)$$

De forma que desaparece toda posible ambig√ºedad.

N√≥tese que para renombrar se ha escogido el siguiente criterio : *Se renombrar√°n todas las ocurrencias ligadas de cada variable a√±adiendo el sub√≠ndice correspondiente seg√∫n el orden y cardinalidad de aparici√≥n del cuantificador (sobre dicha variable) al que est√° ligada dicha ocurrencia (tomando el orden seg√∫n el recorrido en profundidad del $AF$ de la f√≥rmula)*

$\longrightarrow$ <u>Clausura de las f√≥rmulas LPO.</u>

Los algoritmos de decisi√≥n que vamos a estudiar trabajan √∫nicamente sobre f√≥rmulas cerradas, por lo que hemos de *clausurar* todas aquellas f√≥rmulas que no sean cerradas, cuantificando las variables libres de la f√≥rmula (aplicando un renombramiento sobre aquellas variables que sean, simult√°neamente, libres y ligadas).

Se admiten dos tipos de clausura para las f√≥rmulas:

- <u>Clausura universal</u> se trata de cerrar la f√≥rmula a base de cuantificar universalmente (por la izquierda) las variables libres de las f√≥rmulas. Si $v_1, \ldots, v_n$ corresponden a las variables libres de una f√≥rmula $F$, la clausura universal de la f√≥rmula corresponde a la f√≥rmula $\forall v_1 \ldots \forall v_n \, F$

- <u>Clausura existencial</u> se trata de cerrar la f√≥rmula a base de cuantificar existencialmente (por la izquierda) las variables libres de las f√≥rmulas. Si $v_1, \ldots, v_n$ corresponden a las variables libres de una f√≥rmula $F$, la clausura universal de la f√≥rmula corresponde a la f√≥rmula $\exists v_1 \ldots \exists v_n \, F$

Veremos algunas cuestiones m√°s sobre este aspecto cuando veamos la *Sem√°ntica en LPO*.

$\longrightarrow$ <u>F√≥rmulas abiertas/cerradas, FBF, renombramiento y clausura de f√≥rmulas en Logicus</u>

La librer√≠a Logicus permite, en el m√≥dulo *SintaxSemanticsLPO* trabajar con los conceptos que hemos estado viendo.

$-$ *Variables libres y ligadas*

Recordemos que una variable es libre/ligada si existe alguna ocurrencia de dicha variable que sea libre/ligada. En la librer√≠a Logicus las funciones *varIsFreeInFLPO* y *varIsLinkedInFLPO* resuelven este aspecto:

    varIsFreeInFLPO : Variable -> FormulaLPO -> Bool
    varIsFreeInFLPO v f=
        case f of
            Pred _ terms -> List.member v (varsInListTerm terms)
            Equal t1 t2 -> List.member v (varsInListTerm [t1, t2])
            Neg p -> varIsFreeInFLPO v p
            Conj p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Disj p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Impl p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Equi p q -> varIsFreeInFLPO v p || varIsFreeInFLPO v q
            Exists var p -> not(var == v) && varIsFreeInFLPO v p
            Forall var p -> not(var == v) && varIsFreeInFLPO v p
            Insat -> True
    
    varIsLinkedInFLPO : Variable -> FormulaLPO -> Bool
    varIsLinkedInFLPO v f=
        case f of
            Pred _ _ -> False
            Equal _ _ -> False
            Neg p -> varIsLinkedInFLPO v p
            Conj p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Disj p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Impl p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Equi p q -> varIsLinkedInFLPO v p || varIsLinkedInFLPO v q
            Exists var p -> (var == v && List.member v (varsInFormula p)) || varIsLinkedInFLPO v p
            Forall var p -> (var == v && List.member v (varsInFormula p)) || varIsLinkedInFLPO v p
            Insat -> False

De forma que podemos preguntar, por ejemplo si las variables $x$, $y$, $z$ son libres y/o ligadas en $$F: \exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la f√≥rmula

```elm {l context="12"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f = fromStringToFLPO "EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{z} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO
```
2. Preguntamos si cada una de las variables son libres/ligadas:

```elm {l context="12"}
isxF = varIsFreeInFLPO (Var "x") f
isxL = varIsLinkedInFLPO (Var "x") f
```
^^^elm {m=("Es $x$ libre? " ++ (toString isxF) ++ "Es $x$ ligada? " ++ (toString isxL) ) context="12"}^^^

```elm {l context="12"}
isyF = varIsFreeInFLPO (Var "y") f
isyL = varIsLinkedInFLPO (Var "y") f
```
^^^elm {m=("Es $y$ libre? " ++ (toString isyF) ++ "Es $y$ ligada? " ++ (toString isyL) ) context="12"}^^^

```elm {l context="12"}
iszF = varIsFreeInFLPO (Var "z") f
iszL = varIsLinkedInFLPO (Var "z") f
```
^^^elm {m=("Es $z$ libre? " ++ (toString iszF) ++ "Es $z$ ligada? " ++ (toString iszL) ) context="12"}^^^


$-$ *F√≥rmulas abiertas y cerradas*

Recordemos que una f√≥rmula es abierta si todas sus variables son exclusivamente abiertas, o equivalentemente si no contiene cuantificadores. Y una f√≥rmula es cerrada si todas sus variables son exclusivamente cerradas. En la librer√≠a Logicus las funciones *isOpenFLPO* y *isClosedFLPO* resuelven este aspecto:

    isOpenFLPO : FormulaLPO -> Bool
    isOpenFLPO f =
    case f of
        Pred _ _ -> True
        Equal _ _ -> True
        Neg p -> isOpenFLPO p
        Conj p q -> isOpenFLPO p && isOpenFLPO q
        Disj p q -> isOpenFLPO p && isOpenFLPO q
        Impl p q -> isOpenFLPO p && isOpenFLPO q
        Equi p q -> isOpenFLPO p && isOpenFLPO q
        Exists _ _ -> False
        Forall _ _ -> False
        Insat -> True
    
    isClosedFLPO : FormulaLPO -> Bool
    isClosedFLPO f = List.all (\v -> varIsLinkedInFLPO v f) (varsInFormula f)

De forma que podemos preguntar, por ejemplo, si las f√≥rmulas $F$, $G$ y $H$ son abiertas, cerradas o ninguna de las dos:

 $$ F: L(x, C√©sar) \vee O(C√©sar, y)$$ $$G: \forall x \, L(x, C√©sar) \vee \exists y \, O(C√©sar, y)$$ $$H: \forall x \, L(x, C√©sar) \vee O(C√©sar, y)$$

 1. Definimos las f√≥rmulas

 ```elm {l context="13"}

 import Logicus.SintaxSemanticsLPO exposing (..)
 import Logicus.IO_LPO exposing (..)
 import Bool.Extra exposing (toString)

 f : FormulaLPO
 f =  fromStringToFLPO "L[x;_C√©sar;] OR O[_C√©sar; y;]" |> extractReadFLPO

 g : FormulaLPO
 g =  fromStringToFLPO "FORALL{x} L[x;_C√©sar;] OR EXISTS{y} O[_C√©sar; y;]" |> extractReadFLPO

 h : FormulaLPO
 h =  fromStringToFLPO "FORALL{x} L[x;_C√©sar;] OR O[_C√©sar; y;]" |> extractReadFLPO

 ```

 2. Preguntamos si cada una de las f√≥rmulas son abiertas/cerradas:

 ```elm {l context="13"}
 isOF = isOpenFLPO f
 isCF = isClosedFLPO f
 ```
 ^^^elm {m=("Es $F$ abierta? " ++ (toString isOF) ++ "Es $F$ cerrada? " ++ (toString isCF) ) context="13"}^^^

 ```elm {l context="13"}
 isOG = isOpenFLPO g
 isCG = isClosedFLPO g
 ```
 ^^^elm {m=("Es $G$ abierta? " ++ (toString isOG) ++ "Es $G$ cerrada? " ++ (toString isCG) ) context="13"}^^^

 ```elm {l context="13"}
 isOH = isOpenFLPO h
 isCH = isClosedFLPO h
 ```
 ^^^elm {m=("Es $H$ abierta? " ++ (toString isOH) ++ "Es $H$ cerrada? " ++ (toString isCH) ) context="13"}^^^

$-$ *F√≥rmulas bien formadas  y renombramiento de variables.*

Recordemos que consideramos una f√≥rmula bien formada a aquella que es sint√°cticamente correcta y que no contiene cuantificadores anidados sobre una misma variable. La funci√≥n *checkWFF* permite comprobar si una f√≥rmula est√° bien formada o no:

    checkWFF : FormulaLPO -> Bool
    checkWFF x = checkWFFAux x []
    
    checkWFFAux : FormulaLPO -> List Variable -> Bool
    checkWFFAux x ls =
        case x of
            Pred _ _ -> True
            Equal _ _-> True
            Neg p -> checkWFFAux p ls
            Conj p q -> checkWFFAux p ls && checkWFFAux q ls
            Disj p q -> checkWFFAux p ls && checkWFFAux q ls
            Impl p q -> checkWFFAux p ls && checkWFFAux q ls
            Equi p q -> checkWFFAux p ls && checkWFFAux q ls
            Exists v p -> not(List.member v ls) && checkWFFAux p ls && checkWFFAux p (ls ++ [v])
            Forall v p -> not(List.member v ls) && checkWFFAux p ls && checkWFFAux p (ls ++ [v])
            Insat -> True

Recordemos el criterio que establecimos en el renombramiento de variables: *Se renombrar√°n todas las ocurrencias ligadas de cada variable a√±adiendo el sub√≠ndice correspondiente seg√∫n el orden y cardinalidad de aparici√≥n del cuantificador (sobre dicha variable) al que est√° ligada dicha ocurrencia (tomando el orden seg√∫n el recorrido en profundidad del $AF$ de la f√≥rmula)*

En la librer√≠a, la funci√≥n *renameVars* que permite renombrar las variables de una f√≥rmula siguiendo este mismo criterio:

    renameVars : FormulaLPO -> FormulaLPO
    renameVars f = Tuple.first <| renameVarsAux Dict.empty Dict.empty f
    
    renameVarsAux : Dict String Int -> Dict String Int -> FormulaLPO -> (FormulaLPO, Dict String Int)
    renameVarsAux act mem  f =
    case f of
        Pred n terms ->
            let
                s = Dict.map (\ k v -> Var (k ++ "_" ++ String.fromInt v)) act
            in
                (Pred n <| List.map (\ t -> applySubsToTerm s t) terms, mem)
    
        Equal t1 t2 ->
            let
                s = Dict.map (\ k v -> Var (k ++ "_" ++ String.fromInt v)) act
            in
                (Equal (applySubsToTerm s t1) (applySubsToTerm s t2), mem)
    
        Neg g ->
            let
                (ng, nmem) = renameVarsAux act mem g
            in
                (Neg ng, nmem)
    
        Conj g h ->
            let
                (ng, nmem) = renameVarsAux act mem g
            in
                let
                    (nh, nmem2) = renameVarsAux act nmem h
                in
                    (Conj ng nh, nmem2)
    
        Disj g h ->
            let
                (ng, nmem) = renameVarsAux act mem g
            in
                let
                    (nh, nmem2) = renameVarsAux act nmem h
                in
                    (Disj ng nh, nmem2)
        Impl g h ->
            let
                (ng, nmem) = renameVarsAux act mem g
            in
                let
                    (nh, nmem2) = renameVarsAux act nmem h
                in
                    (Impl ng nh, nmem2)
        Equi g h ->
            let
                (ng, nmem) = renameVarsAux act mem g
            in
                let
                    (nh, nmem2) = renameVarsAux act nmem h
                in
                    (Equi ng nh, nmem2)
        Forall (Var x) g ->
            let
                xind = (Maybe.withDefault 0 <| Dict.get x mem) + 1
            in
                let
                    nact = Dict.insert x xind act
                    nmem = Dict.insert x xind mem
                in
                    let
                        (ng, nmem2) = renameVarsAux nact nmem g
                    in
                        (Forall (Var (x ++ "_" ++  String.fromInt xind)) ng, nmem2)
    
        Exists (Var x) g ->
            let
                xind = (Maybe.withDefault 0 <| Dict.get x mem) + 1
            in
                let
                    nact = Dict.insert x xind act
                    nmem = Dict.insert x xind mem
                in
                    let
                        (ng, nmem2) = renameVarsAux nact nmem g
                    in
                        (Exists (Var (x ++ "_" ++  String.fromInt xind)) ng, nmem2)
    
        _ -> (Insat, mem)


*NOTA: La funci√≥n 'applySubsToTerm' la veremos cuando estudiemos las sustituciones (en el siguiente apartado)*.

De forma que podemos aplicar las funciones anteriores al siguiente ejemplo, tal que : $$F: \forall x\,\exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists y\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la f√≥rmula:

```elm {l context="14"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f =  fromStringToFLPO "FORALL{x} EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{y} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO

```

2. Ve√°mos si est√° bien formada:

```elm {l context="14"}
isWFF_F = checkWFF f
```

^^^elm {m=("Est√° $F$ bien formada? " ++ (toString isWFF_F) ) context="14"}^^^

3. Aplicamos el renombramiento de variables:

```elm {l context="14"}
f2 = renameVars f
```

^^^elm {m=((toLatexFLPO f2)) context="14"}^^^

4. Comprobemos si $F_2$ est√° bien formada:

```elm {l context="14"}
isWFF_F2 = checkWFF f2
```

^^^elm {m=("Est√° $F$ bien formada? " ++ (toString isWFF_F2) ) context="14"}^^^

$-$ *Clausura de las f√≥rmulas*

Como ya hemos comentado los m√©todos que vamos a estudiar se basan en el trato de f√≥rmulas cerradas, por lo que cuando las f√≥rmulas no lo son, es necesario clausurarlas universal o existencialmente. La librer√≠a Logicus implementa ambos m√©todos de clausura en las funciones *universalClausureFLPO* y *existencialClausureFLPO*.

    universalClausureFLPO : FormulaLPO -> FormulaLPO
    universalClausureFLPO f = renameVars <| universalClausureFLPOAux f (List.filter (\ v -> varIsFreeInFLPO v f) <| varsInFormula f)
    
    universalClausureFLPOAux : FormulaLPO -> List Variable -> FormulaLPO
    universalClausureFLPOAux f ls =
        case ls of
            [] -> f
            x::xs -> universalClausureFLPOAux (Forall x f) xs
    
    existencialClausureFLPO : FormulaLPO -> FormulaLPO
    existencialClausureFLPO f = renameVars <| existencialClausureFLPOAux f (List.filter (\ v -> varIsFreeInFLPO v f) <| varsInFormula f)
    
    existencialClausureFLPOAux : FormulaLPO -> List Variable -> FormulaLPO
    existencialClausureFLPOAux f ls =
        case ls of
            [] -> f
            x::xs -> existencialClausureFLPOAux (Exists x f) xs

De forma que, si tenemos la f√≥rmula: $$F: \exists y\,\left( P\left(x, y\right)\rightarrow \left( P\left(x, z\right) \vee \exists z\,\left( P\left(y, z\right) \wedge P\left(x, y\right) \right) \right) \right)$$

1. Definimos la funci√≥n

```elm {l context="15"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Bool.Extra exposing (toString)

f : FormulaLPO
f =  fromStringToFLPO "EXISTS{y} (P[x;y;] IMPLIES (P[x;z;] OR EXISTS{z} (P[y;z;] AND P[x;y;])))" |> extractReadFLPO

```

2. La clausura universal de la f√≥rmula corresponder√≠a a:

```elm {l context="15"}
f2 = universalClausureFLPO f
```

^^^elm {m=((toLatexFLPO f2)) context="15"}^^^

2. La clausura existencial de la f√≥rmula corresponder√≠a a:

```elm {l context="15"}
f3 = existencialClausureFLPO f
```

^^^elm {m=((toLatexFLPO f3)) context="15"}^^^

#### Sustituciones en LPO

> Una sustituci√≥n (finita) o simplemente **sustituci√≥n**, **$\theta$** corresponde a una funci√≥n que asigna a un conjunto finito de variables un conjunto finito de t√©rminos  $\theta(x_i)=t_i \, (i=1,\ldots, n)$. Se denomina *dominio* de la funci√≥n al conjunto de variables que no permanecen invariantes ante la sustituci√≥n, esto es, $dom(\theta) = \{x_i / \theta(x_i) \neq x_i\}$.
>
> Para denotar una sustituci√≥n, lo hacemos por $\theta=\{x_1/t_1, \ldots, x_n/t_n\}$ o tambi√©n $\theta=\{(x_1,t_1), \ldots, (x_n,t_n)\}$.

##### Aplicaci√≥n de sustituciones a t√©rminos.

La aplicaci√≥n de una sustituci√≥n a un t√©rmino consiste en intercambiar las variables que participan en dicho t√©rmino seg√∫n la correspondencia que establece la sustituci√≥n y se denota por $\theta(t)$ o tambi√©n $t\{x_1/t_1, \ldots, x_n/t_n\}$. Formalmente: $$\theta(t) = \left\lbrace \begin{array}{lll} \theta(x_i) & si \, t=x_i & [t \textit{ es una variable}]\\ f(\theta(t_1), \ldots, \theta(t_m)) & si \, t=f(t_1, \ldots, t_m) & [t \textit{ es una funci√≥n de aridad } m ]\\  \end{array}\right.$$

Por ejemplo, tengamos la sustituci√≥n $\theta = \{x/(x+y), z/\boldsymbol{0}, u/\boldsymbol{1}\}$ y el t√©rmino $t=(x+y)+z$, de esta forma tendr√≠amos $\theta(t)=((x+y) + y) + \boldsymbol{0}$.

N√≥tese el car√°cter simult√°neo de la susutituci√≥n, esto es, la sustituci√≥n de todos las variables se realiza simult√°neamente de forma que **no** se tiene  $\{x_i/x_j, x_j/t_j\} \equiv \{x_i/t_j, x_j/t_j\}$. Por ejemplo, tengamos el t√©rmino del ejemplo anterior y la sustituci√≥n $\theta_2 = \{x/(x+y), y/\boldsymbol{0}\}$, entonces: $$((x+y)+z)\{x/(x+y), y/\boldsymbol{0}\} \neq ((x+\boldsymbol{0})+\boldsymbol{0})+z$$ $$((x+y)+z)\{x/(x+y), y/\boldsymbol{0}\} = ((x+y)+\boldsymbol{0})+z$$

##### Aplicaci√≥n de sustituciones a f√≥rmulas.
La aplicaci√≥n de una sustituci√≥n a un t√©rmino consiste en intercambiar todas las ocurrencias **libres** de las variables del dominio de la sustituci√≥n en $F$ por los t√©rminos que les corresponden en la sustituci√≥n. Se denota por $\theta(F)$ o tambi√©n $F\{x_1/t_1, \ldots, x_n/t_n\}$ de forma que:

$$\theta(F) \equiv \left\lbrace \begin{array}{ll} P(\theta(t_1), \ldots, \theta(t_n)) & si \, F\equiv P(t_1, \ldots, t_n)\\ \neg \theta(G) & si \, F \equiv \neg G \\ \theta(G) \wedge \theta(H) & si \, F \equiv G \wedge H \\ \theta(G) \vee \theta(H) & si \, F \equiv G \vee H \\ \theta(G) \rightarrow \theta(H) & si \, F \equiv G \rightarrow H \\ \theta(G) \leftrightarrow \theta(H) & si \, F \equiv G \leftrightarrow H \\ \exists x \, G\{x_i/t_i : x_i \in dom(\theta) \wedge x_i \neq x\} & si \, F \equiv \exists x  \, G \\ \forall x \, G\{x_i/t_i : x_i \in dom(\theta) \wedge x_i \neq x\} & si \, F \equiv \forall x  \, G \\ \end{array}\right.$$

 $\longrightarrow$ <u>Sustituciones admisibles</u>

 No toda sustituci√≥n es admisible para una f√≥rmula, por ejemplo, t√©ngase la f√≥rmula $F \equiv \exists x \, \neg(x=y)$ y t√©ngase la sustituci√≥n $\theta = \{y/x\}$, entonces $\theta(F) = \exists x \neg (x=x)$. Claramente el sentido de la f√≥rmula ha cambiado, mientras que en la primera f√≥rmula se establece que debe haber, al menos, dos objetos distintos en la segunda se tiene que existe al menos un objeto que es distinto de s√≠ mismo (que es sencillamente falso.)

 De esta forma:

 > Una variable, $x_i \in dom(\theta)$, de una f√≥rmula, $F$, es sustituible por el t√©rmino correspondiente, $t_i$, si y s√≥lo si la aplicaci√≥n de la sustituci√≥n, $\theta(F)$ no produce nuevas ocurrencias ligadas.

 Formalmente, una variable $x_i$ de $F$ es sustituible por $t_i$ si se da alguna de las siguientes condiciones:

 1. $F$ es at√≥mica.
 2. $F  \equiv \neg G$ y $x_i$ es sustituible por $t_i$ en $G$
 3. $F  \equiv G \left( \wedge | \vee | \rightarrow | \leftrightarrow \right) H$ y $x_i$ es sustituible por $t_i$ en $G$ y en $H$.
 4. $F \equiv \exists x G$ tal que o bien $(x=x_i)$, o bien $(x \neq x_i) \wedge (x \textit{ no ocurre en } t_i) \wedge (x_i \textit{ es sustituible en G})$.
 5. $F \equiv \forall x G$ tal que o bien $(x=x_i)$, o bien $(x \neq x_i) \wedge (x \textit{ no ocurre en } t_i) \wedge (x_i \textit{ es sustituible en G})$.

 De ahora en adelante, cuando escribamos $F\{x/t\}$ supondremos que $x$ es sustituible por $t$ en $F$.

 [*NOTA:* Si dada una f√≥rmula $F(x_1, \ldots, x_n)$, el orden de las variables est√° claro podemos abreviar $F\{x_1/t_1, \ldots, x_n/t_n\}$ por $F(t_1, \ldots, t_n)$]

 $\longrightarrow$ <u>Sustituciones en LogicUS</u>

Seg√∫n lo estudiado, las sustituciones establecen una correspondencia entre dos elementos, incluso notadas como un conjunto de pares variable-t√©rmino. Esto es directamente expresable en el *Elm* como *List Variable Term*, incluso si tomamos √∫nicamente las *Strings* de las variables podr√≠amos expresarlo como *List String Term* o mejor como *Dict String Term* (que no permite elementos repetidos en la clave (*String*)):

    type alias Substitution = Dict String Term

De forma que podemos definir una sustituci√≥n a trav√©s de la funci√≥n *Dict.fromList*. Por ejemplo, definamos la sustituci√≥n $\theta = \{x/(x+y), z/\boldsymbol{0}, u/z\}$

```elm {l context="16"}
import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Dict exposing (..)

theta : Substitution
theta =  Dict.fromList [("x", Func "+" [Var "x", Var "y"]), ("z", Func "0" []), ("u", Var "z")]

```
Aunque no resulta demasiado engorrosa esta definici√≥n de las sustituciones se ha provisto un parser en la funci√≥n *fromStringToSubstitutionLPO* para poder definir m√°s c√≥modamente las sustituciones siguiendo la notaci√≥n seg√∫n el patr√≥n:
<center><i>{[variable] / [t√©rmino], [variable] / [t√©rmino], ..., [variable] / [t√©rmino]}</i></center>

Tal que:

- Se nota como una secuencia escrita entre llaves y separada por comas.
- Los elementos de la secuencia corresponden a pares variable t√©rmino, separados por ' / ', de forma que la variable ha de seguir los criterios dados, anteriormente, para la sint√°xis de variables y los t√©rminos, an√°logamente, la sint√°xis dada para la definici√≥n de t√©rminos.

As√≠ la sustituci√≥n anterior se puede dar como:

```elm {l context="16"}

theta2 : Substitution
theta2 =  fromStringToSubstitutionLPO "{x/_+[x;y;], z/_0 , u/z}" |> extractReadSubstitutionLPO

```

^^^elm {m=(Debug.toString(theta2)) context="16"}^^^

*(NOTA: Recu√©rdese que las constantes se defini√≠an como funciones sin argumentos, esto seguidas de un espacio.)*

$-$ *Aplicaci√≥n de sustituciones a funciones*

La librer√≠a Logicus provee la funci√≥n *applySubsToFormula* que permite aplicar una sustituci√≥n a una f√≥rmula siguiendo los criterios estudiados anteriormente. Dada la definici√≥n recursiva de sustituci√≥n y t√©rmino la implementaci√≥n es directamente la aplicaci√≥n de esa definici√≥n, tanto para los t√©rminos como para las f√≥rmulas.

    applySubsToVar : Substitution -> Variable -> Term
    applySubsToVar s x = Maybe.withDefault x <| Dict.get (getVarSymb x) s
    
    applySubsToTerm : Substitution -> Term -> Term
    applySubsToTerm s t=
        case t of
            Var _ -> applySubsToVar s t
            Func sf ts -> Func sf (List.map (\term -> applySubsToTerm s term) ts)
    
    applySubsToFormula : Substitution -> FormulaLPO -> FormulaLPO
    applySubsToFormula s f =
        case f of
            Pred n ts ->  Pred n <| List.map (\t -> applySubsToTerm s t) ts
            Equal t1 t2 -> Equal (applySubsToTerm s t1)  (applySubsToTerm s t2)
            Neg p ->  Neg <| applySubsToFormula s p
            Conj p q -> Conj (applySubsToFormula s p) (applySubsToFormula s q)
            Disj p q -> Disj (applySubsToFormula s p) (applySubsySubsToFormula : SubstitToFormula s q)
            Impl p q -> Impl (applySubsToFormula s p) (applySubsToFormula s q)
            Equi p q -> Equi (applySubsToFormula s p) (applySubsToFormula s q)
            Exists v p ->
                let
                    s2 = Dict.filter (\ k _ -> k /=  getVarSymb v) s
                in
                    Exists v (applySubsToFormula s2 p)
            Forall v p ->  
                let
                    s2 = Dict.filter (\ k _ -> k /=  getVarSymb v) s
                in
                    Forall v (applySubsToFormula s2 p)
            Insat -> Insat

De forma que, por ejemplo, para aplicar la sustituci√≥n  $\theta = \{x/(x+y), y/\boldsymbol{0}, u/\boldsymbol{1}\}$ a la f√≥rmula $F \equiv Z(x) \wedge Z(y) \rightarrow \exists z \, ((x¬∑y)=z \wedge Z(z))$ (*el producto de n√∫meros enteros es interno*).

```elm {l context="17"}
import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Dict exposing (..)

f : FormulaLPO
f = fromStringToFLPO "Z[x;] AND Z[y;] IMPLIES EXISTS{z} ((_¬∑[x;y;]=z) AND Z[z;])" |> extractReadFLPO

theta : Substitution
theta =  fromStringToSubstitutionLPO "{x/_+[x;y;], y/_0 , z/_0}" |> extractReadSubstitutionLPO

f2 = applySubsToFormula theta f
```
^^^elm {m=(toLatexFLPO f2) context="17"}^^^

### Sem√°ntica de la L√≥gica de Primer Orden

Vista la forma en la que se escriben y se leen las f√≥rmulas en la L√≥gica de Primer, el objetivo de la sem√°ntica es dotar de significado a los t√©rminos y f√≥rmulas de un Lenguaje de Primer Orden. Para ello vamos a ver los elementos que conforman la sem√°ntica:

> Sea $L$ un lenguaje de primer orden. Una **$L$‚Äìestructura** (o $interpretaci√≥n$) corresponde a un par $\mathcal{M}= (M, I)$ donde $M$ es un conjunto no vac√≠o llamado **universo** (o dominio) de la $L$-estructura e $I$ es una aplicaci√≥n tal que:
>1. Aporta una interpretaci√≥n para cada constante, dicha interpretaci√≥n se denota por $c^{\mathcal{M}}$, de forma que $\forall c \in L: \, c^\mathcal{M} \in M$. Esto es, a cada constante le asigna uno y s√≥lo uno de los elementos del universo.
>2. Aporta una interpretaci√≥n para cada uno de los s√≠mbolos de funci√≥n en $L$, tal que si $f$ corresponde a un s√≠mbolo de funci√≥n $n$-aria ($n>0$): $f^{\mathcal{M}} : M^{n} \longrightarrow M$
>3. Aporta una interpretaci√≥n booleana para cada uno de los s√≠mbolos de predicado en $L$, tal que si $P$ corresponde a un s√≠mbolo de predicado $n$-ario: $f^{\mathcal{M}} : P^{n} \longrightarrow \{0,1\}$, O equivalente se puede dar una interpretaci√≥n de que conjuntos $n$-arios cumplen dicho predicado de forma que $P^{n} \subseteq M^{n} $.
>En caso de trabajar con un LPO con igualdad: $=^{\mathcal{M}}: \{(a,a): a \in M\} $.

(Para facilitar la lectura, si no hay ambig√ºedad escribiremos $M$ en vez de $\mathcal{M}$)

Vamos a exponer algunos ejemplos de $L$-estructuras.

Tomemos el lenguaje $LA = \{\underbrace{\boldsymbol{0}, \boldsymbol{1}}_{const.}, \overbrace{<^{\left(2\right)} , =^{\left(2\right)}}^{pred.}, \underbrace{¬∑^{\left(2\right)}, +^{\left(2\right)}}_{func.}\}$

Una $L$-estructura podr√≠a ser: $$ \mathcal{M_1} = \left\lbrace\begin{array}{l} M_1 = \mathbb{N} \\ \boldsymbol{0}^{M_1} = 0; \boldsymbol{1}^{M_1} = 1; \\ +^{M_1} : \mathbb{N^2} \longrightarrow \mathbb{N}, \, +^{M_1}(n_1, n_2) =  n_1 + n_2 \\ ¬∑^{M_1} : \mathbb{N^2} \longrightarrow \mathbb{N}, \, ¬∑^{M_1}(n_1, n_2) =  n_1 ¬∑ n_2 \\ <^{M_1} : \mathbb{N^2} \longrightarrow Bool, \, <^{M_1} = \{(i,j): (i,j) \in \mathbb{N^2} \wedge (i < j)\}  \\  =^{M_1} : \mathbb{N^2} \longrightarrow Bool, =^{M_1} = \{(i,i) : i \in \mathbb{N}\}  \\ \end{array}\right.$$

Pero otra podr√≠a corresponder a: $$ \mathcal{M_2} = \left\lbrace\begin{array}{l} M_2 = \mathbb{Q} \\ \boldsymbol{0}^{M_2} = \frac{1}{2}; \boldsymbol{1}^{M_2} = 2; \\ +^{M_2} : \mathbb{Q}^2 \longrightarrow \mathbb{Q}, \, +^{M_2}(n_1, n_2) =  | n_1 - n_2 | \\ ¬∑^{M_2} : \mathbb{Q}^2 \longrightarrow \mathbb{Q}, \, ¬∑^{M_2}(n_1, n_2) =  n_1 \\ <^{M_2} : \mathbb{Q}^2 \longrightarrow Bool, \, <^{M_2} = \{(i,j): (i,j) \in \mathbb{Q^2} \wedge (i ¬∑ j > 0)\}  \\  =^{M_2} : \mathbb{Q^2} \longrightarrow Bool, =^{M_2} = \{(i,i) : i \in \mathbb{N}\}  \\ \end{array}\right.$$

Recordemos que el predicado de igualdad es invariante en cualquier $L$-estructura y expresa la igualdad entre objetos.

$\longrightarrow$ <u>$L$-estructuras en logicus</u>

Como hemos se√±alado una $L$-estructura se compone de 2 elementos un universo y una interpretaci√≥n, de forma que:

    type alias L_estructure a = (Universe a , Interpretation a)

El universo correspond√≠a a un conjunto de objetos:

    type alias Universe a = List a

Las interpretaciones corresponden a la definici√≥n de aplicaciones de $U^n \longrightarrow U$ para los s√≠mbolos de funciones y $U^n \longrightarrow Bool$ para los s√≠mbolos de predicados. Luego:

    type alias Interpretation a =
        { i_const : Dict String a
         , i_funct : Dict String ((List a) -> a)
         , i_pred : Dict String ((List a) -> Bool)
        }

Esto nos permite definir toda $L$-estructura sobre universos finitos, por ejemplo, tomando el lenguaje de la aritm√©tica y la $L$-estructura (de forma que cada elemento del universo tiene asociada la constante correspondiente):

$$ \mathcal{M} = \left\lbrace\begin{array}{l} M = \mathbb{N_{10}} \\ +^{M} : \mathbb{(N_{10})^2} \longrightarrow \mathbb{N_{10}}, \, +^{M}(n_1, n_2) =  n_1 + n_2 \\ ¬∑^{M} : \mathbb{(N_{10})^2} \longrightarrow \mathbb{N_{10}}, \, ¬∑^{M}(n_1, n_2) =  n_1 ¬∑ n_2 \\ <^{M} : \mathbb{(N_{10})^2} \longrightarrow Bool, \, <^{M}(n_1, n_2) = n_1 < n_2  \\  =^{M} : \mathbb{(N_{10})^2} \longrightarrow Bool, =^{M}(n_1, n_2) = (n_1 = n_2)  \\ \end{array}\right.$$

Recordemos que el predicado de igualdad no necesita definici√≥n y que las constantes en logicus tambi√©n se definen como funciones, de forma que:

```elm {l context="18"}

import Logicus.SintaxSemanticsLPO exposing (..)
import Logicus.IO_LPO exposing (..)
import Dict exposing (..)

m : Universe Int
m = [0,1,2,3,4,5,6,7,8,9,10]

isuma : List Int -> Int
isuma ls = List.sum ls

iprod : List Int -> Int
iprod ls = List.product ls

imenor : List Int -> Bool
imenor ls=
  case ls of
    [x,y] -> x < y
    _ -> False

i : Interpretation Int
i = { i_const = Dict.fromList <| List.map (\x -> (String.fromInt x, x)) m
    , i_funct = Dict.fromList [("+", isuma), ("¬∑", iprod)]
    , i_pred = Dict.fromList [("<", imenor)]}

m_estr : L_estructure Int
m_estr = (m, i)
```
^^^elm {m=(Debug.toString m_estr) context="18"}^^^

#### Interpretaci√≥n de las f√≥rmulas en LPO

Antes de explicar la interpretaci√≥n de las f√≥rmulas vamos ver c√≥mo se interpretar los t√©rminos que las conforman:

> Dada una $L$-estructura $\mathcal{M}$ a cada t√©rmino t√©rmino $t$ de $L$, **sin variables** , le corresponde un objeto o elemento de $M$, que viene dado por la interpretaci√≥n de la $L$-estructura ($t^{\mathcal{M}}$), de forma que: $$t^{\mathcal{M}} = \left\lbrace \begin{array}{ll} c^{\mathcal{M}} & \textrm{si } t \equiv c \, (\textrm{con } c=cte) \\ f^{\mathcal{M}}(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) & \textrm{si } t \equiv f(t_1, \ldots, t_n) \end{array}\right.$$

De forma que una vez interpretados los t√©rminos, podemos llevar a cabo la interpretaci√≥n de las f√≥rmulas, de forma que:

> Dada una $L$-estructura $\mathcal{M}$ decimos que una f√≥rmula **cerrada**, $F$, se satisface en $\mathcal{M}$ (y se denota por $\mathcal{M} \models F$) si se da alguno de los siguientes supuestos:
> 1. $F \equiv P(t_1, \ldots, t_n)$ y adem√°s $P^{\mathcal{M}}(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) = True$ o, equivalentemente, $(t_1^{\mathcal{M}}, \ldots, t_n^{\mathcal{M}}) \in P^\mathcal{M}$
> 2. $F \equiv \neg F_1$ y adem√°s $\mathcal{M} \not \models F_1$
> 3. $F \equiv F_1 \vee F_2$ y se tiene que  $\mathcal{M} \models F_1$ o  $\mathcal{M} \models F_2$ (an√°logo para el resto de conectivas).
> 4. $F \equiv \exists x \, F_1$ y adem√°s hay alg√∫n elemento $e \in M$ (representado por el t√©rmino $e$) tal que $\mathcal{M} \models F_1\{x/e\}$.
> 5. $F \equiv \forall x \, F_1$ y adem√°s todo elemento $e \in M$ (representado por el t√©rmino $e$) verifica $\mathcal{M} \models F_1\{x/e\}$.

En caso de que $F$ no sea cerrada se tiene, por definici√≥n:

$$\left( \mathcal{M} \models F \right) \Leftrightarrow \left(\mathcal{M} \models \forall{x_1, \ldots, x_n} F(x_1, \ldots, x_n)\right)$$

$\longrightarrow$ <u>Interpretaci√≥n de t√©rminos y f√≥rmulas en Logicus</u>

Acudiendo a la definici√≥n expuesta:

    interpretsTerm : Term -> Interpretation a ->  Maybe a
    interpretsTerm t i =
        case t of
            Var _ -> Nothing
            Func s [] -> Dict.get s i.i_const
            Func s args ->         
                let f = Dict.get s i.i_funct in
                    case f of
                        Nothing -> Nothing
                        Just x ->
                            let ls = List.map (\t2 -> interpretsTerm t2 i) args in
                                if List.any isNothing ls then
                                    Nothing
                                else
                                    Just <| x (values ls)

(Recu√©rdese que s√≥lo se admiten interpretaciones sobre t√©rminos sin variables, luego, si en un t√©rmino aparecen variables no es posible realizar su interpretaci√≥n por lo que el objeto devuelto corresponde a un objeto vac√≠o.)

An√°logamente, seg√∫n la definici√≥n recursiva dada para la interpretaci√≥n de las f√≥rmulas:

    interpretsFLPO : FormulaLPO -> L_estructure a -> Maybe Bool
    interpretsFLPO f estr = interpretsFLPOAux (universalClausureFLPO f) estr
    
    interpretsFLPOAux : FormulaLPO -> L_estructure a -> Maybe Bool
    interpretsFLPOAux f (m,i) =
        case f of
            Pred sp terms ->
                let ip = Dict.get sp i.i_pred in
                    case ip of
                        Nothing -> Nothing
                        Just x ->
                            let ls = List.map (\t -> interpretsTerm t i) terms in
                                if List.any isNothing ls then
                                    Nothing
                                else
                                    Just <| x (values ls)
            Equal t1 t2->
                let it1 = interpretsTerm t1 i
                    it2 = interpretsTerm t2 i
                in
                    if isNothing it1 || isNothing it2 then
                        Nothing
                    else Just  (it1 == it2)
    
            Neg f1 -> andThen (\if1 -> Just (not if1)) (interpretsFLPOAux f1 (m,i))
            Conj f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x && y)
            Disj f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x || y)
            Impl f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (not x || y)
            Equi f1 f2 ->
                let if1 = interpretsFLPOAux f1 (m,i)
                    if2 = interpretsFLPOAux f2 (m,i)
                in
                    case if1 of
                        Nothing -> Nothing
                        Just x ->   
                            case if2 of
                                Nothing -> Nothing
                                Just y -> Just (x == y)
            Exists v f1 ->
                let ls = combine <| List.map (\o -> interpretsFLPOAux (applySubsToFormula (Dict.singleton (getVarSymb v) (Func o [])) f1) (m,i)) (Dict.keys i.i_const)in
                    case ls of
                        Nothing -> Nothing
                        Just li -> Just <| List.any (\x -> x) li
            Forall v f1 ->
                let ls = combine <| List.map (\o -> interpretsFLPOAux (applySubsToFormula (Dict.singleton (getVarSymb v) (Func o [])) f1) (m,i)) (Dict.keys i.i_const)in
                    case ls of
                        Nothing -> Nothing
                        Just li -> Just <| List.all (\x -> x) li
            Insat -> Just False

(De forma que la funci√≥n devolver√° un objeto vac√≠o si existe alg√∫n s√≠mbolo en la f√≥rmula que no est√© recogido en la $L$-estructura, por tanto imposible de interpretar).

Ve√°mos algunos ejemplos, probando si se cumplen algunas propiedades sobre el ejemplo anterior:

1. El elemento neutro de la suma es el 0: $\forall x \in \mathbb{N}_{10}: \, (x+0)=x$

```elm {l context="18"}

f1 = fromStringToFLPO "_+[x;_0;] = _0 " |> extractReadFLPO

-- Ejecutamos interpretsFLPO f1 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f1 m_estr) context="18"}^^^

2. Todo n√∫mero m√∫ltiplo de 4 es tambi√©n m√∫ltiplo de 2: $\forall x (\exists y (4¬∑y)=x \rightarrow \exists y (2¬∑y)=x)$

```elm {l context="18"}

f2 = fromStringToFLPO "FORALL{x} (EXISTS{y} (_¬∑[_4;y;] =x) IMPLIES EXISTS{y} (_¬∑[_2;y;] = x))" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f2 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f2 m_estr) context="18"}^^^

Sin embargo, el rec√≠proco no es cierto:

```elm {l context="18"}

f3 = fromStringToFLPO "FORALL{x} (EXISTS{y} (_¬∑[_2;y;] =x) IMPLIES EXISTS{y} (_¬∑[_4;y;] = x))" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f3 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f3 m_estr) context="18"}^^^

3. Ve√°mos que la suma no es interna, esto es, $\neg \forall x \forall y \exists z (z = (x+y))$

```elm {l context="18"}

f4 = fromStringToFLPO "NOT FORALL{x} FORALL{y} EXISTS{z} (z=_+[x;y;])" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f4 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f4 m_estr) context="18"}^^^

4. Ve√°mos que no se tiene que para todo n√∫mero existe uno que es mayor, $\forall x \exists y (x < y)$
```elm {l context="18"}

f5 = fromStringToFLPO "FORALL{x} EXISTS{y} (<[x;y;])" |> extractReadFLPO

-- Ejecutamos interpretsFLPO f5 m_estr
```
^^^elm {m=(Debug.toString <| interpretsFLPO f5 m_estr) context="18"}^^^

####  Satisfactibilidad, Validez y Consecuencia L√≥gica en LPO

Igual que ve√≠amos que una f√≥rmula en LP es satisfactible si exist√≠a al menos un modelo, en LPO se dice que una f√≥rmula es **satisfactible** si existe, al menos, un modelo para dicha f√≥rmula, esto es si existe una $L$-estructura en la que se satisface ($\mathcal{M} \models F$). De forma an√°loga un conjunto de f√≥rmulas $\Sigma$ es **consistente** si existe una $L$-estructura tal que toda f√≥rmula de $\Sigma$ se satisface en $\mathcal{M}$

Una f√≥rmula se dice **l√≥gicamente v√°lida** si para toda $L$-estructura ($\mathcal{M}$) se tiene $\mathcal{M} \models F$ (por ejemplo, $\forall{x} P(x) \vee \exists x \neg P(x)$)

Por √∫ltimo, de igual forma que ve√≠amos el concepto de consecuencia l√≥gica en LP, en LPO se tiene que una f√≥rmula $F$ es **consecuencia l√≥gica** de un conjunto de f√≥rmulas $\Sigma$ (y se denota por $\Sigma \models F$) si se tiene que para toda $L$-estructura $\mathcal{M}$, $\mathcal{M} \models \Sigma \Rightarrow \mathcal{M} \models F$

Al contrario que en LP, en el que exist√≠an algoritmos (aunque ineficientes) que permit√≠an determinar los problemas de consistencia y consecuencia l√≥gica, en LPO este mismo problema no es decidible, esto es no existen algoritmos que permitan determinar, de forma completa, la consistencia de un conjunto de f√≥rmulas (equivalente al problema de la consecuencia l√≥gica).

Durante los siguientes temas estudiaremos algoritmos que tratar√°n de resolver el problema, aunque no sean decisivos en todos los casos.
