## **TEMA 1**
Sintaxis y Sem√°ntica en LP y LPO
====================

Descripci√≥n general del cap√≠tulo
--------------------------------

En este cap√≠tulo se recogen, de forma detallada, los m√≥dulos implementados que abordan el √°mbito de la sintaxis y sem√°ntica de la L√≥gica Proposicional y Primer Orden. Complementariamente, en el *Anexo A. Parsers* se encuentra el desarrollo de varios Parsers, que nos permiten acercar la escritura natural de las f√≥rmulas a la definici√≥n en el sistema.

### <u> Estructura del cap√≠tulo </u>

El cap√≠tulo se encuentra estructurado en distintas secciones, a trav√©s de las cuales se abordan los conceptos fundamentales del √°mbito sint√°ctico-sem√°ntico de la LP y la LPO, presentados conjuntamente con los m√≥dulos que implementan dichos conceptos:

-   **M√≥dulo SintaxSemanticsLP**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sint√°cticoS Y sem√°nticos de la L√≥gica Proposicional.

-   **M√≥dulo SintaxSemanticsLPO**. Recoge las implementaciones de los tipos fundamentales relacionados con los aspectos sint√°cticos y sem√°nticos de la L√≥gica de Primer Orden.

-   **M√≥dulo IO\_LP**. Recoge las implementaciones de los m√©todos relacionados con la lectura y representaci√≥n de las f√≥rmulas LP.

-   **M√≥dulo IO\_LPO**. Recoge las implementaciones de los m√©todos relacionados con la lectura y representaci√≥n de las f√≥rmulas LPO.


1.1. Conceptos b√°sicos de la L√≥gica Proposicional
--------------------------------------------

### Caracterizaci√≥n b√°sica de la L√≥gica Proposicional

La L√≥gica surge como m√©todo de modelado del siguiente problema:

> *Dado un conjunto de asertos (afirmaciones), $\mathcal{BC}$ (*Base de conocimiento*), y una afirmaci√≥n, $\mathcal{A}$, decidir si $\mathcal{A}$ ha de ser necesariamente cierta supuestas ciertas las f√≥rmulas de $\mathcal{BC}$.* 


De manera que para abordar este problema resultan necesarios los siguientes elementos:

-   Un lenguaje que permita expresar de manera formal y precisa las afirmaciones, hechos e hip√≥tesis. (<u>Sintaxis</u>)

-   Una definici√≥n clara de qu√© se considera *afirmaci√≥n cierta*  (<u>Sem√°ntica</u>)

-   Mecanismos efectivos (y a poder ser eficientes) que garanticen la correcci√≥n (y preferentemente la completitud) en las deducciones. (<u>Algoritmos de decisi√≥n</u>)

A lo largo de los distintos cap√≠tulos abordaremos estos puntos para las dos representaciones m√°s comunes, la L√≥gica Proposicional (*LP* o *PL*) y la L√≥gica de Primer Orden (*LPO* o *FOL*).

Por el momento vamos a comenzar este primer cap√≠tulo abordando los dos primeros puntos para la L√≥gica Proposicional y la L√≥gica de Primer Orden, dando una somera introducci√≥n al tercero para cada caso dejando el desarrollo de los algoritmos de decisi√≥n, que se ir√°n abordando a lo largo del resto de cap√≠tulos.

#### Caracter√≠sticas fundamentales de la LP.

-   Sus expresiones (denominadas f*√≥rmulas proposicionales* o *proposiciones*) modelan afirmaciones que pueden considerarse *ciertas* o *falsas*.

-   Las f√≥rmulas proposicionales (en adelante f√≥rmulas (si no existe ambig√ºedad)), se construyen mediante un conjunto de expresiones  b√°sicas (*f√≥rmulas at√≥micas* o *√°tomos*) y conjunto de operadores (*conectivas l√≥gicas*). Dichas conectivas permiten modelar los  siguientes tipos de afirmaciones:

    -   *Conjunci√≥n*: ‚Äò... tal ... Y ... cual ...‚Äô

    -   *Disyunci√≥n*: ‚Äò... tal ... O ... cual ...‚Äô

    -   *Implicaci√≥n*: ‚ÄòSI tal ... ENTONCES ... cual ...‚Äô

    -   *Equivalencia*: ‚Äò... tal ... SI Y S√ìLO SI ... cual ...‚Äô

    -   *Negaci√≥n*: ‚ÄòNO es cierto tal ...‚Äô

    Profundizaremos en este aspecto en la pr√≥xima secci√≥n, cuando  veamos la *Sintaxis de la LP*.

-   El lenguaje s√≥lo permite modelar este tipo de afirmaciones, por lo que muchas veces puede ser dif√≠cil (o imposible) representar el problema en este tipo de L√≥gica, y es necesario recurrir a otras m√°s  ricas (*LPO, L√≥gicas Modales, L√≥gica Fuzzy, etc*). Especificaremos este apartado cuando tratemos las limitaciones de la LP e introduzcamos la LPO.

-   Aunque esta L√≥gica puede resultar de una aparente sencillez, el problema *SAT* corresponde a la categor√≠a de problemas NP-completos, esto es, no existe ning√∫n algoritmo capaz de resolver el problema planteado en un tiempo polinomial de ejecuci√≥n. Trataremos de nuevo este aspecto en la introducci√≥n a los algoritmos de decisi√≥n.

1.2. Fundamentos de la l√≥gica proposicional
--------------------------------------------

Vamos a abordar desde un punto de vista te√≥rico-pr√°ctico, los elementos base que conforman la L√≥gica Proposicional, esto es la S√≠ntaxis y la Sem√°ntica, mostrando unificadamente los desarrollos formales como las implementaciones llevadas a cabo para modelar cada uno de ellos.

### Sint√°xis de la l√≥gica Proposicional

#### El alfabeto proposicional

El concepto ‚Äò*alfabeto proposicional*‚Äô referencia al conjunto de s√≠mbolos que forman parte de este lenguaje. Podemos distinguir las siguientes categor√≠as:

-   **Variables proposicionales o √°tomos**. Ya hemos se√±alado previamente que todo problema est√° representado por relaciones entre un conjunto finito de afirmaciones b√°sicas, dichas afirmaciones se representan por s√≠mbolos proposicionales: $VP = \{p_0, p_1, \ldots, p, q, r\}$. <br><br>

    Aunque, formalmente, no existe ninguna restricci√≥n, vamos a adoptar el siguiente criterio en relaci√≥n a la sintaxis de los s√≠mbolos proposicionales:<br><br>

    > Los s√≠mbolos proposicionales deben comenzar por una letra min√∫scula, seguida (opcionalmente) de otros caract√©res en min√∫scula o d√≠gitos num√©ricos, exclusivamente.

-   **Conectivas L√≥gicas**. Modelan las relaciones entre las distintas afirmaciones b√°sicas (√°tomos). Podemos distinguir:

    -   De aridad 1 o monoaria : *Negaci√≥n* ($\neg$).

    -   De aridad 2 o binarias: *Conjunci√≥n* ($\wedge$), *Disyunci√≥n* ($\vee$), *Condicional* ($\rightarrow$), *Bicondicional* ($\leftrightarrow$).<br><br>

-   **S√≠mbolos Auxiliares**: ‚Äò*(*‚Äô y ‚Äò*)*‚Äô. Permiten expresar relaciones de prioridad entre conectivas l√≥gicas y evitar la ambigi√ºedad en la interpretaci√≥n de las f√≥rmulas.

#### F√≥rmula Proposicional

Se denomina expresi√≥n del lenguaje proposicional a cada una sucesi√≥n finita (y no vac√≠a) de sus s√≠mbolos y conectivas.Un ejemplo de expresi√≥n puede ser la siguiente $a \rightarrow b )ca\vee$, otro puede corresponder a $(a \rightarrow b ) \vee c$. Parece claro que el primero posee ‚Äúuna coherencia‚Äù o‚Äúequilibrio que no parece tener el primero. De esta forma, las expresiones "bien formadas" las denominaremos **f√≥rmulas proposicionales**.

> Formalmente, El conjunto de las f√≥rmulas proposicionales, $PROP$, es el menor conjunto de expresiones que verifica:
> - $VP \subseteq PROP$
> - Es cerrado bajo las conectivas l√≥gicas, esto es:
    - Si una f√≥rmula $F \in PROP$, entonces $\neg F \in PROP$
    - Si las f√≥rmulas $F, G \in PROP$, entonces $(F \wedge G), (F \vee G), (F \rightarrow G), (F \leftrightarrow G) \in PROP$

De manera que se tiene una definici√≥n recursiva del concepto de *F√≥rmula Proposiciona*, tal que el caso base corresponde a una f√≥rmula b√°sica (*√°tomo*) y el caso recursivo corresponde a la aplicaci√≥n de una conectiva sobre una o dos f√≥rmulas (seg√∫n la aridad de la conectiva).

##### √Årboles de formaci√≥n

Cada una de las f√≥rmulas proposicionales lleva asociado un grafo de tipo √°rbol (esencialmente √∫nico), que muestra el desarrollo de formaci√≥n de la f√≥rmula, siguiendo la definici√≥n recursiva de la misma.

Por ejemplo a la f√≥rmula: $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$ le corresponde el √°rbol de formaci√≥n:

<center> <img src="images/img1.png" title="√Årbol formaci√≥n (ejemplo)")></center><br>

##### Prioridad de conectivas y Reducci√≥n de par√©ntesis.

Para facilitar la escritura y lectura de las f√≥rmulas vamos a adoptar algunos criterios:

1.  Omitimos los par√©ntesis externos.<br><br>
2.  Tomaremos como orden de precedencia de las conectivas (de mayor a  menor): $\neg$, $\wedge$, $\vee$ , $\rightarrow$, $\leftrightarrow$. (Para la conectiva $\leftrightarrow$ se recomienda mantener los par√©ntesis en todos los casos).<br><br>
3.  Cuando una conectiva se usa repetidamente, se asocia por la derecha.<br><br>

##### Principio de inducci√≥n sobre f√≥rmulas

Gracias a la definici√≥n de $PROP$ (y su estructura recursiva), para probar que toda f√≥rmula proposicional satisface una cierta propiedad ($\Psi$), podemos hacerlo aplicando el m√©todo de inducci√≥n sobre f√≥rmulas.

De esta forma, probamos:

1.  (*Caso base*). Probar que todos los elementos de $VP$ tienen la propiedad $\Psi$.

2.  (*Paso de inducci√≥n*).

    -  Si $F \in PROP$ tiene la propiedad $\Psi$, entonces $\neg F$ tiene la propiedad $\Psi$.

    -  Si $F, G \in PROP$, tienen la propiedad $\Psi$ entonces $(F \wedge G), (F \vee G), (F \rightarrow G), (F \leftrightarrow G) \in PROP$ tienen la propiedad $\Psi$

##### Escritura de las f√≥rmulas en Logicus

Vamos a exponer cu√°l es la sintaxis de las f√≥rmulas utilizando la librer√≠a Logicous, que nos permitir√° definir f√≥rmulas y aplicar diversos algoritmos sobre las mismas. 

En la librer√≠a podemos definir las f√≥rmulas de dos formas distintas, o bien acudiendo directamente a los constructores de las f√≥rmulas (largo y engorroso), o bien utilizando el Parser (de forma an√°loga a la escritura natural de las f√≥rmulas).

$\longrightarrow$ <u>Definici√≥n de f√≥rmulas a partir de constructores</u>

Si recordamos la definici√≥n recursiva que se ha dado para las f√≥rmulas, expusimos que las mismas pueden corresponder o bien a √°tomos (*caso base*), o bien a la aplicaci√≥n de las conectivas, teniendo en cuenta la aridad de √©stas, sobre f√≥rmulas proposicionales (*caso recursivo*). 

Bien, pues la implementaci√≥n dada en la librer√≠a para las f√≥rmulas corresponde fielmente a dicha definici√≥n. De forma que:

- Los s√≠mbolos proposicionales se definen como cadenas de caract√©res, (recordando el criterio, estos caracteres deben ir en min√∫scula).<br><br>

        type alias PSymb = String 

- Las f√≥rmulas proposicionales se definen seg√∫n la estructura recursiva presentada.<br><br>

        type FormulaLP = Atom PSymb                 -- caso base 
                        | Neg FormulaLP             --‚é´
                        | Conj FormulaLP FormulaLP  --‚é™
                        | Disj FormulaLP FormulaLP  --‚é¨ casos recursivos
                        | Impl FormulaLP FormulaLP  --‚é™
                        | Equi FormulaLP FormulaLP  --‚é≠
                        | Insat                     -- f√≥rmula insatisfactible

Esto nos permite definir todas las f√≥rmulas proposicionales, para muestra algunos ejemplos:


a. $(p \wedge q) \vee (p \wedge r) \quad$ b. $ (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q \quad$ c. $(p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p$<br>

<pre style="background-color: #2B3856; color: white;"><font color="#555753">----</font> <font color="#06989A">Elm 0.19.1</font> <font color="#555753">----------------------------------------------------------------</font>
<font color="#555753">Say :help for help and :exit to exit! More at &lt;https://elm-lang.org/0.19.1/repl&gt;</font>
<font color="#555753">--------------------------------------------------------------------------------</font>
&gt; import Modules.SintaxSemanticsLP exposing (..)
&gt; import Modules.IO_LP exposing (toStringFLP)
&gt; a = Disj (Conj (Atom &quot;p&quot;) (Atom &quot;q&quot;)) (Conj (Atom &quot;p&quot;) (Atom &quot;r&quot;))
<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>))
<font color="#555753">    : FormulaLP</font>
&gt; toStringFLP a
<font color="#FCE94F">&quot;( ( p ‚àß q ) ‚à® ( p ‚àß r ) )&quot;</font><font color="#555753"> : String</font>
&gt; b = Impl (Disj (Conj (Atom &quot;p&quot;) (Atom &quot;r&quot;)) (Conj (Neg (Atom &quot;p&quot;)) (Atom &quot;q&quot;))) (Neg (Atom &quot;q&quot;))
<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>)) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))
<font color="#555753">    : FormulaLP</font>
&gt; toStringFLP b
<font color="#FCE94F">&quot;( ( ( p ‚àß r ) ‚à® ( ¬¨ p ‚àß q ) ) ‚ü∂ ¬¨ q )&quot;</font><font color="#555753"> : String</font>
&gt; c = Conj (Conj (Equi (Atom &quot;p&quot;) (Atom &quot;q&quot;)) (Impl (Atom &quot;p&quot;) (Neg (Atom &quot;q&quot;)))) (Atom &quot;p&quot;)
<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Equi</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)) (<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)))) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>)
<font color="#555753">    : FormulaLP</font>
&gt; toStringFLP c
<font color="#FCE94F">&quot;( ( ( p ‚ü∑ q ) ‚àß ( p ‚ü∂ ¬¨ q ) ) ‚àß p )&quot;</font><font color="#555753"> : String</font>
</pre><br>

*NOTA: La funci√≥n 'toStringFLP' permite dar una representaci√≥n en formato cadena a las f√≥rmulas*

Como se puede apreciar, escribir las f√≥rmulas de esta forma puede resultar una tarea ardua y propensa a errores, por eso, se ha desarrollado un parser que nos permite escribir de forma m√°s c√≥moda,sint√©tica y visual las f√≥rmulas. Para poder utilizarlo se han establecido una serie de requisitos sint√°cticos, an√°logos a los presentados anteriormente:

- Los s√≠mbolos proposicionales deben comenzar por un caracter en min√∫scula seguido, opcionalmente, de caracteres en min√∫scula, d√≠gitos o el s√≠mbolo '_'.<br><br>

- Para las conectivas se usar√°n los siguientes s√≠mbolos, manti√©ndose la prioridad de las conectivas definida (en el orden de prioridad descendente expuesto en la tabla).

<table style="margin-left: auto; margin-right: auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">Conectiva L√≥gica</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;text-decoration:underline;vertical-align:top;word-break:normal">S√≠mbolo Logicous</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Negaci√≥n (¬¨)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'NOT'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Conjunci√≥n (‚àß)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'AND'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Disyunci√≥n (‚à®)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'OR'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Implicaci√≥n (ü°í)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'IMPLIES'</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">Equivalencia (ü°ò)</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">'EQUIV'</td></tr></tbody></table><br> 

- Los par√©ntesis se utilizan de igual forma en que se han definido en el lenguaje formal de la l√≥gica proposicional, con los s√≠mbolos '(' y ')'. No son necesarios los par√©ntesis externos de las f√≥rmulas.<br><br>

- En caso de uso repetido de una misma conectiva, se realizar√° asociaci√≥n por la derecha.

A partir de este momento todas las f√≥rmulas de los ejemplos se definir√°n utilizando el Parser por lo que llegados a este punto se recomienda tener claras las reglas sint√°cticas a seguir, aunque, son an√°logas a las planteadas por el lenguaje formal de la l√≥gica proposicional.

Para definir los ejemplos expuestos anteriormente:

<pre style="background-color: #2B3856; color: white;"><font color="#555753">----</font> <font color="#06989A">Elm 0.19.1</font> <font color="#555753">----------------------------------------------------------------</font>
<font color="#555753">Say :help for help and :exit to exit! More at &lt;https://elm-lang.org/0.19.1/repl&gt;</font>
<font color="#555753">--------------------------------------------------------------------------------</font>
&gt; import Modules.IO_LP exposing (fromStringToFLP, extractReadFLP, toStringFLP)
&gt; aAux = fromStringToFLP &quot;(p AND q) OR (p AND r)&quot;
(<font color="#34E2E2">Just</font> (<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>))),<font color="#FCE94F">&quot;&quot;</font>)
<font color="#555753">    : ( Maybe Modules.SintaxSemanticsLP.FormulaLP, String )</font>
&gt; a = extractReadFLP aAux
<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>))
<font color="#555753">    : Modules.SintaxSemanticsLP.FormulaLP</font>
&gt; bAux = fromStringToFLP &quot;(p AND r) OR (NOT p AND q) IMPLIES NOT q&quot;
(<font color="#34E2E2">Just</font> (<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>)) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))),<font color="#FCE94F">&quot;&quot;</font>)
<font color="#555753">    : ( Maybe Modules.SintaxSemanticsLP.FormulaLP, String )</font>
&gt; b = extractReadFLP bAux
<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>)) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))
<font color="#555753">    : Modules.SintaxSemanticsLP.FormulaLP</font>
&gt; cAux = fromStringToFLP &quot;(p EQUIV q) AND (p IMPLIES NOT q) AND p&quot;
(<font color="#34E2E2">Just</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Equi</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>))),<font color="#FCE94F">&quot;&quot;</font>)
<font color="#555753">    : ( Maybe Modules.SintaxSemanticsLP.FormulaLP, String )</font>
&gt; c = extractReadFLP cAux
<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Equi</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>))
<font color="#555753">    : Modules.SintaxSemanticsLP.FormulaLP</font>
&gt; toStringFLP a
<font color="#FCE94F">&quot;( ( p ‚àß q ) ‚à® ( p ‚àß r ) )&quot;</font><font color="#555753"> : String</font>
&gt; toStringFLP b
<font color="#FCE94F">&quot;( ( ( p ‚àß r ) ‚à® ( ¬¨ p ‚àß q ) ) ‚ü∂ ¬¨ q )&quot;</font><font color="#555753"> : String</font>
&gt; toStringFLP c
<font color="#FCE94F">&quot;( ( p ‚ü∑ q ) ‚àß ( ( p ‚ü∂ ¬¨ q ) ‚àß p ) )&quot;</font><font color="#555753"> : String</font>
</pre>

N√≥tese que la funci√≥n *fromStringToFLP* proporciona una tupla de dos elementos el primero de ellos corresponde a la f√≥rmula le√≠da y el segundo a una cadena de texto. Bien, si cometemos alg√∫n error sint√°ctico en la escritura de la f√≥rmula el Parser no ser√° capaz de interpretarla correctamente por lo que devolver√° una tupla *(Nothing,error)*, en el que el segundo elemento corresponder√° al mensaje de error y el primer elemento a un objeto vac√≠o.

Una vez le√≠da la f√≥rmula correctamente podemos extraerla utilizando la funci√≥n *extractReadFLP*. Si utilizamos dicha funci√≥n sobre una f√≥rmula le√≠da incorrectamente, se extraer√° como f√≥rmula la f√≥rmula insatisfactible. 

<pre style="background-color: #2B3856; color: white;"><font color="#555753">----</font> <font color="#06989A">Elm 0.19.1</font> <font color="#555753">----------------------------------------------------------------</font>
<font color="#555753">Say :help for help and :exit to exit! More at &lt;https://elm-lang.org/0.19.1/repl&gt;</font>
<font color="#555753">--------------------------------------------------------------------------------</font>
&gt; import Modules.IO_LP exposing (fromStringToFLP, extractReadFLP, toStringFLP)
&gt; cAux = fromStringToFLP &quot;(p EQUIV q) and (p IMPLIES NOT q) AND p&quot;
(<font color="#34E2E2">Nothing</font>,<font color="#FCE94F">&quot;[{ col = 11, problem = ExpectingSymbol \&quot;)\&quot;, row = 1 }]&quot;</font>)
<font color="#555753">    : ( Maybe Modules.SintaxSemanticsLP.FormulaLP, String )</font>
&gt; c = extractReadFLP cAux
<font color="#34E2E2">Insat</font><font color="#555753"> : Modules.SintaxSemanticsLP.FormulaLP</font>
&gt; toStringFLP c
<font color="#FCE94F">&quot;‚ä•&quot;</font><font color="#555753"> : String</font>
</pre>

$\longrightarrow$ <u>√Årboles de formaci√≥n en Logicous</u>

La librer√≠a tambi√©n permite la representaci√≥n de los √°rboles de formaci√≥n. La funci√≥n *formtree* muestra la representaci√≥n del √°rbol de formaci√≥n en formato texto DOT. 

Por ejemplo para la f√≥rmula $\neg(\neg(p \vee q) \rightarrow (\neg r \wedge s))$:

<pre style="background-color: #2B3856; color: white;"><font color="#555753">----</font> <font color="#06989A">Elm 0.19.1</font> <font color="#555753">----------------------------------------------------------------</font>
<font color="#555753">Say :help for help and :exit to exit! More at &lt;https://elm-lang.org/0.19.1/repl&gt;</font>
<font color="#555753">--------------------------------------------------------------------------------</font>
&gt; import Modules.IO_LP exposing (fromStringToFLP, extractReadFLP, toStringFLP, formTree)
&gt; ejemplo = fromStringToFLP &quot;NOT (NOT (p OR q) IMPLIES (NOT r AND s))&quot;
(<font color="#34E2E2">Just</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>)) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;s&quot;</font>)))),<font color="#FCE94F">&quot;&quot;</font>)
<font color="#555753">    : ( Maybe Modules.SintaxSemanticsLP.FormulaLP, String )</font>
&gt; ejemploF = extractReadFLP ejemplo
<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>)) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;s&quot;</font>)))
<font color="#555753">    : Modules.SintaxSemanticsLP.FormulaLP</font>
&gt; toStringFLP ejemploF
<font color="#FCE94F">&quot;¬¨ ( ¬¨ ( p ‚à® q ) ‚ü∂ ( ¬¨ r ‚àß s ) )&quot;</font><font color="#555753"> : String</font>
&gt; formTree ejemploF
<font color="#FCE94F">&quot;digraph G {\n  rankdir=TB\n  graph []\n  node [shape=plaintext, color=black]\n  edge [dir=none]\n\n  0 -&gt; 1\n  1 -&gt; 2\n  1 -&gt; 6\n  2 -&gt; 3\n  3 -&gt; 4\n  3 -&gt; 5\n  6 -&gt; 7\n  6 -&gt; 9\n  7 -&gt; 8\n\n  0 [label=\&quot;¬¨ ( ¬¨ ( p ‚à® q ) ‚ü∂ ( ¬¨ r ‚àß s ) )\&quot;]\n  1 [label=\&quot;( ¬¨ ( p ‚à® q ) ‚ü∂ ( ¬¨ r ‚àß s ) )\&quot;]\n  2 [label=\&quot;¬¨ ( p ‚à® q )\&quot;]\n  3 [label=\&quot;( p ‚à® q )\&quot;]\n  4 [label=\&quot;p\&quot;]\n  5 [label=\&quot;q\&quot;]\n  6 [label=\&quot;( ¬¨ r ‚àß s )\&quot;]\n  7 [label=\&quot;¬¨ r\&quot;]\n  8 [label=\&quot;r\&quot;]\n  9 [label=\&quot;s\&quot;]\n}&quot;</font>
<font color="#555753">    : String</font>
&gt; 
</pre>

Para poder visualizar el texto en formato DOT se puede utilizar un renderizador graphviz.

N√≥tese que en la consola se muestran los caracteres \\n y \\", estos habr√≠a que sustituirlos antes de d√°rselos al renderizador. En el proyecto se da un renderizador ([Graphviz Visualizer](../../web-sources/pages/GraphVizVisualizer.html)) que permite pegar el c√≥digo tal cual y as√≠ poder visualizar el √°rbol f√°cil y c√≥modamente. (NOTA: no se han de incluir las comillas iniciales y finales, delimitadoras de la cadena).

<center> <img src="images/img2.png" title="GraphvizVisualizer (ejemplo)")></center><br>

#### Conjuntos de f√≥rmulas

Definido $PROP$, los conjuntos de f√≥rmulas no son m√°s que subconjuntos de $PROP$, esto es, corresponden a agrupaciones de f√≥rmulas proposicionales.


##### Conjuntos de f√≥rmulas en Logicus

Los conjuntos proposicionales se definen como listas de f√≥rmulas proposicionales. De esta forma:

    
    type alias LPSet = List FormulaLP

De forma que la definici√≥n de estos se realiza como listas de objetos *FormulaLP*. Si por ejemplo queremos definir el conjunto: 
$$ M = \left\lbrace (p \wedge q) \vee (p \wedge r), (p \wedge r) \vee (\neg p \wedge q) \rightarrow \neg q, (p \leftrightarrow q) \wedge (p \rightarrow \neg q) \wedge p \right\rbrace$$

Podr√≠amos hacerlo:

<pre style="background-color: #2B3856; color: white;"><font color="#555753">----</font> <font color="#06989A">Elm 0.19.1</font> <font color="#555753">----------------------------------------------------------------</font>
<font color="#555753">Say :help for help and :exit to exit! More at &lt;https://elm-lang.org/0.19.1/repl&gt;</font>
<font color="#555753">--------------------------------------------------------------------------------</font>
&gt; import Modules.IO_LP exposing (fromStringToFLP, extractReadFLP, toStringFLP, toStringFLPSet)
&gt; import Modules.SintaxSemanticsLP exposing (..)
&gt; a = fromStringToFLP &quot;(p AND q) OR (p AND r)&quot; |&gt; extractReadFLP
<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>))
<font color="#555753">    : FormulaLP</font>
&gt; b = fromStringToFLP &quot;(p AND r) OR (NOT p AND q) IMPLIES NOT q&quot; |&gt; extractReadFLP
<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>)) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))
<font color="#555753">    : FormulaLP</font>
&gt; c = fromStringToFLP &quot;(p EQUIV q) AND (p IMPLIES NOT q) AND p&quot; |&gt; extractReadFLP
<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Equi</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>))
<font color="#555753">    : FormulaLP</font>
&gt; m : LPSet
| m = [a, b, c]
|   
[<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>)),<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>)) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)),<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Equi</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>))]
<font color="#555753">    : LPSet</font>
&gt; toStringFLPSet m
<font color="#FCE94F">&quot;{( ( p ‚àß q ) ‚à® ( p ‚àß r ) ), ( ( ( p ‚àß r ) ‚à® ( ¬¨ p ‚àß q ) ) ‚ü∂ ¬¨ q ), ( ( p ‚ü∑ q ) ‚àß ( ( p ‚ü∂ ¬¨ q ) ‚àß p ) )}&quot;</font>
<font color="#555753">    : String</font>
</pre>



### Sem√°ntica de la l√≥gica Proposicional

#### Interpretaciones, Modelos, Satisfactibilidad y Validez L√≥gica

Una vez provista la sintaxis, pasamos a desarrollar la sem√°ntica de la L√≥gica Proposicional. Como ya comentamos, hemos de abordar la interpretaci√≥n de certeza o veracidad de las f√≥rmulas. Para esto es necesario conocer los conceptos de *valor de verdad* y *funci√≥n de verdad*.

> -  **Valor de verdad**. Los elementos del conjunto $\{0,1\}$ se denominan valores de verdad o valores booleanos. Representan si un hecho es cierto o no, de forma que el valor $1$ se asocia a *verdadero* y el valor $0$ a *falso*.<br><br>
>  -   **Funciones de verdad**. Corresponden a funciones que devuelven un valor de verdad seg√∫n el valor de verdad de los argumentos. As√≠, el significado (valor de verdad asociado) de cada una de las conectivas l√≥gicas viene dado por una funci√≥n de verdad, de forma que:<br>
    $$\begin{array}{l l} H_{\neg}(i) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = 0\\
        0 & \textrm{si } i = 1\\
        \end{array} \right. & H_{\wedge}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j = 1\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\vee}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right. & H_{\rightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = 1, j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\leftrightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\end{array}$$

Visto esto, pasamos a estudiar el valor de verdad de las f√≥rmulas proposicionales. Para ello debemos definir el valor de verdad de las variables proposicionales, (denominadas *valoraciones* o *interpretaciones*) y a partir de √©stas y las funciones de verdad de las conectivas,podemos extender cada valoraci√≥n,$v$,de forma √∫nica,al conjunto de todas las f√≥rmulas de manera que se verifica:

$$\begin{array}{c c} v((F \wedge G))= H_{\wedge}(v(F), v(G)) & v((F \vee G))= H_{\vee}(v(F), v(G))\\\\ v((F \rightarrow G))= H_{\rightarrow}(v(F), v(G)) & v((F \leftrightarrow G))= H_{\leftrightarrow}(v(F), v(G)) \end{array}$$ 

> Dada una f√≥rmula $F \in PROP$, se dice que $v(F)$ es el valor de verdad de $F$ respecto de la valoraci√≥n $v$.

De esta forma, es sencillo realizar el c√°lculo del valor de verdad de una f√≥rmula respecto de una valoraci√≥n, recurriendo al √°rbol de formaci√≥n de la f√≥rmula, evaluando las subf√≥rmulas, desde las hojas (variables proposicionales) hasta el nodo ra√≠z (la f√≥rmula completa).

Por ejemplo el c√°lculo de la valoraci√≥n de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$:

<center> <img src="images/img3.png" title="C√°lculo de la valoraci√≥n con el AF.")></center><br>

Adem√°s del c√°culo a trav√©s del √Årbol de Formaci√≥n, existe otro m√©todo (equivalente) para el c√°lculo del valor de verdad de una f√≥rmula respecto de una valoraci√≥n, c√°lculo a trav√©s de Tabla. Dado que, dada una valoraci√≥n,$v$, el valor de verdad de una f√≥rmula $F$ respecto de $v$ est√° determinado por los valores de verdad de las subf√≥rmulas de $F$, podemos construir una tabla que recorra los valores de sus subf√≥rmulas. Para el ejemplo anterior: 

<table style="margin-left: auto; margin-right: auto; width:80%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p ‚à® q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(p ‚à® q)</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨r ‚à® s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(p ‚à® q) <span style="font-weight:400;font-style:normal">‚à®</span> <span style="font-style:normal">¬¨(r ‚à® s)</span></th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(<span style="font-style:normal">¬¨(p ‚à® q) </span>‚à® (¬¨r ‚à® s))</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr></tbody></table><br>

##### Tablas de Verdad

Una tabla de verdad corresponde a una estructura similar a la anterior (nosotros s√≥lo reflejaremos el valor de las variables proposicionales y el valor de verdad de la f√≥rmula completa), en la que en cada fila se presenta la valoraci√≥n y el valor de verdad de la f√≥rmula respecto a la misma, para toda interpretaci√≥n posible (que corresponda a las variables proposicionales presentes en la f√≥rmula).

Para la f√≥rmula anterior, su tabla de verdad corresponder√≠a a: 

<table style="margin:auto; width:40%; border-collapse:collapse;border-color:#ccc;border-spacing:0" class="tg"><thead><tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">p</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">q</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">r</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">s</th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">¬¨(<span style="font-style:normal">¬¨(p ‚à® q) </span>‚à® (¬¨ r ‚à® s))</th></tr></thead><tbody><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td></tr><tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">1</td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal">0</td></tr></tbody></table>


##### Modelos, Satisfactibilidad y Validez L√≥gica

Una vez estudiado lo anterior, vamos dar unas cuantas definiciones:

> -  **Modelo.** Se dice que una f√≥rmula $F$ es v√°lida en una valoraci√≥n $v$ o equivalentemente que $v$ es **modelo** de $F$ si $v(F)=1$ y se denota por $v \models F$. En caso contrario, se dice que $v$ es **contramodelo** de $F$ y se denota $v \not \models F$.<br><br>
> - **Satisfactibilidad.** Una f√≥rmula $F$ se dice **satisfactible** (o consistente) si existe una valoraci√≥n $v$ que es modelo de $F$. En caso contrario se dice que $F$ es **insatisfactible** (o inconsistente), y se representa por $\perp$.<br><br>
> - **Validez l√≥gica o Tautolog√≠a**. Una f√≥rmula $F$ se dice **tautolog√≠a** (o (l√≥gicamente) v√°lida) si toda valoraci√≥n es modelo de $F$ y se denota $\models F$.<br>

$\longrightarrow$ <u>Relaci√≥n entre Validez y Satisfactibilidad</u>

> *LEMA*: Para cada $F \in PROP$ se verifica:
> -  Si $F$ es tautolog√≠a, entonces $F$ es satisfactible.<br>
> -  $F$ es tautolog√≠a si y s√≥lo si $F$ es insatisfactible.<br>

<br>
##### Sem√°ntica de F√≥rmulas LP en Logicous

La librer√≠a dispone de funciones que modelan todos los conceptos sem√°nticos que hemos visto hasta ahora.

$\longrightarrow$ <u>Valores, Funciones de Verdad e Interpretaciones</u>

Como hemos estudiado los **valores de verdad** corresponden a 1 (*verdadero*) y 0 (*falso*). Elm ya provee esos valores booleanos en el tipo *Bool*, por lo que no es necesario realizar ninguna definici√≥n alternativa para este concepto.

Las definici√≥n de las funciones de verdad asociadas a las conectivas corresponden directamente a la aplicaci√≥n de dichas funciones en la evaluaci√≥n de las f√≥rmulas. Antes de ver la evaluaci√≥n resulta necesario ver la definici√≥n que se ha dado para las interpretaciones. Para ello, se ha elegido una representaci√≥n "dispersa" de manera que una interpretaci√≥n corresponde a una lista de s√≠mbolos proposicionales (variables proposicionales) que son los que son considerados verdaderos, los t√©rminos que no aparecen en la lista ser√°n considerados como falsos.

    type alias Interpretation = List PSymb

Con esta definici√≥n resulta sencillo llevar a cabo la evaluaci√≥n de las f√≥rmulas. Tal y como se ha planteado formamelte, podemos distinguir el proceso de evaluaci√≥n en 2 casos:

- **Evaluaci√≥n de variables**. Una variable ser√° verdadera si en la interpretaci√≥n le otorga dicho valor, esto es, seg√∫n la definici√≥n dada, ser√° verdadera si pertenece a la lista de la interpretaci√≥n, y ser√° falsa en caso contrario.

- **Evaluaci√≥n de conectivas**. Seg√∫n la definici√≥n formal dada:
$$\begin{array}{l l} H_{\neg}(i) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = 0\\
        0 & \textrm{si } i = 1\\
        \end{array} \right. & H_{\wedge}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j = 1\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\vee}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right. & H_{\rightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        0 & \textrm{si } i = 1, j = 0\\
        1 & \textrm{e.o.c}\\
        \end{array} \right.\\\\ H_{\leftrightarrow}(i,j) = \left\lbrace \begin{array}{l l}
        1 & \textrm{si } i = j\\
        0 & \textrm{e.o.c}\\
        \end{array} \right.\end{array}$$

De forma que:

    valuation : FormulaLP -> Interpretation -> Bool
    valuation pr i =
        case pr of
            Atom p -> List.member p i
            Neg p -> not (valuation p i)
            Conj p q -> valuation p i &&  valuation q i
            Disj p q ->   valuation p i ||  valuation q i
            Impl p q ->   not (valuation p i) ||  valuation q i
            Equi p q ->   valuation (Impl p q) i &&  valuation (Impl q p) i
            Insat -> Basics.False

NOTA: n√≥tese que la f√≥rmula insatisfactible, l√≥gicamente, es falsa respecto de cualquier valoraci√≥n.

De forma que la funci√≥n *valuation* nos permite calcular la valoraci√≥n de una f√≥rmula respecto de una valoraci√≥n. Por ejemplo, calculemos la valoraci√≥n de $F \equiv \neg(\neg(p \vee q)\vee(\neg r \vee s))$ respecto de $v \equiv \{p=1, q=1, r=0, s=0\}$:

<pre style="background-color: #2B3856; color: white;"><font color="#555753">----</font> <font color="#06989A">Elm 0.19.1</font> <font color="#555753">----------------------------------------------------------------</font>
<font color="#555753">Say :help for help and :exit to exit! More at &lt;https://elm-lang.org/0.19.1/repl&gt;</font>
<font color="#555753">--------------------------------------------------------------------------------</font>
&gt; import Modules.IO_LP exposing (..)
&gt; import Modules.SintaxSemanticsLP exposing (..)
&gt; f = fromStringToFLP &quot;NOT (NOT (p OR q) OR (NOT r OR s))&quot; |&gt; extractReadFLP
<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>))) (<font color="#34E2E2">Disj</font> (<font color="#34E2E2">Neg</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>)) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;s&quot;</font>)))
<font color="#555753">    : FormulaLP</font>
&gt; i : Interpretation
| i = [&quot;p&quot;,&quot;q&quot;]
|   
[<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;q&quot;</font>]<font color="#555753"> : Interpretation</font>
&gt; valuation f i
<font color="#34E2E2">False</font><font color="#555753"> : Bool</font>
</pre>

$\longrightarrow$ <u>Tabla de Verdad, Modelos, Satisfactibilidad y Validez </u>

Como se ha expuesto anteriormente una tabla de verdad recoge las valoraciones de una f√≥rmula respecto a todas las posibles interpretaciones que integran a sus s√≠mbolos proposicionales. Bien dada la definici√≥n de las interpretaciones resulta bien sencillo el c√°lculo de todas las posibles interpretaciones, de hecho el conjunto de interpretaciones corrsponde a todos los posibles subconjuntos del conjunto formado por los s√≠mbolos proposicionales que participan en la f√≥rmula. De esta forma:

    symbInProp : FormulaLP -> Set.Set PSymb
    symbInProp f=
        case f of
            Atom p -> Set.singleton p
            Neg p -> symbInProp p
            Conj p q -> Set.union (symbInProp p ) (symbInProp q)
            Disj p q -> Set.union (symbInProp p ) (symbInProp q)
            Impl p q -> Set.union (symbInProp p ) (symbInProp q)
            Equi p q -> Set.union (symbInProp p ) (symbInProp q)
            Insat -> Set.empty

    allInterpretations : FormulaLP -> List Interpretation
    allInterpretations x =  Aux.powerset <| List.sort <| Set.toList <| symbInProp x

Y la tabla de verdad corresponde al conjunto de pares (*Interpretaci√≥n, Valoraci√≥n*), que corresponde a las entradas cada una de las entradas (filas) de la tabla.

    truthTable : FormulaLP -> List (Interpretation, Bool)
    truthTable x = List.map (\xs ->  (xs,valuation x xs)) <| allInterpretations x

Para el ejemplo anterior:

<pre style="background-color: #2B3856; color: white;">
&gt; truthTable f
[([],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;s&quot;</font>],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;r&quot;</font>],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;r&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;q&quot;</font>],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>],<font color="#34E2E2">True</font>),([<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;p&quot;</font>],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>],<font color="#34E2E2">True</font>),([<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;q&quot;</font>],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],<font color="#34E2E2">False</font>),([<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>],<font color="#34E2E2">True</font>),([<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],<font color="#34E2E2">False</font>)]
<font color="#555753">    : List ( Interpretation, Bool )</font>
</pre>

Una vez calculadas todas las posibles interpretaciones resulta sencillo calcular los modelos y contramodelos de una f√≥rmula proposicional, sin m√°s que seleccionar aquellos que sean evaluados como verdaderos o falsos, respectivamente. Tal que:

    models : FormulaLP -> List Interpretation
    models x = List.filter (\y -> valuation x y) (allInterpretations x)

    countermodels : FormulaLP -> List Interpretation
    countermodels x = List.filter (\y -> not(valuation x y)) (allInterpretations x)

De forma que para la f√≥rmula anterior, el conjunto de modelos y contramodelos corresponder√≠a a:

<pre style="background-color: #2B3856; color: white;">
&gt; models f
[[<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>]]
<font color="#555753">    : List Interpretation</font>
&gt; countermodels f
[[],[<font color="#FCE94F">&quot;s&quot;</font>],[<font color="#FCE94F">&quot;r&quot;</font>],[<font color="#FCE94F">&quot;r&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],[<font color="#FCE94F">&quot;q&quot;</font>],[<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],[<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;q&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>,<font color="#FCE94F">&quot;s&quot;</font>]]
<font color="#555753">    : List Interpretation</font>
</pre>

Del mismo modo resulta casi trivial decidir la satisfactibilidad y validez de las f√≥rmulas proposicionales, sin m√°s que comprobar si todas las interpretaciones hacen a la f√≥rmula verdadera (*tautolog√≠a*), alguna de ellas la hace verdadera (*f√≥rmula satisfactible*), o no la hace ninguna de ellas (*f√≥rmula insatisfactible*). As√≠:


    satisfactibility : FormulaLP -> Bool
    satisfactibility x = List.any (\xs-> valuation x xs) (allInterpretations x)

    validity : FormulaLP -> Bool
    validity x = List.all (\xs-> valuation x xs) (allInterpretations x)

    insatisfactibility : FormulaLP -> Bool
    insatisfactibility x = List.all (\xs-> not(valuation x xs)) (allInterpretations x)

De forma que en el caso dela f√≥rmula anterior, sabemos que es satisfactible ya que el conjunto de modelos no era vac√≠o, y que no es tautolog√≠a ya que el de contramodelos tampoco lo era. Utilizando las funciones provistas por la librer√≠a:

<pre style="background-color: #2B3856; color: white;">
&gt; satisfactibility f
<font color="#34E2E2">True</font><font color="#555753"> : Bool</font>
&gt; validity f
<font color="#34E2E2">False</font><font color="#555753"> : Bool</font>
&gt; insatisfactibility f
<font color="#34E2E2">False</font><font color="#555753"> : Bool</font>
</pre>


#### Conjuntos de F√≥rmulas. Modelos y Consistencia.

De forma an√°loga a la presentada para las f√≥rmulas proposicionales podemos definir los conceptos anteriores, aplicados a conjuntos de f√≥rmulas de forma que:

>- **Modelo.** Se dice que una valoraci√≥n $v$ es **modelo** de un conjunto de f√≥rmulas $U$ si para toda f√≥rmula $F \in U$ se tiene que $v(F)=1$ y se denota por $v \models U$. En caso contrario, se dice **contramodelo**.<br><br>
> -   **Consistencia** Un conjunto de f√≥rmulas $U$ se dice **consistente** si existe una valoraci√≥n $v$ que es modelo de $U$. En caso contrario se dice que $U$ es **inconsistente**.


##### Consecuencia L√≥gica.

>Una f√≥rmula $F$ es consecuencia l√≥gica (o se sigue) de un conjunto de f√≥rmulas $U$, y se denota por $U \models F$, si toda valoraci√≥n que es modelo de $U$ es tambi√©n modelo de $F$.

Es precisamente este concepto el que permite formular el problema b√°sico en el marco de la l√≥gica proposicional, que planteamos como objetivo de la LP.

##### Relaci√≥n entre consecuencia l√≥gica, consistencia y validez

> *PROPOSICI√ìN*: Sea $U = \{F_1, F_2, \ldots, F_n \} \subseteq PROP$ y $F \in PROP$ son equivalentes:
>- $(U = \{F_1, F_2, \ldots, F_n \}) \models F$<br><br>
>- $\left(\bigwedge \limits_{F_i} U = (F_1 \wedge F_2 \wedge \ldots \wedge F_n)\right) \rightarrow F \in TAUT$<br><br>
>- $\left( U \cup \{\neg F\} = \{F_1 , F_2 , \ldots , F_n , \neg F\} \right) \models \perp$

##### Sem√°ntica de Conjuntos LP en Logicous

Al igual que en el caso de las f√≥rmulas proposicionales podemos realizar una traslaci√≥n directa de los conceptos formalmente expuestos a las implementaciones, de forma que el c√°lculo de las posibles interpretaciones, an√°logamente al caso de las f√≥rmulas, se reduce al c√°lculo de los posibles subconjuntos de los s√≠mbolos proposicionales presentes en las f√≥rmulas, correspondientes a la uni√≥n de los conjuntos de s√≠mbolos asociados a cada una de las f√≥rmulas. De esta forma:

    setSymbols : List FormulaLP -> Set.Set PSymb
    setSymbols xs = List.foldr (\x acc -> Set.union acc (symbInProp x)) Set.empty xs

    allSetInterpretations : List FormulaLP -> List Interpretation
    allSetInterpretations xs = Aux.powerset <| Set.toList <| setSymbols xs

De forma que el c√°lculo de los modelos, contramodelos, consistencia e inconsistencia se reduce a aplicar las definiciones sobre el conjunto de f√≥rmulas:

    isSetModel : List FormulaLP -> Interpretation -> Bool
    isSetModel xs i =  List.all (\x -> valuation x i) xs

    allSetModels : List FormulaLP -> List Interpretation
    allSetModels xs = List.filter (isSetModel xs) (allSetInterpretations xs)

    allSetCounterModels : List FormulaLP -> List Interpretation
    allSetCounterModels xs = List.filter (\x -> not(isSetModel xs x)) <| allSetInterpretations xs

    isConsistent : List FormulaLP -> Bool
    isConsistent xs = List.any (\x -> isSetModel xs x) <| allSetInterpretations xs

    isInconsistent: List FormulaLP -> Bool
    isInconsistent xs = not(isConsistent xs)

$\longrightarrow$ <u>Consecuencia l√≥gica</u>

Dada la definici√≥n de conseciencia l√≥gica y teniendo en cuenta la relaci√≥n entre consecuencia l√≥gica, consistencia y validez (√∫ltimo caso), funcionalmente hemos planteado dos desarrollos alternativos para el concepto de Consecuencia L√≥gica:

(1) Acudiendo a la propia definici√≥n. (2) Acudiendo al tercer punto de la proposici√≥n anterior.

    isConsecuence : List FormulaLP -> FormulaLP -> Bool
    -- isConsecuence xs x = List.all (\y -> valuation x y) <| allSetModels xs
    isConsecuence xs x = isInconsistent (xs ++ [Neg x])

NOTA: Se ha dejado la segunda como implementaci√≥n final.

Ve√°mos un ejemplo, dado el conjunto de f√≥rmulas $U=\{p \rightarrow q,q \rightarrow p \wedge r\}$ y la f√≥rmula $ F = p \rightarrow (p \rightarrow q) \rightarrow r$, ve√°mos si se cumple $U \models F$.

<pre style="background-color: #2B3856; color: white;">
<font color="#555753">----</font> <font color="#06989A">Elm 0.19.1</font> <font color="#555753">----------------------------------------------------------------</font>
<font color="#555753">Say :help for help and :exit to exit! More at &lt;https://elm-lang.org/0.19.1/repl&gt;</font>
<font color="#555753">--------------------------------------------------------------------------------</font>
&gt; import Modules.IO_LP exposing (..)
&gt; import Modules.SintaxSemanticsLP exposing (..)
&gt; u1 = fromStringToFLP &quot;p IMPLIES q&quot; |&gt; extractReadFLP
<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)
<font color="#555753">    : FormulaLP</font>
&gt; u2 = fromStringToFLP &quot;q IMPLIES p AND r&quot; |&gt; extractReadFLP
<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>))
<font color="#555753">    : FormulaLP</font>
&gt; uSet = [u1, u2]
[<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>),<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>) (<font color="#34E2E2">Conj</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>))]
<font color="#555753">    : List FormulaLP</font>
&gt; f = fromStringToFLP &quot;p IMPLIES (p IMPLIES q) IMPLIES r&quot; |&gt; extractReadFLP
<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Impl</font> (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;p&quot;</font>) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;q&quot;</font>)) (<font color="#34E2E2">Atom</font> <font color="#FCE94F">&quot;r&quot;</font>))
<font color="#555753">    : FormulaLP</font>
&gt; isConsecuence uSet  f
<font color="#34E2E2">True</font><font color="#555753"> : Bool</font>
</pre>

De hecho, acudiendo a la definici√≥n podemos ver que, en efecto, todo modelo del conjunto $U$ es tambi√©n modelo de la f√≥rmula $F$.

<pre style="background-color: #2B3856; color: white;">
&gt; allSetModels uSet
[[],[<font color="#FCE94F">&quot;r&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>]]
<font color="#555753">    : List Interpretation</font>
&gt; models f
[[],[<font color="#FCE94F">&quot;r&quot;</font>],[<font color="#FCE94F">&quot;q&quot;</font>],[<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>],[<font color="#FCE94F">&quot;p&quot;</font>,<font color="#FCE94F">&quot;q&quot;</font>,<font color="#FCE94F">&quot;r&quot;</font>]]
<font color="#555753">    : List Interpretation</font>
</pre>

### Algoritmos de decisi√≥n en LP

Como hemos se√±alado vamos a presentar de forma somera los algoritmos de decisi√≥n en LP, e iremos desarrollando algunos de los algoritmos m√°s importantes a lo largo de los distintos cap√≠tulos.

> Dado un conjunto de f√≥rmulas $U$, un **algoritmo de decisi√≥n** para $U$ es aqu√©l que dada una f√≥rmula $A \in PROP$, devuelve `SI` cuando $A \in U$ y `NO` cuando $A \not\in U$

Esto da pie a la definici√≥n de algunos problemas con un especial inter√©s:

> - $SAT = \{A \in PROP: \, A \textit{ es satisfactible}\}$.
> - $TAUT = \{A \in PROP: \, A \textit{ es tautolog√≠a}\}$.
> - Fijado $U \subseteq PROP$, la *Teor√≠a de $U$* corresponde a: $\mathcal{T}(U) = \{A \in PROP: \, U \models A\}$.

Precisamente, un algoritmo de decisi√≥n para $\mathcal{T}(U)$ proporciona una respuesta al Problema B√°sico que planteamos al comienzo del cap√≠tulo. Por tanto, podemos reducir dicho problema a uno nuevo: 
> Obtener un algoritmo que, dado un conjunto finito de f√≥rmulas proposicionales, $U$, y una f√≥rmula, $F$, decida si $U \models F$.

Y este a su vez se reduce a comprobar la satisfactibilidad de una cierta f√≥rmula (o bien la validez de otra), hemos aqu√≠ el problema conocido como *Problema $SAT$*.

Notemos que ya hemos visto un algoritmo, el de las Tablas de Verdad, que resuelve, de forma simple, el problema, pero la complejidad de dicho algoritmo es exponencial en el n√∫mero de s√≠mbolos proposicionales, lo que lo hace inabordable para f√≥rmulas de cierta complejidad , incluso computacionalmente.

Hemos de se√±alar que existen otros algoritmos de decisi√≥n del problema $SAT$, algunos de los cuales abordaremos a lo largo de los siguientes cap√≠tulos, pero a√∫n no se ha encontrado ninguno capaz de resolver el problema eficientemente (complejidad polinomial), y, de hecho, se duda (fuertemente) de la existencia del mismo. De hecho, determinar la satisfactibilidad de una f√≥rmula proposicional se trata de un problema NP-completo.

1.3 De Proposiciones a Predicados. 
Conceptos B√°sicos de L√≥gica de Primer Orden
----------------------------------------------------

### Limitaciones de la L√≥gica Proposicional

Aunque la l√≥gica proposicional posee un sem√°ntica sencilla y existen algoritmos de decisi√≥n (poco eficientes) para sus problemas b√°sicos, como $SAT$ o la consecuencia l√≥gica, la expresividad de LP es bastante limitada, esto hace que muchos problemas no sean modelables en LP, bien porque requieren un gran n√∫mero de f√≥rmulas o f√≥rmulas de gran tama√±o, o
bien porque no puedan ni siquiera expresarse en este lenguaje. El siguiente ejemplo presenta un razonamiento que es v√°lido, sin embargo no es expresable en LP:

‚Äã1. Todo hombre es mortal.
2. S√≥crates es hombre. 
3. Por tanto, S√≥crates es mortal.

¬øC√≥mo expresar el concepto de ser hombre?¬øComo expresar qui√©n es S√≥crates?, pero a√∫n m√°s ¬øC√≥mo expresar que todos es mortal?. Es aqu√≠ precisamente donde comienza el √°mbito de la L√≥gica de PrimerOrden.

### Caracterizaci√≥n de la L√≥gica de Primer Orden

La **L√≥gica de Primer Orden** o **L√≥gica de Predicados** es un sistema formal dise√±ado para estudiar los m√©todos inferenciales en los leguajes de primer orden. Un **lenguaje de primer orden** corresponde a un lenguaje formal que consta de:

- <u>S√≠mbolos l√≥gicos</u> (comunes a todos los lenguajes): En los que se engloban:

    -   Un conjunto de *Variables:* $V = \{x, x_0, x_1, \ldots, y, y_0, \ldots \}$

    -   *Conectivas l√≥gicas :* $\neg$ (negaci√≥n), $\wedge$ (conjunci√≥n), $\vee$ (disyunci√≥n), $\rightarrow$ (implicaci√≥n), $\leftrightarrow$ (equivalencia).

    -   *Cuantificadores:* $\exists$ (existencial), $\forall$ (universal).

    -   *S√≠mbolos auxiliares:* $`('$ y $`)'$<br><br>

-   <u>S√≠mbolos no l√≥gicos</u> (propios de cada lenguaje): En los que se engloban:

    -   Un conjunto de *Constantes:* $L_{C}= \{a, b, \ldots, a_{0}, a_{1}, \ldots \}$

    -   Un conjunto de *s√≠mbolos de funci√≥n:* $L_{F} = \{f_{0}, f_{1}, \ldots\}$, cada uno con su aridad correspondiente.

    -   Un conjunto de **s√≠mbolos de predicado:** $L_P=\{P_{0}, P_{1}, \ldots, Q, Q_0, \ldots\}$, cada uno con su aridad correspondiente.
    
        Dos notas:

        -   Los s√≠mpolos de predicado de aridad 0 act√∫an como s√≠mbolos proposicionales.

        -   El s√≠mbolo de igualdad (‚Äò$=$‚Äô) no es un predicado com√∫n a todos los lenguajes de primer orden, pero si es corriente su aparici√≥n. La familia de lenguajes que incluyen este predicado es denominada *Lenguajes de Primer Orden con Igualdad*.

1.4. Fundamentos de la L√≥gica de Primer Orden
----------------------------------------------------

$\boxed{TO \, DO}$


